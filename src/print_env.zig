const std = @import("std");
const build_options = @import("build_options");
const introspect = @import("introspect.zig");
const Allocator = std.mem.Allocator;
const fatal = std.process.fatal;

pub fn cmdEnv(arena: Allocator, args: []const []const u8) !void {
    _ = args;
    const cwd_path = try introspect.getResolvedCwd(arena);
    const self_exe_path = try std.fs.selfExePathAlloc(arena);

    var zig_lib_directory = introspect.findZigLibDirFromSelfExe(arena, cwd_path, self_exe_path) catch |err| {
        fatal("unable to find zig installation directory: {s}\n", .{@errorName(err)});
    };
    defer zig_lib_directory.handle.close();

    const zig_std_dir = try std.fs.path.join(arena, &[_][]const u8{ zig_lib_directory.path.?, "std" });

    const global_cache_dir = try introspect.resolveGlobalCacheDir(arena);

    const host = try std.zig.system.resolveTargetQuery(.{});
    const triple = try host.zigTriple(arena);

    var buffer: [1024]u8 = undefined;
    var bw: std.io.BufferedWriter = .{
        .buffer = &buffer,
        .unbuffered_writer = std.io.getStdOut().writer(),
    };
    var jws: std.json.Stringify = .{ .writer = &bw, .options = .{ .whitespace = .indent_1 } };

    try jws.beginObject();

    try jws.objectField("zig_exe");
    try jws.write(self_exe_path);

    try jws.objectField("lib_dir");
    try jws.write(zig_lib_directory.path.?);

    try jws.objectField("std_dir");
    try jws.write(zig_std_dir);

    try jws.objectField("global_cache_dir");
    try jws.write(global_cache_dir);

    try jws.objectField("version");
    try jws.write(build_options.version);

    try jws.objectField("target");
    try jws.write(triple);

    try jws.objectField("env");
    try jws.beginObject();
    inline for (@typeInfo(std.zig.EnvVar).@"enum".fields) |field| {
        try jws.objectField(field.name);
        try jws.write(try @field(std.zig.EnvVar, field.name).get(arena));
    }
    try jws.endObject();

    try jws.endObject();
    try bw.writeByte('\n');

    try bw.flush();
}
