//! Autogenerated by GenerateDef from src/aro/Diagnostics/messages.def, do not edit
// zig fmt: off

const std = @import("std");

pub fn with(comptime Properties: type) type {
return struct {
const W = Properties.makeOpt;
const pointer_sign_message = " converts between pointers to integer types with different sign";
const expected_arguments = "expected {d} argument(s) got {d}";
pub const Tag = enum {
    todo,
    error_directive,
    warning_directive,
    elif_without_if,
    elif_after_else,
    elifdef_without_if,
    elifdef_after_else,
    elifndef_without_if,
    elifndef_after_else,
    else_without_if,
    else_after_else,
    endif_without_if,
    unknown_pragma,
    line_simple_digit,
    line_invalid_filename,
    unterminated_conditional_directive,
    invalid_preprocessing_directive,
    macro_name_missing,
    extra_tokens_directive_end,
    expected_value_in_expr,
    closing_paren,
    to_match_paren,
    to_match_brace,
    to_match_bracket,
    header_str_closing,
    header_str_match,
    string_literal_in_pp_expr,
    float_literal_in_pp_expr,
    defined_as_macro_name,
    macro_name_must_be_identifier,
    whitespace_after_macro_name,
    hash_hash_at_start,
    hash_hash_at_end,
    pasting_formed_invalid,
    missing_paren_param_list,
    unterminated_macro_param_list,
    invalid_token_param_list,
    expected_comma_param_list,
    hash_not_followed_param,
    expected_filename,
    empty_filename,
    expected_invalid,
    expected_eof,
    expected_token,
    expected_expr,
    expected_integer_constant_expr,
    missing_type_specifier,
    missing_type_specifier_c23,
    multiple_storage_class,
    static_assert_failure,
    static_assert_failure_message,
    expected_type,
    cannot_combine_spec,
    duplicate_decl_spec,
    restrict_non_pointer,
    expected_external_decl,
    expected_ident_or_l_paren,
    missing_declaration,
    func_not_in_root,
    illegal_initializer,
    extern_initializer,
    spec_from_typedef,
    param_before_var_args,
    void_only_param,
    void_param_qualified,
    void_must_be_first_param,
    invalid_storage_on_param,
    threadlocal_non_var,
    func_spec_non_func,
    illegal_storage_on_func,
    illegal_storage_on_global,
    expected_stmt,
    func_cannot_return_func,
    func_cannot_return_array,
    undeclared_identifier,
    not_callable,
    unsupported_str_cat,
    static_func_not_global,
    implicit_func_decl,
    unknown_builtin,
    implicit_builtin,
    implicit_builtin_header_note,
    expected_param_decl,
    invalid_old_style_params,
    expected_fn_body,
    invalid_void_param,
    unused_value,
    continue_not_in_loop,
    break_not_in_loop_or_switch,
    unreachable_code,
    duplicate_label,
    previous_label,
    undeclared_label,
    case_not_in_switch,
    duplicate_switch_case,
    multiple_default,
    previous_case,
    expected_arguments,
    expected_arguments_old,
    expected_at_least_arguments,
    invalid_static_star,
    static_non_param,
    array_qualifiers,
    star_non_param,
    variable_len_array_file_scope,
    useless_static,
    negative_array_size,
    array_incomplete_elem,
    array_func_elem,
    static_non_outermost_array,
    qualifier_non_outermost_array,
    unterminated_macro_arg_list,
    unknown_warning,
    overflow,
    int_literal_too_big,
    indirection_ptr,
    addr_of_rvalue,
    addr_of_bitfield,
    not_assignable,
    ident_or_l_brace,
    empty_enum,
    redefinition,
    previous_definition,
    expected_identifier,
    expected_str_literal,
    expected_str_literal_in,
    parameter_missing,
    empty_record,
    empty_record_size,
    wrong_tag,
    expected_parens_around_typename,
    alignof_expr,
    invalid_alignof,
    invalid_sizeof,
    macro_redefined,
    generic_qual_type,
    generic_array_type,
    generic_func_type,
    generic_duplicate,
    generic_duplicate_here,
    generic_duplicate_default,
    generic_no_match,
    escape_sequence_overflow,
    invalid_universal_character,
    incomplete_universal_character,
    multichar_literal_warning,
    invalid_multichar_literal,
    wide_multichar_literal,
    char_lit_too_wide,
    char_too_large,
    must_use_struct,
    must_use_union,
    must_use_enum,
    redefinition_different_sym,
    redefinition_incompatible,
    redefinition_of_parameter,
    invalid_bin_types,
    comparison_ptr_int,
    comparison_distinct_ptr,
    incompatible_pointers,
    invalid_argument_un,
    incompatible_assign,
    implicit_ptr_to_int,
    invalid_cast_to_float,
    invalid_cast_to_pointer,
    invalid_cast_type,
    qual_cast,
    invalid_index,
    invalid_subscript,
    array_after,
    array_before,
    statement_int,
    statement_scalar,
    func_should_return,
    incompatible_return,
    incompatible_return_sign,
    implicit_int_to_ptr,
    func_does_not_return,
    void_func_returns_value,
    incompatible_arg,
    incompatible_ptr_arg,
    incompatible_ptr_arg_sign,
    parameter_here,
    atomic_array,
    atomic_func,
    atomic_incomplete,
    addr_of_register,
    variable_incomplete_ty,
    parameter_incomplete_ty,
    tentative_array,
    deref_incomplete_ty_ptr,
    alignas_on_func,
    alignas_on_param,
    minimum_alignment,
    maximum_alignment,
    negative_alignment,
    align_ignored,
    zero_align_ignored,
    non_pow2_align,
    pointer_mismatch,
    static_assert_not_constant,
    static_assert_missing_message,
    pre_c23_compat,
    unbound_vla,
    array_too_large,
    incompatible_ptr_init,
    incompatible_ptr_init_sign,
    incompatible_ptr_assign,
    incompatible_ptr_assign_sign,
    vla_init,
    func_init,
    incompatible_init,
    empty_scalar_init,
    excess_scalar_init,
    excess_str_init,
    excess_struct_init,
    excess_array_init,
    str_init_too_long,
    arr_init_too_long,
    invalid_typeof,
    division_by_zero,
    division_by_zero_macro,
    builtin_choose_cond,
    alignas_unavailable,
    case_val_unavailable,
    enum_val_unavailable,
    incompatible_array_init,
    array_init_str,
    initializer_overrides,
    previous_initializer,
    invalid_array_designator,
    negative_array_designator,
    oob_array_designator,
    invalid_field_designator,
    no_such_field_designator,
    empty_aggregate_init_braces,
    ptr_init_discards_quals,
    ptr_assign_discards_quals,
    ptr_ret_discards_quals,
    ptr_arg_discards_quals,
    unknown_attribute,
    ignored_attribute,
    invalid_fallthrough,
    cannot_apply_attribute_to_statement,
    builtin_macro_redefined,
    feature_check_requires_identifier,
    missing_tok_builtin,
    gnu_label_as_value,
    expected_record_ty,
    member_expr_not_ptr,
    member_expr_ptr,
    no_such_member,
    malformed_warning_check,
    invalid_computed_goto,
    pragma_warning_message,
    pragma_error_message,
    pragma_message,
    pragma_requires_string_literal,
    poisoned_identifier,
    pragma_poison_identifier,
    pragma_poison_macro,
    newline_eof,
    empty_translation_unit,
    omitting_parameter_name,
    non_int_bitfield,
    negative_bitwidth,
    zero_width_named_field,
    bitfield_too_big,
    invalid_utf8,
    implicitly_unsigned_literal,
    invalid_preproc_operator,
    invalid_preproc_expr_start,
    c99_compat,
    unexpected_character,
    invalid_identifier_start_char,
    unicode_zero_width,
    unicode_homoglyph,
    meaningless_asm_qual,
    duplicate_asm_qual,
    invalid_asm_str,
    dollar_in_identifier_extension,
    dollars_in_identifiers,
    expanded_from_here,
    skipping_macro_backtrace,
    pragma_operator_string_literal,
    unknown_gcc_pragma,
    unknown_gcc_pragma_directive,
    predefined_top_level,
    incompatible_va_arg,
    too_many_scalar_init_braces,
    uninitialized_in_own_init,
    gnu_statement_expression,
    stmt_expr_not_allowed_file_scope,
    gnu_imaginary_constant,
    plain_complex,
    complex_int,
    qual_on_ret_type,
    cli_invalid_standard,
    cli_invalid_target,
    cli_invalid_emulate,
    cli_unknown_arg,
    cli_error,
    cli_unused_link_object,
    cli_unknown_linker,
    extra_semi,
    func_field,
    vla_field,
    field_incomplete_ty,
    flexible_in_union,
    flexible_non_final,
    flexible_in_empty,
    duplicate_member,
    binary_integer_literal,
    gnu_va_macro,
    builtin_must_be_called,
    va_start_not_in_func,
    va_start_fixed_args,
    va_start_not_last_param,
    attribute_not_enough_args,
    attribute_too_many_args,
    attribute_arg_invalid,
    unknown_attr_enum,
    attribute_requires_identifier,
    declspec_not_enabled,
    declspec_attr_not_supported,
    deprecated_declarations,
    deprecated_note,
    unavailable,
    unavailable_note,
    warning_attribute,
    error_attribute,
    ignored_record_attr,
    backslash_newline_escape,
    array_size_non_int,
    cast_to_smaller_int,
    gnu_switch_range,
    empty_case_range,
    non_standard_escape_char,
    invalid_pp_stringify_escape,
    vla,
    float_overflow_conversion,
    float_out_of_range,
    float_zero_conversion,
    float_value_changed,
    float_to_int,
    const_decl_folded,
    const_decl_folded_vla,
    redefinition_of_typedef,
    undefined_macro,
    fn_macro_undefined,
    preprocessing_directive_only,
    missing_lparen_after_builtin,
    offsetof_ty,
    offsetof_incomplete,
    offsetof_array,
    pragma_pack_lparen,
    pragma_pack_rparen,
    pragma_pack_unknown_action,
    pragma_pack_show,
    pragma_pack_int,
    pragma_pack_int_ident,
    pragma_pack_undefined_pop,
    pragma_pack_empty_stack,
    cond_expr_type,
    too_many_includes,
    enumerator_too_small,
    enumerator_too_large,
    include_next,
    include_next_outside_header,
    enumerator_overflow,
    enum_not_representable,
    enum_too_large,
    enum_fixed,
    enum_prev_nonfixed,
    enum_prev_fixed,
    enum_different_explicit_ty,
    enum_not_representable_fixed,
    transparent_union_wrong_type,
    transparent_union_one_field,
    transparent_union_size,
    transparent_union_size_note,
    designated_init_invalid,
    designated_init_needed,
    ignore_common,
    ignore_nocommon,
    non_string_ignored,
    local_variable_attribute,
    ignore_cold,
    ignore_hot,
    ignore_noinline,
    ignore_always_inline,
    invalid_noreturn,
    nodiscard_unused,
    warn_unused_result,
    invalid_vec_elem_ty,
    vec_size_not_multiple,
    invalid_imag,
    invalid_real,
    zero_length_array,
    old_style_flexible_struct,
    comma_deletion_va_args,
    main_return_type,
    expansion_to_defined,
    invalid_int_suffix,
    invalid_float_suffix,
    invalid_octal_digit,
    invalid_binary_digit,
    exponent_has_no_digits,
    hex_floating_constant_requires_exponent,
    sizeof_returns_zero,
    declspec_not_allowed_after_declarator,
    declarator_name_tok,
    type_not_supported_on_target,
    bit_int,
    unsigned_bit_int_too_small,
    signed_bit_int_too_small,
    bit_int_too_big,
    keyword_macro,
    ptr_arithmetic_incomplete,
    callconv_not_supported,
    pointer_arith_void,
    sizeof_array_arg,
    array_address_to_bool,
    string_literal_to_bool,
    constant_expression_conversion_not_allowed,
    invalid_object_cast,
    cli_invalid_fp_eval_method,
    suggest_pointer_for_invalid_fp16,
    bitint_suffix,
    auto_type_extension,
    auto_type_not_allowed,
    auto_type_requires_initializer,
    auto_type_requires_single_declarator,
    auto_type_requires_plain_declarator,
    invalid_cast_to_auto_type,
    auto_type_from_bitfield,
    array_of_auto_type,
    auto_type_with_init_list,
    missing_semicolon,
    tentative_definition_incomplete,
    forward_declaration_here,
    gnu_union_cast,
    invalid_union_cast,
    cast_to_incomplete_type,
    invalid_source_epoch,
    fuse_ld_path,
    invalid_rtlib,
    unsupported_rtlib_gcc,
    invalid_unwindlib,
    incompatible_unwindlib,
    gnu_asm_disabled,
    extension_token_used,
    complex_component_init,
    complex_prefix_postfix_op,
    not_floating_type,
    argument_types_differ,
    ms_search_rule,
    ctrl_z_eof,
    illegal_char_encoding_warning,
    illegal_char_encoding_error,
    ucn_basic_char_error,
    ucn_basic_char_warning,
    ucn_control_char_error,
    ucn_control_char_warning,
    c89_ucn_in_literal,
    four_char_char_literal,
    multi_char_char_literal,
    missing_hex_escape,
    unknown_escape_sequence,
    attribute_requires_string,
    unterminated_string_literal_warning,
    unterminated_string_literal_error,
    empty_char_literal_warning,
    empty_char_literal_error,
    unterminated_char_literal_warning,
    unterminated_char_literal_error,
    unterminated_comment,
    def_no_proto_deprecated,
    passing_args_to_kr,
    unknown_type_name,
    label_compound_end,
    u8_char_lit,
    malformed_embed_param,
    malformed_embed_limit,
    duplicate_embed_param,
    unsupported_embed_param,
    invalid_compound_literal_storage_class,
    va_opt_lparen,
    va_opt_rparen,
    attribute_int_out_of_range,
    identifier_not_normalized,
    c23_auto_plain_declarator,
    c23_auto_single_declarator,
    c32_auto_requires_initializer,
    c23_auto_scalar_init,
    negative_shift_count,
    too_big_shift_count,
    complex_conj,
    overflow_builtin_requires_int,
    overflow_result_requires_ptr,

    pub fn property(tag: Tag) Properties {
        return named_data[@intFromEnum(tag)];
    }

    const named_data = [_]Properties{
        .{ .msg = "TODO: {s}", .extra = .str, .kind = .@"error" },
        .{ .msg = "{s}", .extra = .str, .kind = .@"error" },
        .{ .msg = "{s}", .opt = W("#warnings"), .extra = .str, .kind = .warning },
        .{ .msg = "#elif without #if", .kind = .@"error" },
        .{ .msg = "#elif after #else", .kind = .@"error" },
        .{ .msg = "#elifdef without #if", .kind = .@"error" },
        .{ .msg = "#elifdef after #else", .kind = .@"error" },
        .{ .msg = "#elifndef without #if", .kind = .@"error" },
        .{ .msg = "#elifndef after #else", .kind = .@"error" },
        .{ .msg = "#else without #if", .kind = .@"error" },
        .{ .msg = "#else after #else", .kind = .@"error" },
        .{ .msg = "#endif without #if", .kind = .@"error" },
        .{ .msg = "unknown pragma ignored", .opt = W("unknown-pragmas"), .kind = .off, .all = true },
        .{ .msg = "#line directive requires a simple digit sequence", .kind = .@"error" },
        .{ .msg = "invalid filename for #line directive", .kind = .@"error" },
        .{ .msg = "unterminated conditional directive", .kind = .@"error" },
        .{ .msg = "invalid preprocessing directive", .kind = .@"error" },
        .{ .msg = "macro name missing", .kind = .@"error" },
        .{ .msg = "extra tokens at end of macro directive", .kind = .@"error" },
        .{ .msg = "expected value in expression", .kind = .@"error" },
        .{ .msg = "expected closing ')'", .kind = .@"error" },
        .{ .msg = "to match this '('", .kind = .note },
        .{ .msg = "to match this '{'", .kind = .note },
        .{ .msg = "to match this '['", .kind = .note },
        .{ .msg = "expected closing '>'", .kind = .@"error" },
        .{ .msg = "to match this '<'", .kind = .note },
        .{ .msg = "string literal in preprocessor expression", .kind = .@"error" },
        .{ .msg = "floating point literal in preprocessor expression", .kind = .@"error" },
        .{ .msg = "'defined' cannot be used as a macro name", .kind = .@"error" },
        .{ .msg = "macro name must be an identifier", .kind = .@"error" },
        .{ .msg = "ISO C99 requires whitespace after the macro name", .opt = W("c99-extensions"), .kind = .warning },
        .{ .msg = "'##' cannot appear at the start of a macro expansion", .kind = .@"error" },
        .{ .msg = "'##' cannot appear at the end of a macro expansion", .kind = .@"error" },
        .{ .msg = "pasting formed '{s}', an invalid preprocessing token", .extra = .str, .kind = .@"error" },
        .{ .msg = "missing ')' in macro parameter list", .kind = .@"error" },
        .{ .msg = "unterminated macro param list", .kind = .@"error" },
        .{ .msg = "invalid token in macro parameter list", .kind = .@"error" },
        .{ .msg = "expected comma in macro parameter list", .kind = .@"error" },
        .{ .msg = "'#' is not followed by a macro parameter", .kind = .@"error" },
        .{ .msg = "expected \"FILENAME\" or <FILENAME>", .kind = .@"error" },
        .{ .msg = "empty filename", .kind = .@"error" },
        .{ .msg = "expected '{s}', found invalid bytes", .extra = .tok_id_expected, .kind = .@"error" },
        .{ .msg = "expected '{s}' before end of file", .extra = .tok_id_expected, .kind = .@"error" },
        .{ .msg = "expected '{s}', found '{s}'", .extra = .tok_id, .kind = .@"error" },
        .{ .msg = "expected expression", .kind = .@"error" },
        .{ .msg = "expression is not an integer constant expression", .kind = .@"error" },
        .{ .msg = "type specifier missing, defaults to 'int'", .opt = W("implicit-int"), .kind = .warning, .all = true },
        .{ .msg = "a type specifier is required for all declarations", .kind = .@"error" },
        .{ .msg = "cannot combine with previous '{s}' declaration specifier", .extra = .str, .kind = .@"error" },
        .{ .msg = "static assertion failed", .kind = .@"error" },
        .{ .msg = "static assertion failed {s}", .extra = .str, .kind = .@"error" },
        .{ .msg = "expected a type", .kind = .@"error" },
        .{ .msg = "cannot combine with previous '{s}' specifier", .extra = .str, .kind = .@"error" },
        .{ .msg = "duplicate '{s}' declaration specifier", .extra = .str, .opt = W("duplicate-decl-specifier"), .kind = .warning, .all = true },
        .{ .msg = "restrict requires a pointer or reference ('{s}' is invalid)", .extra = .str, .kind = .@"error" },
        .{ .msg = "expected external declaration", .kind = .@"error" },
        .{ .msg = "expected identifier or '('", .kind = .@"error" },
        .{ .msg = "declaration does not declare anything", .opt = W("missing-declaration"), .kind = .warning },
        .{ .msg = "function definition is not allowed here", .kind = .@"error" },
        .{ .msg = "illegal initializer (only variables can be initialized)", .kind = .@"error" },
        .{ .msg = "extern variable has initializer", .opt = W("extern-initializer"), .kind = .warning },
        .{ .msg = "'{s}' came from typedef", .extra = .str, .kind = .note },
        .{ .msg = "ISO C requires a named parameter before '...'", .kind = .@"error", .suppress_version = .c23 },
        .{ .msg = "'void' must be the only parameter if specified", .kind = .@"error" },
        .{ .msg = "'void' parameter cannot be qualified", .kind = .@"error" },
        .{ .msg = "'void' must be the first parameter if specified", .kind = .@"error" },
        .{ .msg = "invalid storage class on function parameter", .kind = .@"error" },
        .{ .msg = "_Thread_local only allowed on variables", .kind = .@"error" },
        .{ .msg = "'{s}' can only appear on functions", .extra = .str, .kind = .@"error" },
        .{ .msg = "illegal storage class on function", .kind = .@"error" },
        .{ .msg = "illegal storage class on global variable", .kind = .@"error" },
        .{ .msg = "expected statement", .kind = .@"error" },
        .{ .msg = "function cannot return a function", .kind = .@"error" },
        .{ .msg = "function cannot return an array", .kind = .@"error" },
        .{ .msg = "use of undeclared identifier '{s}'", .extra = .str, .kind = .@"error" },
        .{ .msg = "cannot call non function type '{s}'", .extra = .str, .kind = .@"error" },
        .{ .msg = "unsupported string literal concatenation", .kind = .@"error" },
        .{ .msg = "static functions must be global", .kind = .@"error" },
        .{ .msg = "call to undeclared function '{s}'; ISO C99 and later do not support implicit function declarations", .extra = .str, .opt = W("implicit-function-declaration"), .kind = .@"error", .all = true },
        .{ .msg = "use of unknown builtin '{s}'", .extra = .str, .opt = W("implicit-function-declaration"), .kind = .@"error", .all = true },
        .{ .msg = "implicitly declaring library function '{s}'", .extra = .str, .opt = W("implicit-function-declaration"), .kind = .@"error", .all = true },
        .{ .msg = "include the header <{s}.h> or explicitly provide a declaration for '{s}'", .extra = .builtin_with_header, .opt = W("implicit-function-declaration"), .kind = .note, .all = true },
        .{ .msg = "expected parameter declaration", .kind = .@"error" },
        .{ .msg = "identifier parameter lists are only allowed in function definitions", .kind = .@"error" },
        .{ .msg = "expected function body after function declaration", .kind = .@"error" },
        .{ .msg = "parameter cannot have void type", .kind = .@"error" },
        .{ .msg = "expression result unused", .opt = W("unused-value"), .kind = .warning, .all = true },
        .{ .msg = "'continue' statement not in a loop", .kind = .@"error" },
        .{ .msg = "'break' statement not in a loop or a switch", .kind = .@"error" },
        .{ .msg = "unreachable code", .opt = W("unreachable-code"), .kind = .warning, .all = true },
        .{ .msg = "duplicate label '{s}'", .extra = .str, .kind = .@"error" },
        .{ .msg = "previous definition of label '{s}' was here", .extra = .str, .kind = .note },
        .{ .msg = "use of undeclared label '{s}'", .extra = .str, .kind = .@"error" },
        .{ .msg = "'{s}' statement not in a switch statement", .extra = .str, .kind = .@"error" },
        .{ .msg = "duplicate case value '{s}'", .extra = .str, .kind = .@"error" },
        .{ .msg = "multiple default cases in the same switch", .kind = .@"error" },
        .{ .msg = "previous case defined here", .kind = .note },
        .{ .msg = expected_arguments, .extra = .arguments, .kind = .@"error" },
        .{ .msg = expected_arguments, .extra = .arguments, .kind = .warning },
        .{ .msg = "expected at least {d} argument(s) got {d}", .extra = .arguments, .kind = .warning },
        .{ .msg = "'static' may not be used with an unspecified variable length array size", .kind = .@"error" },
        .{ .msg = "'static' used outside of function parameters", .kind = .@"error" },
        .{ .msg = "type qualifier in non parameter array type", .kind = .@"error" },
        .{ .msg = "star modifier used outside of function parameters", .kind = .@"error" },
        .{ .msg = "variable length arrays not allowed at file scope", .kind = .@"error" },
        .{ .msg = "'static' useless without a constant size", .kind = .warning, .w_extra = true },
        .{ .msg = "array size must be 0 or greater", .kind = .@"error" },
        .{ .msg = "array has incomplete element type '{s}'", .extra = .str, .kind = .@"error" },
        .{ .msg = "arrays cannot have functions as their element type", .kind = .@"error" },
        .{ .msg = "'static' used in non-outermost array type", .kind = .@"error" },
        .{ .msg = "type qualifier used in non-outermost array type", .kind = .@"error" },
        .{ .msg = "unterminated function macro argument list", .kind = .@"error" },
        .{ .msg = "unknown warning '{s}'", .extra = .str, .opt = W("unknown-warning-option"), .kind = .warning },
        .{ .msg = "overflow in expression; result is '{s}'", .extra = .str, .opt = W("integer-overflow"), .kind = .warning },
        .{ .msg = "integer literal is too large to be represented in any integer type", .kind = .@"error" },
        .{ .msg = "indirection requires pointer operand", .kind = .@"error" },
        .{ .msg = "cannot take the address of an rvalue", .kind = .@"error" },
        .{ .msg = "address of bit-field requested", .kind = .@"error" },
        .{ .msg = "expression is not assignable", .kind = .@"error" },
        .{ .msg = "expected identifier or '{'", .kind = .@"error" },
        .{ .msg = "empty enum is invalid", .kind = .@"error" },
        .{ .msg = "redefinition of '{s}'", .extra = .str, .kind = .@"error" },
        .{ .msg = "previous definition is here", .kind = .note },
        .{ .msg = "expected identifier", .kind = .@"error" },
        .{ .msg = "expected string literal for diagnostic message in static_assert", .kind = .@"error" },
        .{ .msg = "expected string literal in '{s}'", .extra = .str, .kind = .@"error" },
        .{ .msg = "parameter named '{s}' is missing", .extra = .str, .kind = .@"error" },
        .{ .msg = "empty {s} is a GNU extension", .extra = .str, .opt = W("gnu-empty-struct"), .kind = .off, .pedantic = true },
        .{ .msg = "empty {s} has size 0 in C, size 1 in C++", .extra = .str, .opt = W("c++-compat"), .kind = .off },
        .{ .msg = "use of '{s}' with tag type that does not match previous definition", .extra = .str, .kind = .@"error" },
        .{ .msg = "expected parentheses around type name", .kind = .@"error" },
        .{ .msg = "'_Alignof' applied to an expression is a GNU extension", .opt = W("gnu-alignof-expression"), .kind = .warning, .suppress_gnu = true },
        .{ .msg = "invalid application of 'alignof' to an incomplete type '{s}'", .extra = .str, .kind = .@"error" },
        .{ .msg = "invalid application of 'sizeof' to an incomplete type '{s}'", .extra = .str, .kind = .@"error" },
        .{ .msg = "'{s}' macro redefined", .extra = .str, .opt = W("macro-redefined"), .kind = .warning },
        .{ .msg = "generic association with qualifiers cannot be matched with", .opt = W("generic-qual-type"), .kind = .warning },
        .{ .msg = "generic association array type cannot be matched with", .opt = W("generic-qual-type"), .kind = .warning },
        .{ .msg = "generic association function type cannot be matched with", .opt = W("generic-qual-type"), .kind = .warning },
        .{ .msg = "type '{s}' in generic association compatible with previously specified type", .extra = .str, .kind = .@"error" },
        .{ .msg = "compatible type '{s}' specified here", .extra = .str, .kind = .note },
        .{ .msg = "duplicate default generic association", .kind = .@"error" },
        .{ .msg = "controlling expression type '{s}' not compatible with any generic association type", .extra = .str, .kind = .@"error" },
        .{ .msg = "escape sequence out of range", .kind = .@"error" },
        .{ .msg = "invalid universal character", .kind = .@"error" },
        .{ .msg = "incomplete universal character name", .kind = .@"error" },
        .{ .msg = "multi-character character constant", .opt = W("multichar"), .kind = .warning, .all = true },
        .{ .msg = "{s} character literals may not contain multiple characters", .kind = .@"error", .extra = .str },
        .{ .msg = "extraneous characters in character constant ignored", .kind = .warning },
        .{ .msg = "character constant too long for its type", .kind = .warning, .all = true },
        .{ .msg = "character too large for enclosing character literal type", .kind = .@"error" },
        .{ .msg = "must use 'struct' tag to refer to type '{s}'", .extra = .str, .kind = .@"error" },
        .{ .msg = "must use 'union' tag to refer to type '{s}'", .extra = .str, .kind = .@"error" },
        .{ .msg = "must use 'enum' tag to refer to type '{s}'", .extra = .str, .kind = .@"error" },
        .{ .msg = "redefinition of '{s}' as different kind of symbol", .extra = .str, .kind = .@"error" },
        .{ .msg = "redefinition of '{s}' with a different type", .extra = .str, .kind = .@"error" },
        .{ .msg = "redefinition of parameter '{s}'", .extra = .str, .kind = .@"error" },
        .{ .msg = "invalid operands to binary expression ({s})", .extra = .str, .kind = .@"error" },
        .{ .msg = "comparison between pointer and integer ({s})", .extra = .str, .opt = W("pointer-integer-compare"), .kind = .warning },
        .{ .msg = "comparison of distinct pointer types ({s})", .extra = .str, .opt = W("compare-distinct-pointer-types"), .kind = .warning },
        .{ .msg = "incompatible pointer types ({s})", .extra = .str, .kind = .@"error" },
        .{ .msg = "invalid argument type '{s}' to unary expression", .extra = .str, .kind = .@"error" },
        .{ .msg = "assignment to {s}", .extra = .str, .kind = .@"error" },
        .{ .msg = "implicit pointer to integer conversion from {s}", .extra = .str, .opt = W("int-conversion"), .kind = .warning },
        .{ .msg = "pointer cannot be cast to type '{s}'", .extra = .str, .kind = .@"error" },
        .{ .msg = "operand of type '{s}' cannot be cast to a pointer type", .extra = .str, .kind = .@"error" },
        .{ .msg = "cannot cast to non arithmetic or pointer type '{s}'", .extra = .str, .kind = .@"error" },
        .{ .msg = "cast to type '{s}' will not preserve qualifiers", .extra = .str, .opt = W("cast-qualifiers"), .kind = .warning },
        .{ .msg = "array subscript is not an integer", .kind = .@"error" },
        .{ .msg = "subscripted value is not an array or pointer", .kind = .@"error" },
        .{ .msg = "array index {s} is past the end of the array", .extra = .str, .opt = W("array-bounds"), .kind = .warning },
        .{ .msg = "array index {s} is before the beginning of the array", .extra = .str, .opt = W("array-bounds"), .kind = .warning },
        .{ .msg = "statement requires expression with integer type ('{s}' invalid)", .extra = .str, .kind = .@"error" },
        .{ .msg = "statement requires expression with scalar type ('{s}' invalid)", .extra = .str, .kind = .@"error" },
        .{ .msg = "non-void function '{s}' should return a value", .extra = .str, .opt = W("return-type"), .kind = .@"error", .all = true },
        .{ .msg = "returning {s}", .extra = .str, .kind = .@"error" },
        .{ .msg = "returning {s}" ++ pointer_sign_message, .extra = .str, .kind = .warning, .opt = W("pointer-sign") },
        .{ .msg = "implicit integer to pointer conversion from {s}", .extra = .str, .opt = W("int-conversion"), .kind = .warning },
        .{ .msg = "non-void function '{s}' does not return a value", .extra = .str, .opt = W("return-type"), .kind = .warning, .all = true },
        .{ .msg = "void function '{s}' should not return a value", .extra = .str, .opt = W("return-type"), .kind = .@"error", .all = true },
        .{ .msg = "passing {s}", .extra = .str, .kind = .@"error" },
        .{ .msg = "passing {s}", .extra = .str, .kind = .warning, .opt = W("incompatible-pointer-types") },
        .{ .msg = "passing {s}" ++ pointer_sign_message, .extra = .str, .kind = .warning, .opt = W("pointer-sign") },
        .{ .msg = "passing argument to parameter here", .kind = .note },
        .{ .msg = "atomic cannot be applied to array type '{s}'", .extra = .str, .kind = .@"error" },
        .{ .msg = "atomic cannot be applied to function type '{s}'", .extra = .str, .kind = .@"error" },
        .{ .msg = "atomic cannot be applied to incomplete type '{s}'", .extra = .str, .kind = .@"error" },
        .{ .msg = "address of register variable requested", .kind = .@"error" },
        .{ .msg = "variable has incomplete type '{s}'", .extra = .str, .kind = .@"error" },
        .{ .msg = "parameter has incomplete type '{s}'", .extra = .str, .kind = .@"error" },
        .{ .msg = "tentative array definition assumed to have one element", .kind = .warning },
        .{ .msg = "dereferencing pointer to incomplete type '{s}'", .extra = .str, .kind = .@"error" },
        .{ .msg = "'_Alignas' attribute only applies to variables and fields", .kind = .@"error" },
        .{ .msg = "'_Alignas' attribute cannot be applied to a function parameter", .kind = .@"error" },
        .{ .msg = "requested alignment is less than minimum alignment of {d}", .extra = .unsigned, .kind = .@"error" },
        .{ .msg = "requested alignment of {s} is too large", .extra = .str, .kind = .@"error" },
        .{ .msg = "requested negative alignment of {s} is invalid", .extra = .str, .kind = .@"error" },
        .{ .msg = "'_Alignas' attribute is ignored here", .kind = .warning },
        .{ .msg = "requested alignment of zero is ignored", .kind = .warning },
        .{ .msg = "requested alignment is not a power of 2", .kind = .@"error" },
        .{ .msg = "pointer type mismatch ({s})", .extra = .str, .opt = W("pointer-type-mismatch"), .kind = .warning },
        .{ .msg = "static_assert expression is not an integral constant expression", .kind = .@"error" },
        .{ .msg = "static_assert with no message is a C23 extension", .opt = W("c23-extensions"), .kind = .warning, .suppress_version = .c23 },
        .{ .msg = "{s} is incompatible with C standards before C23", .extra = .str, .kind = .off, .suppress_unless_version = .c23, .opt = W("pre-c23-compat") },
        .{ .msg = "variable length array must be bound in function definition", .kind = .@"error" },
        .{ .msg = "array is too large", .kind = .@"error" },
        .{ .msg = "incompatible pointer types initializing {s}", .extra = .str, .opt = W("incompatible-pointer-types"), .kind = .warning },
        .{ .msg = "incompatible pointer types initializing {s}" ++ pointer_sign_message, .extra = .str, .opt = W("pointer-sign"), .kind = .warning },
        .{ .msg = "incompatible pointer types assigning to {s}", .extra = .str, .opt = W("incompatible-pointer-types"), .kind = .warning },
        .{ .msg = "incompatible pointer types assigning to {s} " ++ pointer_sign_message, .extra = .str, .opt = W("pointer-sign"), .kind = .warning },
        .{ .msg = "variable-sized object may not be initialized", .kind = .@"error" },
        .{ .msg = "illegal initializer type", .kind = .@"error" },
        .{ .msg = "initializing {s}", .extra = .str, .kind = .@"error" },
        .{ .msg = "scalar initializer cannot be empty", .kind = .@"error" },
        .{ .msg = "excess elements in scalar initializer", .opt = W("excess-initializers"), .kind = .warning },
        .{ .msg = "excess elements in string initializer", .opt = W("excess-initializers"), .kind = .warning },
        .{ .msg = "excess elements in struct initializer", .opt = W("excess-initializers"), .kind = .warning },
        .{ .msg = "excess elements in array initializer", .opt = W("excess-initializers"), .kind = .warning },
        .{ .msg = "initializer-string for char array is too long", .opt = W("excess-initializers"), .kind = .warning },
        .{ .msg = "cannot initialize type ({s})", .extra = .str, .kind = .@"error" },
        .{ .msg = "'{s} typeof' is invalid", .extra = .str, .kind = .@"error" },
        .{ .msg = "{s} by zero is undefined", .extra = .str, .opt = W("division-by-zero"), .kind = .warning },
        .{ .msg = "{s} by zero in preprocessor expression", .extra = .str, .kind = .@"error" },
        .{ .msg = "'__builtin_choose_expr' requires a constant expression", .kind = .@"error" },
        .{ .msg = "'_Alignas' attribute requires integer constant expression", .kind = .@"error" },
        .{ .msg = "case value must be an integer constant expression", .kind = .@"error" },
        .{ .msg = "enum value must be an integer constant expression", .kind = .@"error" },
        .{ .msg = "cannot initialize array of type {s}", .extra = .str, .kind = .@"error" },
        .{ .msg = "array initializer must be an initializer list or wide string literal", .kind = .@"error" },
        .{ .msg = "initializer overrides previous initialization", .opt = W("initializer-overrides"), .kind = .warning, .w_extra = true },
        .{ .msg = "previous initialization", .kind = .note },
        .{ .msg = "array designator used for non-array type '{s}'", .extra = .str, .kind = .@"error" },
        .{ .msg = "array designator value {s} is negative", .extra = .str, .kind = .@"error" },
        .{ .msg = "array designator index {s} exceeds array bounds", .extra = .str, .kind = .@"error" },
        .{ .msg = "field designator used for non-record type '{s}'", .extra = .str, .kind = .@"error" },
        .{ .msg = "record type has no field named '{s}'", .extra = .str, .kind = .@"error" },
        .{ .msg = "initializer for aggregate with no elements requires explicit braces", .kind = .@"error" },
        .{ .msg = "initializing {s} discards qualifiers", .extra = .str, .opt = W("incompatible-pointer-types-discards-qualifiers"), .kind = .warning },
        .{ .msg = "assigning to {s} discards qualifiers", .extra = .str, .opt = W("incompatible-pointer-types-discards-qualifiers"), .kind = .warning },
        .{ .msg = "returning {s} discards qualifiers", .extra = .str, .opt = W("incompatible-pointer-types-discards-qualifiers"), .kind = .warning },
        .{ .msg = "passing {s} discards qualifiers", .extra = .str, .opt = W("incompatible-pointer-types-discards-qualifiers"), .kind = .warning },
        .{ .msg = "unknown attribute '{s}' ignored", .extra = .str, .opt = W("unknown-attributes"), .kind = .warning },
        .{ .msg = "{s}", .extra = .str, .opt = W("ignored-attributes"), .kind = .warning },
        .{ .msg = "fallthrough annotation does not directly precede switch label", .kind = .@"error" },
        .{ .msg = "'{s}' attribute cannot be applied to a statement", .extra = .str, .kind = .@"error" },
        .{ .msg = "redefining builtin macro", .opt = W("builtin-macro-redefined"), .kind = .warning },
        .{ .msg = "builtin feature check macro requires a parenthesized identifier", .kind = .@"error" },
        .{ .msg = "missing '{s}', after builtin feature-check macro", .extra = .tok_id_expected, .kind = .@"error" },
        .{ .msg = "use of GNU address-of-label extension", .opt = W("gnu-label-as-value"), .kind = .off, .pedantic = true },
        .{ .msg = "member reference base type '{s}' is not a structure or union", .extra = .str, .kind = .@"error" },
        .{ .msg = "member reference type '{s}' is not a pointer; did you mean to use '.'?", .extra = .str, .kind = .@"error" },
        .{ .msg = "member reference type '{s}' is a pointer; did you mean to use '->'?", .extra = .str, .kind = .@"error" },
        .{ .msg = "no member named {s}", .extra = .str, .kind = .@"error" },
        .{ .msg = "{s} expected option name (e.g. \"-Wundef\")", .extra = .str, .opt = W("malformed-warning-check"), .kind = .warning, .all = true },
        .{ .msg = "computed goto in function with no address-of-label expressions", .kind = .@"error" },
        .{ .msg = "{s}", .extra = .str, .opt = W("#pragma-messages"), .kind = .warning },
        .{ .msg = "{s}", .extra = .str, .kind = .@"error" },
        .{ .msg = "#pragma message: {s}", .extra = .str, .kind = .note },
        .{ .msg = "pragma {s} requires string literal", .extra = .str, .kind = .@"error" },
        .{ .msg = "attempt to use a poisoned identifier", .kind = .@"error" },
        .{ .msg = "can only poison identifier tokens", .kind = .@"error" },
        .{ .msg = "poisoning existing macro", .kind = .warning },
        .{ .msg = "no newline at end of file", .opt = W("newline-eof"), .kind = .off, .pedantic = true },
        .{ .msg = "ISO C requires a translation unit to contain at least one declaration", .opt = W("empty-translation-unit"), .kind = .off, .pedantic = true },
        .{ .msg = "omitting the parameter name in a function definition is a C23 extension", .opt = W("c23-extensions"), .kind = .warning, .suppress_version = .c23 },
        .{ .msg = "bit-field has non-integer type '{s}'", .extra = .str, .kind = .@"error" },
        .{ .msg = "bit-field has negative width ({s})", .extra = .str, .kind = .@"error" },
        .{ .msg = "named bit-field has zero width", .kind = .@"error" },
        .{ .msg = "width of bit-field exceeds width of its type", .kind = .@"error" },
        .{ .msg = "source file is not valid UTF-8", .kind = .@"error" },
        .{ .msg = "integer literal is too large to be represented in a signed integer type, interpreting as unsigned", .opt = W("implicitly-unsigned-literal"), .kind = .warning },
        .{ .msg = "token is not a valid binary operator in a preprocessor subexpression", .kind = .@"error" },
        .{ .msg = "invalid token at start of a preprocessor expression", .kind = .@"error" },
        .{ .msg = "using this character in an identifier is incompatible with C99", .opt = W("c99-compat"), .kind = .off },
        .{ .msg = "unexpected character <U+{X:0>4}>", .extra = .actual_codepoint, .kind = .@"error" },
        .{ .msg = "character <U+{X:0>4}> not allowed at the start of an identifier", .extra = .actual_codepoint, .kind = .@"error" },
        .{ .msg = "identifier contains Unicode character <U+{X:0>4}> that is invisible in some environments", .opt = W("unicode-homoglyph"), .extra = .actual_codepoint, .kind = .warning },
        .{ .msg = "treating Unicode character <U+{X:0>4}> as identifier character rather than as '{u}' symbol", .extra = .codepoints, .opt = W("unicode-homoglyph"), .kind = .warning },
        .{ .msg = "meaningless '{s}' on assembly outside function", .extra = .str, .kind = .@"error" },
        .{ .msg = "duplicate asm qualifier '{s}'", .extra = .str, .kind = .@"error" },
        .{ .msg = "cannot use {s} string literal in assembly", .extra = .str, .kind = .@"error" },
        .{ .msg = "'$' in identifier", .opt = W("dollar-in-identifier-extension"), .kind = .off, .pedantic = true },
        .{ .msg = "illegal character '$' in identifier", .kind = .@"error" },
        .{ .msg = "expanded from here", .kind = .note },
        .{ .msg = "(skipping {d} expansions in backtrace; use -fmacro-backtrace-limit=0 to see all)", .extra = .unsigned, .kind = .note },
        .{ .msg = "_Pragma requires exactly one string literal token", .kind = .@"error" },
        .{ .msg = "pragma GCC expected 'error', 'warning', 'diagnostic', 'poison'", .opt = W("unknown-pragmas"), .kind = .off, .all = true },
        .{ .msg = "pragma GCC diagnostic expected 'error', 'warning', 'ignored', 'fatal', 'push', or 'pop'", .opt = W("unknown-pragmas"), .kind = .warning, .all = true },
        .{ .msg = "predefined identifier is only valid inside function", .opt = W("predefined-identifier-outside-function"), .kind = .warning },
        .{ .msg = "first argument to va_arg, is of type '{s}' and not 'va_list'", .extra = .str, .kind = .@"error" },
        .{ .msg = "too many braces around scalar initializer", .opt = W("many-braces-around-scalar-init"), .kind = .warning },
        .{ .msg = "variable '{s}' is uninitialized when used within its own initialization", .extra = .str, .opt = W("uninitialized"), .kind = .off, .all = true },
        .{ .msg = "use of GNU statement expression extension", .opt = W("gnu-statement-expression"), .kind = .off, .suppress_gnu = true, .pedantic = true },
        .{ .msg = "statement expression not allowed at file scope", .kind = .@"error" },
        .{ .msg = "imaginary constants are a GNU extension", .opt = W("gnu-imaginary-constant"), .kind = .off, .suppress_gnu = true, .pedantic = true },
        .{ .msg = "plain '_Complex' requires a type specifier; assuming '_Complex double'", .kind = .warning },
        .{ .msg = "complex integer types are a GNU extension", .opt = W("gnu-complex-integer"), .suppress_gnu = true, .kind = .off },
        .{ .msg = "'{s}' type qualifier on return type has no effect", .opt = W("ignored-qualifiers"), .extra = .str, .kind = .off, .all = true },
        .{ .msg = "invalid standard '{s}'", .extra = .str, .kind = .@"error" },
        .{ .msg = "invalid target '{s}'", .extra = .str, .kind = .@"error" },
        .{ .msg = "invalid compiler '{s}'", .extra = .str, .kind = .@"error" },
        .{ .msg = "unknown argument '{s}'", .extra = .str, .kind = .@"error" },
        .{ .msg = "{s}", .extra = .str, .kind = .@"error" },
        .{ .msg = "{s}: linker input file unused because linking not done", .extra = .str, .kind = .warning },
        .{ .msg = "unrecognized linker '{s}'", .extra = .str, .kind = .@"error" },
        .{ .msg = "extra ';' outside of a function", .opt = W("extra-semi"), .kind = .off, .pedantic = true },
        .{ .msg = "field declared as a function", .kind = .@"error" },
        .{ .msg = "variable length array fields extension is not supported", .kind = .@"error" },
        .{ .msg = "field has incomplete type '{s}'", .extra = .str, .kind = .@"error" },
        .{ .msg = "flexible array member in union is not allowed", .kind = .@"error", .suppress_msvc = true },
        .{ .msg = "flexible array member is not at the end of struct", .kind = .@"error" },
        .{ .msg = "flexible array member in otherwise empty struct", .kind = .@"error", .suppress_msvc = true },
        .{ .msg = "duplicate member '{s}'", .extra = .str, .kind = .@"error" },
        .{ .msg = "binary integer literals are a GNU extension", .kind = .off, .opt = W("gnu-binary-literal"), .pedantic = true },
        .{ .msg = "named variadic macros are a GNU extension", .opt = W("variadic-macros"), .kind = .off, .pedantic = true },
        .{ .msg = "builtin function must be directly called", .kind = .@"error" },
        .{ .msg = "'va_start' cannot be used outside a function", .kind = .@"error" },
        .{ .msg = "'va_start' used in a function with fixed args", .kind = .@"error" },
        .{ .msg = "second argument to 'va_start' is not the last named parameter", .opt = W("varargs"), .kind = .warning },
        .{ .msg = "'{s}' attribute takes at least {d} argument(s)", .kind = .@"error", .extra = .attr_arg_count },
        .{ .msg = "'{s}' attribute takes at most {d} argument(s)", .kind = .@"error", .extra = .attr_arg_count },
        .{ .msg = "Attribute argument is invalid, expected {s} but got {s}", .kind = .@"error", .extra = .attr_arg_type },
        .{ .msg = "Unknown `{s}` argument. Possible values are: {s}", .kind = .@"error", .extra = .attr_enum },
        .{ .msg = "'{s}' attribute requires an identifier", .kind = .@"error", .extra = .str },
        .{ .msg = "'__declspec' attributes are not enabled; use '-fdeclspec' or '-fms-extensions' to enable support for __declspec attributes", .kind = .@"error" },
        .{ .msg = "__declspec attribute '{s}' is not supported", .extra = .str, .opt = W("ignored-attributes"), .kind = .warning },
        .{ .msg = "{s}", .extra = .str, .opt = W("deprecated-declarations"), .kind = .warning },
        .{ .msg = "'{s}' has been explicitly marked deprecated here", .extra = .str, .opt = W("deprecated-declarations"), .kind = .note },
        .{ .msg = "{s}", .extra = .str, .kind = .@"error" },
        .{ .msg = "'{s}' has been explicitly marked unavailable here", .extra = .str, .kind = .note },
        .{ .msg = "{s}", .extra = .str, .kind = .warning, .opt = W("attribute-warning") },
        .{ .msg = "{s}", .extra = .str, .kind = .@"error" },
        .{ .msg = "attribute '{s}' is ignored, place it after \"{s}\" to apply attribute to type declaration", .extra = .ignored_record_attr, .kind = .warning, .opt = W("ignored-attributes") },
        .{ .msg = "backslash and newline separated by space", .kind = .warning, .opt = W("backslash-newline-escape") },
        .{ .msg = "size of array has non-integer type '{s}'", .extra = .str, .kind = .@"error" },
        .{ .msg = "cast to smaller integer type {s}", .extra = .str, .kind = .warning, .opt = W("pointer-to-int-cast") },
        .{ .msg = "use of GNU case range extension", .opt = W("gnu-case-range"), .kind = .off, .pedantic = true },
        .{ .msg = "empty case range specified", .kind = .warning },
        .{ .msg = "use of non-standard escape character '\\{s}'", .kind = .off, .opt = W("pedantic"), .extra = .invalid_escape },
        .{ .msg = "invalid string literal, ignoring final '\\'", .kind = .warning },
        .{ .msg = "variable length array used", .kind = .off, .opt = W("vla") },
        .{ .msg = "implicit conversion of non-finite value from {s} is undefined", .extra = .str, .kind = .off, .opt = W("float-overflow-conversion") },
        .{ .msg = "implicit conversion of out of range value from {s} is undefined", .extra = .str, .kind = .warning, .opt = W("literal-conversion") },
        .{ .msg = "implicit conversion from {s}", .extra = .str, .kind = .off, .opt = W("float-zero-conversion") },
        .{ .msg = "implicit conversion from {s}", .extra = .str, .kind = .warning, .opt = W("float-conversion") },
        .{ .msg = "implicit conversion turns floating-point number into integer: {s}", .extra = .str, .kind = .off, .opt = W("literal-conversion") },
        .{ .msg = "expression is not an integer constant expression; folding it to a constant is a GNU extension", .kind = .off, .opt = W("gnu-folding-constant"), .pedantic = true },
        .{ .msg = "variable length array folded to constant array as an extension", .kind = .off, .opt = W("gnu-folding-constant"), .pedantic = true },
        .{ .msg = "typedef redefinition with different types ({s})", .extra = .str, .kind = .@"error" },
        .{ .msg = "'{s}' is not defined, evaluates to 0", .extra = .str, .kind = .off, .opt = W("undef") },
        .{ .msg = "function-like macro '{s}' is not defined", .extra = .str, .kind = .@"error" },
        .{ .msg = "'{s}' must be used within a preprocessing directive", .extra = .tok_id_expected, .kind = .@"error" },
        .{ .msg = "Missing '(' after built-in macro '{s}'", .extra = .str, .kind = .@"error" },
        .{ .msg = "offsetof requires struct or union type, '{s}' invalid", .extra = .str, .kind = .@"error" },
        .{ .msg = "offsetof of incomplete type '{s}'", .extra = .str, .kind = .@"error" },
        .{ .msg = "offsetof requires array type, '{s}' invalid", .extra = .str, .kind = .@"error" },
        .{ .msg = "missing '(' after '#pragma pack' - ignoring", .kind = .warning, .opt = W("ignored-pragmas") },
        .{ .msg = "missing ')' after '#pragma pack' - ignoring", .kind = .warning, .opt = W("ignored-pragmas") },
        .{ .msg = "unknown action for '#pragma pack' - ignoring", .opt = W("ignored-pragmas"), .kind = .warning },
        .{ .msg = "value of #pragma pack(show) == {d}", .extra = .unsigned, .kind = .warning },
        .{ .msg = "expected #pragma pack parameter to be '1', '2', '4', '8', or '16'", .opt = W("ignored-pragmas"), .kind = .warning },
        .{ .msg = "expected integer or identifier in '#pragma pack' - ignored", .opt = W("ignored-pragmas"), .kind = .warning },
        .{ .msg = "specifying both a name and alignment to 'pop' is undefined", .kind = .warning },
        .{ .msg = "#pragma pack(pop, ...) failed: stack empty", .opt = W("ignored-pragmas"), .kind = .warning },
        .{ .msg = "used type '{s}' where arithmetic or pointer type is required", .extra = .str, .kind = .@"error" },
        .{ .msg = "#include nested too deeply", .kind = .@"error" },
        .{ .msg = "ISO C restricts enumerator values to range of 'int' ({s} is too small)", .extra = .str, .kind = .off, .opt = W("pedantic") },
        .{ .msg = "ISO C restricts enumerator values to range of 'int' ({s} is too large)", .extra = .str, .kind = .off, .opt = W("pedantic") },
        .{ .msg = "#include_next is a language extension", .kind = .off, .pedantic = true, .opt = W("gnu-include-next") },
        .{ .msg = "#include_next in primary source file; will search from start of include path", .kind = .warning, .opt = W("include-next-outside-header") },
        .{ .msg = "overflow in enumeration value", .kind = .warning },
        .{ .msg = "incremented enumerator value {s} is not representable in the largest integer type", .kind = .warning, .opt = W("enum-too-large"), .extra = .pow_2_as_string },
        .{ .msg = "enumeration values exceed range of largest integer", .kind = .warning, .opt = W("enum-too-large") },
        .{ .msg = "enumeration types with a fixed underlying type are a Clang extension", .kind = .off, .pedantic = true, .opt = W("fixed-enum-extension") },
        .{ .msg = "enumeration previously declared with nonfixed underlying type", .kind = .@"error" },
        .{ .msg = "enumeration previously declared with fixed underlying type", .kind = .@"error" },
        .{ .msg = "enumeration redeclared with different underlying type {s})", .extra = .str, .kind = .@"error" },
        .{ .msg = "enumerator value is not representable in the underlying type '{s}'", .extra = .str, .kind = .@"error" },
        .{ .msg = "'transparent_union' attribute only applies to unions", .opt = W("ignored-attributes"), .kind = .warning },
        .{ .msg = "transparent union definition must contain at least one field; transparent_union attribute ignored", .opt = W("ignored-attributes"), .kind = .warning },
        .{ .msg = "size of field {s} bits) does not match the size of the first field in transparent union; transparent_union attribute ignored", .extra = .str, .opt = W("ignored-attributes"), .kind = .warning },
        .{ .msg = "size of first field is {d}", .extra = .unsigned, .kind = .note },
        .{ .msg = "'designated_init' attribute is only valid on 'struct' type'", .kind = .@"error" },
        .{ .msg = "positional initialization of field in 'struct' declared with 'designated_init' attribute", .opt = W("designated-init"), .kind = .warning },
        .{ .msg = "ignoring attribute 'common' because it conflicts with attribute 'nocommon'", .opt = W("ignored-attributes"), .kind = .warning },
        .{ .msg = "ignoring attribute 'nocommon' because it conflicts with attribute 'common'", .opt = W("ignored-attributes"), .kind = .warning },
        .{ .msg = "'nonstring' attribute ignored on objects of type '{s}'", .opt = W("ignored-attributes"), .kind = .warning },
        .{ .msg = "'{s}' attribute only applies to local variables", .extra = .str, .opt = W("ignored-attributes"), .kind = .warning },
        .{ .msg = "ignoring attribute 'cold' because it conflicts with attribute 'hot'", .opt = W("ignored-attributes"), .kind = .warning },
        .{ .msg = "ignoring attribute 'hot' because it conflicts with attribute 'cold'", .opt = W("ignored-attributes"), .kind = .warning },
        .{ .msg = "ignoring attribute 'noinline' because it conflicts with attribute 'always_inline'", .opt = W("ignored-attributes"), .kind = .warning },
        .{ .msg = "ignoring attribute 'always_inline' because it conflicts with attribute 'noinline'", .opt = W("ignored-attributes"), .kind = .warning },
        .{ .msg = "function '{s}' declared 'noreturn' should not return", .extra = .str, .kind = .warning, .opt = W("invalid-noreturn") },
        .{ .msg = "ignoring return value of '{s}', declared with 'nodiscard' attribute", .extra = .str, .kind = .warning, .opt = W("unused-result") },
        .{ .msg = "ignoring return value of '{s}', declared with 'warn_unused_result' attribute", .extra = .str, .kind = .warning, .opt = W("unused-result") },
        .{ .msg = "invalid vector element type '{s}'", .extra = .str, .kind = .@"error" },
        .{ .msg = "vector size not an integral multiple of component size", .kind = .@"error" },
        .{ .msg = "invalid type '{s}' to __imag operator", .extra = .str, .kind = .@"error" },
        .{ .msg = "invalid type '{s}' to __real operator", .extra = .str, .kind = .@"error" },
        .{ .msg = "zero size arrays are an extension", .kind = .off, .pedantic = true, .opt = W("zero-length-array") },
        .{ .msg = "array index {s} is past the end of the array", .extra = .str, .kind = .off, .pedantic = true, .opt = W("old-style-flexible-struct") },
        .{ .msg = "token pasting of ',' and __VA_ARGS__ is a GNU extension", .kind = .off, .pedantic = true, .opt = W("gnu-zero-variadic-macro-arguments"), .suppress_gcc = true },
        .{ .msg = "return type of 'main' is not 'int'", .kind = .warning, .opt = W("main-return-type") },
        .{ .msg = "macro expansion producing 'defined' has undefined behavior", .kind = .off, .pedantic = true, .opt = W("expansion-to-defined") },
        .{ .msg = "invalid suffix '{s}' on integer constant", .extra = .str, .kind = .@"error" },
        .{ .msg = "invalid suffix '{s}' on floating constant", .extra = .str, .kind = .@"error" },
        .{ .msg = "invalid digit '{c}' in octal constant", .extra = .ascii, .kind = .@"error" },
        .{ .msg = "invalid digit '{c}' in binary constant", .extra = .ascii, .kind = .@"error" },
        .{ .msg = "exponent has no digits", .kind = .@"error" },
        .{ .msg = "hexadecimal floating constant requires an exponent", .kind = .@"error" },
        .{ .msg = "sizeof returns 0", .kind = .warning, .suppress_gcc = true, .suppress_clang = true },
        .{ .msg = "'declspec' attribute not allowed after declarator", .kind = .@"error" },
        .{ .msg = "this declarator", .kind = .note },
        .{ .msg = "{s} is not supported on this target", .extra = .str, .kind = .@"error" },
        .{ .msg = "'_BitInt' in C17 and earlier is a Clang extension'", .kind = .off, .pedantic = true, .opt = W("bit-int-extension"), .suppress_version = .c23 },
        .{ .msg = "{s} must have a bit size of at least 1", .extra = .str, .kind = .@"error" },
        .{ .msg = "{s} must have a bit size of at least 2", .extra = .str, .kind = .@"error" },
        .{ .msg = "{s} of bit sizes greater than " ++ std.fmt.comptimePrint("{d}", .{Properties.max_bits}) ++ " not supported", .extra = .str, .kind = .@"error" },
        .{ .msg = "keyword is hidden by macro definition", .kind = .off, .pedantic = true, .opt = W("keyword-macro") },
        .{ .msg = "arithmetic on a pointer to an incomplete type '{s}'", .extra = .str, .kind = .@"error" },
        .{ .msg = "'{s}' calling convention is not supported for this target", .extra = .str, .opt = W("ignored-attributes"), .kind = .warning },
        .{ .msg = "invalid application of '{s}' to a void type", .extra = .str, .kind = .off, .pedantic = true, .opt = W("pointer-arith") },
        .{ .msg = "sizeof on array function parameter will return size of {s}", .extra = .str, .kind = .warning, .opt = W("sizeof-array-argument") },
        .{ .msg = "address of array '{s}' will always evaluate to 'true'", .extra = .str, .kind = .warning, .opt = W("pointer-bool-conversion") },
        .{ .msg = "implicit conversion turns string literal into bool: {s}", .extra = .str, .kind = .off, .opt = W("string-conversion") },
        .{ .msg = "this conversion is not allowed in a constant expression", .kind = .note },
        .{ .msg = "cannot cast an object of type {s}", .extra = .str, .kind = .@"error" },
        .{ .msg = "unsupported argument '{s}' to option '-ffp-eval-method='; expected 'source', 'double', or 'extended'", .extra = .str, .kind = .@"error" },
        .{ .msg = "{s} cannot have __fp16 type; did you forget * ?", .extra = .str, .kind = .@"error" },
        .{ .msg = "'_BitInt' suffix for literals is a C23 extension", .opt = W("c23-extensions"), .kind = .warning, .suppress_version = .c23 },
        .{ .msg = "'__auto_type' is a GNU extension", .opt = W("gnu-auto-type"), .kind = .off, .pedantic = true },
        .{ .msg = "'__auto_type' not allowed in {s}", .kind = .@"error", .extra = .str },
        .{ .msg = "declaration of variable '{s}' with deduced type requires an initializer", .kind = .@"error", .extra = .str },
        .{ .msg = "'__auto_type' may only be used with a single declarator", .kind = .@"error" },
        .{ .msg = "'__auto_type' requires a plain identifier as declarator", .kind = .@"error" },
        .{ .msg = "invalid cast to '__auto_type'", .kind = .@"error" },
        .{ .msg = "cannot use bit-field as '__auto_type' initializer", .kind = .@"error" },
        .{ .msg = "'{s}' declared as array of '__auto_type'", .kind = .@"error", .extra = .str },
        .{ .msg = "cannot use '__auto_type' with initializer list", .kind = .@"error" },
        .{ .msg = "expected ';' at end of declaration list", .kind = .warning },
        .{ .msg = "tentative definition has type '{s}' that is never completed", .kind = .@"error", .extra = .str },
        .{ .msg = "forward declaration of '{s}'", .kind = .note, .extra = .str },
        .{ .msg = "cast to union type is a GNU extension", .opt = W("gnu-union-cast"), .kind = .off, .pedantic = true },
        .{ .msg = "cast to union type from type '{s}' not present in union", .kind = .@"error", .extra = .str },
        .{ .msg = "cast to incomplete type '{s}'", .kind = .@"error", .extra = .str },
        .{ .msg = "environment variable SOURCE_DATE_EPOCH must expand to a non-negative integer less than or equal to 253402300799", .kind = .@"error" },
        .{ .msg = "'-fuse-ld=' taking a path is deprecated; use '--ld-path=' instead", .kind = .off, .opt = W("fuse-ld-path") },
        .{ .msg = "invalid runtime library name '{s}'", .kind = .@"error", .extra = .str },
        .{ .msg = "unsupported runtime library 'libgcc' for platform '{s}'", .kind = .@"error", .extra = .str },
        .{ .msg = "invalid unwind library name '{s}'", .kind = .@"error", .extra = .str },
        .{ .msg = "--rtlib=libgcc requires --unwindlib=libgcc", .kind = .@"error" },
        .{ .msg = "GNU-style inline assembly is disabled", .kind = .@"error" },
        .{ .msg = "extension used", .kind = .off, .pedantic = true, .opt = W("language-extension-token") },
        .{ .msg = "complex initialization specifying real and imaginary components is an extension", .opt = W("complex-component-init"), .kind = .off, .pedantic = true },
        .{ .msg = "ISO C does not support '++'/'--' on complex type '{s}'", .opt = W("pedantic"), .extra = .str, .kind = .off },
        .{ .msg = "argument type '{s}' is not a real floating point type", .extra = .str, .kind = .@"error" },
        .{ .msg = "arguments are of different types ({s})", .extra = .str, .kind = .@"error" },
        .{ .msg = "#include resolved using non-portable Microsoft search rules as: {s}", .extra = .str, .opt = W("microsoft-include"), .kind = .warning },
        .{ .msg = "treating Ctrl-Z as end-of-file is a Microsoft extension", .opt = W("microsoft-end-of-file"), .kind = .off, .pedantic = true },
        .{ .msg = "illegal character encoding in character literal", .opt = W("invalid-source-encoding"), .kind = .warning },
        .{ .msg = "illegal character encoding in character literal", .kind = .@"error" },
        .{ .msg = "character '{c}' cannot be specified by a universal character name", .kind = .@"error", .extra = .ascii },
        .{ .msg = "specifying character '{c}' with a universal character name is incompatible with C standards before C23", .kind = .off, .extra = .ascii, .suppress_unless_version = .c23, .opt = W("pre-c23-compat") },
        .{ .msg = "universal character name refers to a control character", .kind = .@"error" },
        .{ .msg = "universal character name referring to a control character is incompatible with C standards before C23", .kind = .off, .suppress_unless_version = .c23, .opt = W("pre-c23-compat") },
        .{ .msg = "universal character names are only valid in C99 or later", .suppress_version = .c99, .kind = .warning, .opt = W("unicode") },
        .{ .msg = "multi-character character constant", .opt = W("four-char-constants"), .kind = .off },
        .{ .msg = "multi-character character constant", .kind = .off },
        .{ .msg = "\\{c} used with no following hex digits", .kind = .@"error", .extra = .ascii },
        .{ .msg = "unknown escape sequence '\\{s}'", .kind = .warning, .opt = W("unknown-escape-sequence"), .extra = .invalid_escape },
        .{ .msg = "attribute '{s}' requires an ordinary string", .kind = .@"error", .extra = .str },
        .{ .msg = "missing terminating '\"' character", .kind = .warning, .opt = W("invalid-pp-token") },
        .{ .msg = "missing terminating '\"' character", .kind = .@"error" },
        .{ .msg = "empty character constant", .kind = .warning, .opt = W("invalid-pp-token") },
        .{ .msg = "empty character constant", .kind = .@"error" },
        .{ .msg = "missing terminating ' character", .kind = .warning, .opt = W("invalid-pp-token") },
        .{ .msg = "missing terminating ' character", .kind = .@"error" },
        .{ .msg = "unterminated comment", .kind = .@"error" },
        .{ .msg = "a function definition without a prototype is deprecated in all versions of C and is not supported in C23", .kind = .warning, .opt = W("deprecated-non-prototype") },
        .{ .msg = "passing arguments to a function without a prototype is deprecated in all versions of C and is not supported in C23", .kind = .warning, .opt = W("deprecated-non-prototype") },
        .{ .msg = "unknown type name '{s}'", .kind = .@"error", .extra = .str },
        .{ .msg = "label at end of compound statement is a C23 extension", .opt = W("c23-extensions"), .kind = .warning, .suppress_version = .c23 },
        .{ .msg = "UTF-8 character literal is a C23 extension", .opt = W("c23-extensions"), .kind = .warning, .suppress_version = .c23 },
        .{ .msg = "unexpected token in embed parameter", .kind = .@"error" },
        .{ .msg = "the limit parameter expects one non-negative integer as a parameter", .kind = .@"error" },
        .{ .msg = "duplicate embed parameter '{s}'", .kind = .warning, .extra = .str, .opt = W("duplicate-embed-param") },
        .{ .msg = "unsupported embed parameter '{s}' embed parameter", .kind = .warning, .extra = .str, .opt = W("unsupported-embed-param") },
        .{ .msg = "compound literal cannot have {s} storage class", .kind = .@"error", .extra = .str },
        .{ .msg = "missing '(' following __VA_OPT__", .kind = .@"error" },
        .{ .msg = "unterminated __VA_OPT__ argument list", .kind = .@"error" },
        .{ .msg = "attribute value '{s}' out of range", .kind = .@"error", .extra = .str },
        .{ .msg = "'{s}' is not in NFC", .kind = .warning, .extra = .normalized, .opt = W("normalized") },
        .{ .msg = "'auto' requires a plain identifier declarator", .kind = .@"error" },
        .{ .msg = "'auto' can only be used with a single declarator", .kind = .@"error" },
        .{ .msg = "'auto' requires an initializer", .kind = .@"error" },
        .{ .msg = "'auto' requires a scalar initializer", .kind = .@"error" },
        .{ .msg = "shift count is negative", .opt = W("shift-count-negative"), .kind = .warning, .all = true },
        .{ .msg = "shift count >= width of type", .opt = W("shift-count-overflow"), .kind = .warning, .all = true },
        .{ .msg = "ISO C does not support '~' for complex conjugation of '{s}'", .opt = W("pedantic"), .extra = .str, .kind = .off },
        .{ .msg = "operand argument to overflow builtin must be an integer ('{s}' invalid)", .extra = .str, .kind = .@"error" },
        .{ .msg = "result argument to overflow builtin must be a pointer to a non-const integer ('{s}' invalid)", .extra = .str, .kind = .@"error" },
    };
};
};
}
