//! This file implements x86/x86_64 cpu detection.
//!
//! The following function implementations should be reviewed after any update to
//! the autogenerated file lib/compiler_rt/cpu_model/x86.zig in case there's new CPU
//! type/subtype definitions from LLVM (specifically in compiler-rt/lib/builtins/cpu_mode/x86.c):
//!     - detectAMDProcessor()
//!     - detectIntelProcessor()
//!
//! In upstream LLVM, the relevant files for x86 CPU detection are
//!  - llvm/include/llvm/TargetParser/X86TargetParser.def: enum definitions and values
//!  - compiler-rt/lib/builtins/cpu_mode/x86.c: LLVM runtime implementation of x86 cpu detection
//!                                             and symbol definitions
//!  - llvm/include/llvm/TargetParse/X86TargetParser.h
//!    llvm/lib/TargetParser/X86TargetParser.cpp: LLVM helpers for x86 cpu detection
//!  - clang/lib/CodeGen/CGBuiltin.cpp: Clang code that emits x86 feture detection code

const std = @import("std");
const builtin = @import("builtin");
const Target = std.Target;

pub const enums = @import("x86/enums.zig");

const Vendor = enums.Vendor;
const Type = enums.Type;
const Subtype = enums.Subtype;

const XCR0_XMM = 0x02;
const XCR0_YMM = 0x04;
const XCR0_MASKREG = 0x20;
const XCR0_ZMM0_15 = 0x40;
const XCR0_ZMM16_31 = 0x80;

fn setFeature(feature_set: *Target.Cpu.Feature.Set, feature: Target.x86.Feature, enabled: bool) void {
    const idx = @as(Target.Cpu.Feature.Set.Index, @intFromEnum(feature));

    if (enabled) feature_set.addFeature(idx) else feature_set.removeFeature(idx);
}

inline fn bit(input: u32, offset: u5) bool {
    return (input >> offset) & 1 != 0;
}

inline fn hasMask(input: u32, mask: u32) bool {
    return (input & mask) == mask;
}

pub fn detectNativeCpuAndFeatures(arch: Target.Cpu.Arch, os: Target.Os, query: Target.Query) Target.Cpu {
    _ = query;
    // First we detect features, to use as hints when detecting CPU Model.
    const features = blk: {
        var features = Target.Cpu.Feature.Set.empty;
        detectNativeFeatures(&features, os.tag);
        break :blk features;
    };

    const detected: Detected = detectNativeProcessor(arch, features);

    var cpu = Target.Cpu{
        .arch = arch,
        .model = detected.model,
        .features = Target.Cpu.Feature.Set.empty,
    };

    // Add the CPU model's feature set into the working set, but then
    // override with actual detected features again.
    // TODO: can this break in a virtualised environment that provides
    //       fake cpuid values?
    cpu.features.addFeatureSet(cpu.model.features);
    detectNativeFeatures(&cpu.features, os.tag);
    cpu.features.populateDependencies(cpu.arch.allFeaturesList());

    return cpu;
}

pub const Detected = struct {
    vendor: Vendor,
    type: Type,
    subtype: Subtype,
    model: *const Target.Cpu.Model,
};

pub fn detectNativeProcessor(arch: Target.Cpu.Arch, features: Target.Cpu.Feature.Set) Detected {
    const other: Detected = .{
        .vendor = .other,
        .type = .unknown,
        .subtype = .unknown,
        .model = Target.Cpu.Model.generic(arch),
    };

    var leaf = cpuid(0, 0);
    const max_leaf = leaf.eax;
    const vendor = leaf.ebx;

    if (max_leaf > 0) {
        leaf = cpuid(0x1, 0);

        const brand_id = leaf.ebx & 0xff;

        // Detect model and family
        var family = (leaf.eax >> 8) & 0xf;
        var model = (leaf.eax >> 4) & 0xf;
        if (family == 6 or family == 0xf) {
            if (family == 0xf) {
                family += (leaf.eax >> 20) & 0xff;
            }
            model += ((leaf.eax >> 16) & 0xf) << 4;
        }

        // Now we detect the model.
        return switch (vendor) {
            0x756e6547 => detectIntelProcessor(arch, features, family, model, brand_id),
            0x68747541 => detectAMDProcessor(arch, features, family, model),
            else => other,
        };
    }

    return other;
}

fn detectIntelProcessor(
    arch: Target.Cpu.Arch,
    features: Target.Cpu.Feature.Set,
    family: u32,
    model: u32,
    brand_id: u32,
) Detected {
    var d: Detected = .{
        .vendor = .intel,
        .type = .unknown,
        .subtype = .unknown,
        .model = Target.Cpu.Model.generic(arch),
    };

    if (brand_id != 0) {
        return d;
    }

    switch (family) {
        3 => {
            d.model = &Target.x86.cpu.i386;
        },
        4 => {
            d.model = &Target.x86.cpu.i486;
        },
        5 => {
            if (Target.x86.featureSetHas(features, .mmx)) {
                d.model = &Target.x86.cpu.pentium_mmx;
            } else {
                d.model = &Target.x86.cpu.pentium;
            }
        },
        6 => {
            switch (model) {
                0x01 => {
                    d.model = &Target.x86.cpu.pentiumpro;
                },
                0x03, 0x05, 0x06 => {
                    d.model = &Target.x86.cpu.pentium2;
                },
                0x07, 0x08, 0x0a, 0x0b => {
                    d.model = &Target.x86.cpu.pentium3;
                },
                0x09, 0x0d, 0x15 => {
                    d.model = &Target.x86.cpu.pentium_m;
                },
                0x0e => {
                    d.model = &Target.x86.cpu.yonah;
                },
                0x0f, 0x16 => {
                    d.type = .intel_core2;
                    d.model = &Target.x86.cpu.core2;
                },
                0x17, 0x1d => {
                    d.type = .intel_core2;
                    d.model = &Target.x86.cpu.penryn;
                },
                0x1a, 0x1e, 0x1f, 0x2e => {
                    d.type = .intel_corei7;
                    d.subtype = .intel_corei7_nehalem;
                    d.model = &Target.x86.cpu.nehalem;
                },
                0x25, 0x2c, 0x2f => {
                    d.type = .intel_corei7;
                    d.subtype = .intel_corei7_westmere;
                    d.model = &Target.x86.cpu.westmere;
                },
                0x2a, 0x2d => {
                    d.type = .intel_corei7;
                    d.subtype = .intel_corei7_sandybridge;
                    d.model = &Target.x86.cpu.sandybridge;
                },
                0x3a, 0x3e => {
                    d.type = .intel_corei7;
                    d.subtype = .intel_corei7_ivybridge;
                    d.model = &Target.x86.cpu.ivybridge;
                },
                0x3c, 0x3f, 0x45, 0x46 => {
                    d.type = .intel_corei7;
                    d.subtype = .intel_corei7_haswell;
                    d.model = &Target.x86.cpu.haswell;
                },
                0x3d, 0x47, 0x4f, 0x56 => {
                    d.type = .intel_corei7;
                    d.subtype = .intel_corei7_broadwell;
                    d.model = &Target.x86.cpu.broadwell;
                },
                0x4e, 0x5e, 0x8e, 0x9e, 0xa5, 0xa6 => {
                    d.type = .intel_corei7;
                    d.subtype = .intel_corei7_skylake;
                    d.model = &Target.x86.cpu.skylake;
                },
                0xa7 => {
                    d.type = .intel_corei7;
                    d.subtype = .intel_corei7_rocketlake;
                    d.model = &Target.x86.cpu.rocketlake;
                },
                0x55 => {
                    d.type = .intel_corei7;
                    if (Target.x86.featureSetHas(features, .avx512bf16)) {
                        d.subtype = .intel_corei7_cooperlake;
                        d.model = &Target.x86.cpu.cooperlake;
                    } else if (Target.x86.featureSetHas(features, .avx512vnni)) {
                        d.subtype = .intel_corei7_cascadelake;
                        d.model = &Target.x86.cpu.cascadelake;
                    } else {
                        d.subtype = .intel_corei7_skylake_avx512;
                        d.model = &Target.x86.cpu.skylake_avx512;
                    }
                },
                0x66 => {
                    d.type = .intel_corei7;
                    d.subtype = .intel_corei7_cannonlake;
                    d.model = &Target.x86.cpu.cannonlake;
                },
                0x7d, 0x7e => {
                    d.type = .intel_corei7;
                    d.subtype = .intel_corei7_icelake_client;
                    d.model = &Target.x86.cpu.icelake_client;
                },
                0x6a, 0x6c => {
                    d.type = .intel_corei7;
                    d.subtype = .intel_corei7_icelake_server;
                    d.model = &Target.x86.cpu.icelake_server;
                },
                0x8c, 0x8d => {
                    d.type = .intel_corei7;
                    d.subtype = .intel_corei7_tigerlake;
                    d.model = &Target.x86.cpu.tigerlake;
                },
                0x97, 0x9a => {
                    d.type = .intel_corei7;
                    d.subtype = .intel_corei7_alderlake;
                    d.model = &Target.x86.cpu.alderlake;
                },
                0xbe => {
                    d.type = .intel_corei7;
                    d.subtype = .intel_corei7_alderlake; // not a typo
                    d.model = &Target.x86.cpu.gracemont;
                },
                0xb7, 0xba, 0xbf => {
                    d.type = .intel_corei7;
                    d.subtype = .intel_corei7_alderlake; // not a typo
                    d.model = &Target.x86.cpu.raptorlake;
                },
                0xaa, 0xac => {
                    d.type = .intel_corei7;
                    d.subtype = .intel_corei7_alderlake; // not a typo
                    d.model = &Target.x86.cpu.meteorlake;
                },
                0xc5, 0xb5 => {
                    d.type = .intel_corei7;
                    d.subtype = .intel_corei7_arrowlake;
                    d.model = &Target.x86.cpu.arrowlake;
                },
                0xc6 => {
                    d.type = .intel_corei7;
                    d.subtype = .intel_corei7_arrowlake_s;
                    d.model = &Target.x86.cpu.arrowlake_s;
                },
                0xbd => {
                    d.type = .intel_corei7;
                    d.subtype = .intel_corei7_arrowlake_s; // not a typo
                    d.model = &Target.x86.cpu.lunarlake;
                },
                0xcc => {
                    d.type = .intel_corei7;
                    d.subtype = .intel_corei7_pantherlake;
                    d.model = &Target.x86.cpu.pantherlake;
                },
                0xad => {
                    d.type = .intel_corei7;
                    d.subtype = .intel_corei7_graniterapids;
                    d.model = &Target.x86.cpu.graniterapids;
                },
                0xae => {
                    d.type = .intel_corei7;
                    d.subtype = .intel_corei7_graniterapids_d;
                    d.model = &Target.x86.cpu.graniterapids_d;
                },
                0xcf => {
                    d.type = .intel_corei7;
                    d.subtype = .intel_corei7_sapphirerapids; // not a typo
                    d.model = &Target.x86.cpu.emeraldrapids;
                },
                0x8f => {
                    d.type = .intel_corei7;
                    d.subtype = .intel_corei7_sapphirerapids;
                    d.model = &Target.x86.cpu.sapphirerapids;
                },
                0x1c, 0x26, 0x27, 0x35, 0x36 => {
                    d.type = .intel_bonnell;
                    d.model = &Target.x86.cpu.bonnell;
                },
                0x37, 0x4a, 0x4d, 0x5a, 0x5d, 0x4c => {
                    d.type = .intel_silvermont;
                    d.model = &Target.x86.cpu.silvermont;
                },
                0x5c, 0x5f => {
                    d.type = .intel_goldmont;
                    d.model = &Target.x86.cpu.goldmont;
                },
                0x7a => {
                    d.type = .intel_goldmont_plus;
                    d.model = &Target.x86.cpu.goldmont_plus;
                },
                0x86, 0x8a, 0x96, 0x9c => {
                    d.type = .intel_tremont;
                    d.model = &Target.x86.cpu.tremont;
                },
                0xaf => {
                    d.type = .intel_sierraforest;
                    d.model = &Target.x86.cpu.sierraforest;
                },
                0xb6 => {
                    d.type = .intel_grandridge;
                    d.model = &Target.x86.cpu.grandridge;
                },
                0xdd => {
                    d.type = .intel_clearwaterforest;
                    d.model = &Target.x86.cpu.clearwaterforest;
                },
                0x57 => {
                    d.type = .intel_knl;
                    d.model = &Target.x86.cpu.knl;
                },
                0x85 => {
                    d.type = .intel_knm;
                    d.model = &Target.x86.cpu.knm;
                },
                else => {},
            }
        },
        15 => {
            if (Target.x86.featureSetHas(features, .@"64bit")) {
                d.model = &Target.x86.cpu.nocona;
            } else if (Target.x86.featureSetHas(features, .sse3)) {
                d.model = &Target.x86.cpu.prescott;
            } else {
                d.model = &Target.x86.cpu.pentium4;
            }
        },
        else => {}, // Unknown CPU Model
    }
    return d;
}

fn detectAMDProcessor(
    arch: Target.Cpu.Arch,
    features: Target.Cpu.Feature.Set,
    family: u32,
    model: u32,
) Detected {
    var d: Detected = .{
        .vendor = .amd,
        .type = .unknown,
        .subtype = .unknown,
        .model = Target.Cpu.Model.generic(arch),
    };

    switch (family) {
        4 => {
            d.model = &Target.x86.cpu.i486;
        },
        5 => switch (model) {
            6, 7 => {
                d.model = &Target.x86.cpu.k6;
            },
            8 => {
                d.model = &Target.x86.cpu.k6_2;
            },
            9, 13 => {
                d.model = &Target.x86.cpu.k6_3;
            },
            10 => {
                d.model = &Target.x86.cpu.geode;
            },
            else => {
                d.model = &Target.x86.cpu.pentium;
            },
        },
        6 => if (Target.x86.featureSetHas(features, .sse)) {
            d.model = &Target.x86.cpu.athlon_xp;
        } else {
            d.model = &Target.x86.cpu.athlon;
        },
        15 => if (Target.x86.featureSetHas(features, .sse3)) {
            d.model = &Target.x86.cpu.k8_sse3;
        } else {
            d.model = &Target.x86.cpu.k8;
        },
        16, 18 => {
            d.type = .amdfam10h;
            switch (model) {
                2 => d.subtype = .amdfam10h_barcelona,
                4 => d.subtype = .amdfam10h_shanghai,
                8 => d.subtype = .amdfam10h_istanbul,
                else => {},
            }
            d.model = &Target.x86.cpu.amdfam10;
        },
        20 => {
            d.type = .amd_btver1;
            d.model = &Target.x86.cpu.btver1;
        },
        21 => {
            d.type = .amdfam15h;
            switch (model) {
                0x60...0x7f => {
                    d.subtype = .amdfam15h_bdver4;
                    d.model = &Target.x86.cpu.bdver4;
                },
                0x30...0x3f => {
                    d.subtype = .amdfam15h_bdver3;
                    d.model = &Target.x86.cpu.bdver3;
                },
                0x02, 0x10...0x1f => {
                    d.subtype = .amdfam15h_bdver2;
                    d.model = &Target.x86.cpu.bdver2;
                },
                else => {
                    d.subtype = .amdfam15h_bdver1;
                    d.model = &Target.x86.cpu.bdver1;
                },
            }
        },
        22 => {
            d.type = .amd_btver2;
            d.model = &Target.x86.cpu.btver2;
        },
        23 => {
            d.type = .amdfam17h;
            switch (model) {
                0x30...0x3f,
                0x47,
                0x60...0x6f,
                0x70...0x7f,
                0x84...0x87,
                0x90...0x9f,
                0xa0...0xaf,
                => {
                    d.subtype = .amdfam17h_znver2;
                    d.model = &Target.x86.cpu.znver2;
                },
                else => {
                    d.subtype = .amdfam17h_znver1;
                    d.model = &Target.x86.cpu.znver1;
                },
            }
        },
        25 => {
            d.type = .amdfam19h;
            switch (model) {
                0x10...0x1f,
                0x60...0x6f,
                0x70...0x7f,
                0xa0...0xaf,
                => {
                    d.subtype = .amdfam19h_znver4;
                    d.model = &Target.x86.cpu.znver4;
                },
                else => {
                    d.subtype = .amdfam19h_znver3;
                    d.model = &Target.x86.cpu.znver3;
                },
            }
        },
        26 => {
            d.type = .amdfam1ah;
            if (model < 0x77) d.subtype = .amdfam1ah_znver5; // Models 00h-77h
            d.model = &Target.x86.cpu.znver5;
        },
        else => {},
    }

    return d;
}

pub fn detectNativeFeatures(features: *Target.Cpu.Feature.Set, os_tag: Target.Os.Tag) void {
    var leaf = cpuid(0, 0);

    const max_level = leaf.eax;

    leaf = cpuid(1, 0);

    setFeature(features, .cx8, bit(leaf.edx, 8));
    setFeature(features, .cmov, bit(leaf.edx, 15));
    setFeature(features, .mmx, bit(leaf.edx, 23));
    setFeature(features, .fxsr, bit(leaf.edx, 24));
    setFeature(features, .sse, bit(leaf.edx, 25));
    setFeature(features, .sse2, bit(leaf.edx, 26));
    setFeature(features, .sse3, bit(leaf.ecx, 0));
    setFeature(features, .pclmul, bit(leaf.ecx, 1));
    setFeature(features, .ssse3, bit(leaf.ecx, 9));
    setFeature(features, .cx16, bit(leaf.ecx, 13));
    setFeature(features, .sse4_1, bit(leaf.ecx, 19));
    setFeature(features, .sse4_2, bit(leaf.ecx, 20));
    setFeature(features, .movbe, bit(leaf.ecx, 22));
    setFeature(features, .popcnt, bit(leaf.ecx, 23));
    setFeature(features, .aes, bit(leaf.ecx, 25));
    setFeature(features, .rdrnd, bit(leaf.ecx, 30));

    const has_xsave = bit(leaf.ecx, 27);
    const has_avx = bit(leaf.ecx, 28);

    // Make sure not to call xgetbv if xsave is not supported
    const xcr0_eax = if (has_xsave and has_avx) getXCR0() else 0;

    const has_avx_save = hasMask(xcr0_eax, XCR0_XMM | XCR0_YMM);

    // LLVM approaches avx512_save by hardcoding it to true on Darwin,
    // because the kernel saves the context even if the bit is not set.
    // https://github.com/llvm/llvm-project/blob/bca373f73fc82728a8335e7d6cd164e8747139ec/llvm/lib/Support/Host.cpp#L1378
    //
    // Google approaches this by using a different series of checks and flags,
    // and this may report the feature more accurately on a technically correct
    // but ultimately less useful level.
    // https://github.com/google/cpu_features/blob/b5c271c53759b2b15ff91df19bd0b32f2966e275/src/cpuinfo_x86.c#L113
    // (called from https://github.com/google/cpu_features/blob/b5c271c53759b2b15ff91df19bd0b32f2966e275/src/cpuinfo_x86.c#L1052)
    //
    // Right now, we use LLVM's approach, because even if the target doesn't support
    // the feature, the kernel should provide the same functionality transparently,
    // so the implementation details don't make a difference.
    // That said, this flag impacts other CPU features' availability,
    // so until we can verify that this doesn't come with side affects,
    // we'll say TODO verify this.

    // Darwin lazily saves the AVX512 context on first use: trust that the OS will
    // save the AVX512 context if we use AVX512 instructions, even if the bit is not
    // set right now.
    const has_avx512_save = switch (os_tag.isDarwin()) {
        true => true,
        false => hasMask(xcr0_eax, XCR0_MASKREG | XCR0_ZMM0_15 | XCR0_ZMM16_31),
    };

    setFeature(features, .avx, has_avx_save);
    setFeature(features, .fma, has_avx_save and bit(leaf.ecx, 12));
    // Only enable XSAVE if OS has enabled support for saving YMM state.
    setFeature(features, .xsave, has_avx_save and bit(leaf.ecx, 26));
    setFeature(features, .f16c, has_avx_save and bit(leaf.ecx, 29));

    leaf = cpuid(0x80000000, 0);
    const max_ext_level = leaf.eax;

    if (max_ext_level >= 0x80000001) {
        leaf = cpuid(0x80000001, 0);
        setFeature(features, .sahf, bit(leaf.ecx, 0));
        setFeature(features, .lzcnt, bit(leaf.ecx, 5));
        setFeature(features, .sse4a, bit(leaf.ecx, 6));
        setFeature(features, .prfchw, bit(leaf.ecx, 8));
        setFeature(features, .xop, bit(leaf.ecx, 11) and has_avx_save);
        setFeature(features, .lwp, bit(leaf.ecx, 15));
        setFeature(features, .fma4, bit(leaf.ecx, 16) and has_avx_save);
        setFeature(features, .tbm, bit(leaf.ecx, 21));
        setFeature(features, .mwaitx, bit(leaf.ecx, 29));
        setFeature(features, .@"64bit", bit(leaf.edx, 29));
    } else {
        for ([_]Target.x86.Feature{
            .sahf, .lzcnt, .sse4a, .prfchw, .xop,
            .lwp,  .fma4,  .tbm,   .mwaitx, .@"64bit",
        }) |feat| {
            setFeature(features, feat, false);
        }
    }

    // Misc. memory-related features.
    if (max_ext_level >= 0x80000008) {
        leaf = cpuid(0x80000008, 0);
        setFeature(features, .clzero, bit(leaf.ebx, 0));
        setFeature(features, .wbnoinvd, bit(leaf.ebx, 9));
    } else {
        for ([_]Target.x86.Feature{ .clzero, .wbnoinvd }) |feat| {
            setFeature(features, feat, false);
        }
    }

    if (max_level >= 0x7) {
        leaf = cpuid(0x7, 0);

        setFeature(features, .fsgsbase, bit(leaf.ebx, 0));
        setFeature(features, .sgx, bit(leaf.ebx, 2));
        setFeature(features, .bmi, bit(leaf.ebx, 3));
        // AVX2 is only supported if we have the OS save support from AVX.
        setFeature(features, .avx2, bit(leaf.ebx, 5) and has_avx_save);
        setFeature(features, .smep, bit(leaf.ebx, 7));
        setFeature(features, .bmi2, bit(leaf.ebx, 8));
        setFeature(features, .invpcid, bit(leaf.ebx, 10));
        setFeature(features, .rtm, bit(leaf.ebx, 11));
        // AVX512 is only supported if the OS supports the context save for it.
        setFeature(features, .avx512f, bit(leaf.ebx, 16) and has_avx512_save);
        setFeature(features, .avx512dq, bit(leaf.ebx, 17) and has_avx512_save);
        setFeature(features, .rdseed, bit(leaf.ebx, 18));
        setFeature(features, .adx, bit(leaf.ebx, 19));
        setFeature(features, .smap, bit(leaf.ebx, 20));
        setFeature(features, .avx512ifma, bit(leaf.ebx, 21) and has_avx512_save);
        setFeature(features, .clflushopt, bit(leaf.ebx, 23));
        setFeature(features, .clwb, bit(leaf.ebx, 24));
        setFeature(features, .avx512pf, bit(leaf.ebx, 26) and has_avx512_save);
        setFeature(features, .avx512er, bit(leaf.ebx, 27) and has_avx512_save);
        setFeature(features, .avx512cd, bit(leaf.ebx, 28) and has_avx512_save);
        setFeature(features, .sha, bit(leaf.ebx, 29));
        setFeature(features, .avx512bw, bit(leaf.ebx, 30) and has_avx512_save);
        setFeature(features, .avx512vl, bit(leaf.ebx, 31) and has_avx512_save);

        setFeature(features, .prefetchwt1, bit(leaf.ecx, 0));
        setFeature(features, .avx512vbmi, bit(leaf.ecx, 1) and has_avx512_save);
        setFeature(features, .pku, bit(leaf.ecx, 4));
        setFeature(features, .waitpkg, bit(leaf.ecx, 5));
        setFeature(features, .avx512vbmi2, bit(leaf.ecx, 6) and has_avx512_save);
        setFeature(features, .shstk, bit(leaf.ecx, 7));
        setFeature(features, .gfni, bit(leaf.ecx, 8));
        setFeature(features, .vaes, bit(leaf.ecx, 9) and has_avx_save);
        setFeature(features, .vpclmulqdq, bit(leaf.ecx, 10) and has_avx_save);
        setFeature(features, .avx512vnni, bit(leaf.ecx, 11) and has_avx512_save);
        setFeature(features, .avx512bitalg, bit(leaf.ecx, 12) and has_avx512_save);
        setFeature(features, .avx512vpopcntdq, bit(leaf.ecx, 14) and has_avx512_save);
        setFeature(features, .avx512vp2intersect, bit(leaf.edx, 8) and has_avx512_save);
        setFeature(features, .rdpid, bit(leaf.ecx, 22));
        setFeature(features, .cldemote, bit(leaf.ecx, 25));
        setFeature(features, .movdiri, bit(leaf.ecx, 27));
        setFeature(features, .movdir64b, bit(leaf.ecx, 28));
        setFeature(features, .enqcmd, bit(leaf.ecx, 29));

        // There are two CPUID leafs which information associated with the pconfig
        // instruction:
        // EAX=0x7, ECX=0x0 indicates the availability of the instruction (via the 18th
        // bit of EDX), while the EAX=0x1b leaf returns information on the
        // availability of specific pconfig leafs.
        // The target feature here only refers to the the first of these two.
        // Users might need to check for the availability of specific pconfig
        // leaves using cpuid, since that information is ignored while
        // detecting features using the "-march=native" flag.
        // For more info, see X86 ISA docs.
        setFeature(features, .pconfig, bit(leaf.edx, 18));
        setFeature(features, .uintr, bit(leaf.edx, 5));

        // TODO I feel unsure about this check.
        //      It doesn't really seem to check for 7.1, just for 7.
        //      Is this a sound assumption to make?
        //      Note that this is what other implementations do, so I kind of trust it.
        const has_leaf_7_1 = max_level >= 7;
        if (has_leaf_7_1) {
            leaf = cpuid(0x7, 0x1);
            setFeature(features, .avx512bf16, bit(leaf.eax, 5) and has_avx512_save);
        } else {
            setFeature(features, .avx512bf16, false);
        }
    } else {
        for ([_]Target.x86.Feature{
            .fsgsbase,           .sgx,        .bmi,          .avx2,
            .bmi2,               .invpcid,    .rtm,          .avx512f,
            .avx512dq,           .rdseed,     .adx,          .avx512ifma,
            .clflushopt,         .clwb,       .avx512pf,     .avx512er,
            .avx512cd,           .sha,        .avx512bw,     .avx512vl,
            .prefetchwt1,        .avx512vbmi, .pku,          .waitpkg,
            .avx512vbmi2,        .shstk,      .gfni,         .vaes,
            .vpclmulqdq,         .avx512vnni, .avx512bitalg, .avx512vpopcntdq,
            .avx512vp2intersect, .rdpid,      .cldemote,     .movdiri,
            .movdir64b,          .enqcmd,     .pconfig,      .avx512bf16,
        }) |feat| {
            setFeature(features, feat, false);
        }
    }

    if (max_level >= 0xD and has_avx_save) {
        leaf = cpuid(0xD, 0x1);
        // Only enable XSAVE if OS has enabled support for saving YMM state.
        setFeature(features, .xsaveopt, bit(leaf.eax, 0));
        setFeature(features, .xsavec, bit(leaf.eax, 1));
        setFeature(features, .xsaves, bit(leaf.eax, 3));
    } else {
        for ([_]Target.x86.Feature{ .xsaveopt, .xsavec, .xsaves }) |feat| {
            setFeature(features, feat, false);
        }
    }

    if (max_level >= 0x14) {
        leaf = cpuid(0x14, 0);
        setFeature(features, .ptwrite, bit(leaf.ebx, 4));
    } else {
        setFeature(features, .ptwrite, false);
    }
}

const CpuidLeaf = packed struct {
    eax: u32,
    ebx: u32,
    ecx: u32,
    edx: u32,
};

/// This is a workaround for the C backend until zig has the ability to put
/// C code in inline assembly.
extern fn zig_x86_cpuid(leaf_id: u32, subid: u32, eax: *u32, ebx: *u32, ecx: *u32, edx: *u32) callconv(.c) void;

fn cpuid(leaf_id: u32, subid: u32) CpuidLeaf {
    // valid for both x86 and x86_64
    var eax: u32 = undefined;
    var ebx: u32 = undefined;
    var ecx: u32 = undefined;
    var edx: u32 = undefined;

    if (builtin.zig_backend == .stage2_c) {
        zig_x86_cpuid(leaf_id, subid, &eax, &ebx, &ecx, &edx);
    } else {
        asm volatile ("cpuid"
            : [_] "={eax}" (eax),
              [_] "={ebx}" (ebx),
              [_] "={ecx}" (ecx),
              [_] "={edx}" (edx),
            : [_] "{eax}" (leaf_id),
              [_] "{ecx}" (subid),
        );
    }

    return .{ .eax = eax, .ebx = ebx, .ecx = ecx, .edx = edx };
}

/// This is a workaround for the C backend until zig has the ability to put
/// C code in inline assembly.
extern fn zig_x86_get_xcr0() callconv(.c) u32;

// Read control register 0 (XCR0). Used to detect features such as AVX.
fn getXCR0() u32 {
    if (builtin.zig_backend == .stage2_c) {
        return zig_x86_get_xcr0();
    }

    return asm volatile (
        \\ xor %%ecx, %%ecx
        \\ xgetbv
        : [_] "={eax}" (-> u32),
        :
        : "edx", "ecx"
    );
}
