const std = @import("../../../std.zig");
const kern = @import("kern.zig");

const PtRegs = @compileError("TODO missing os bits: PtRegs");
const TcpHdr = @compileError("TODO missing os bits: TcpHdr");
const SkFullSock = @compileError("TODO missing os bits: SkFullSock");

// in BPF, all the helper calls
// TODO: when https://github.com/ziglang/zig/issues/1717 is here, make a nice
// function that uses the Helper enum
//
// Note, these function signatures were created from documentation found in
// '/usr/include/linux/bpf.h'
pub const map_lookup_elem = @intToPtr(*const fn (map: *const kern.MapDef, key: ?*const anyopaque) ?*anyopaque, 1);
pub const map_update_elem = @intToPtr(*const fn (map: *const kern.MapDef, key: ?*const anyopaque, value: ?*const anyopaque, flags: u64) c_long, 2);
pub const map_delete_elem = @intToPtr(*const fn (map: *const kern.MapDef, key: ?*const anyopaque) c_long, 3);
pub const probe_read = @intToPtr(*const fn (dst: ?*anyopaque, size: u32, unsafe_ptr: ?*const anyopaque) c_long, 4);
pub const ktime_get_ns = @intToPtr(*const fn () u64, 5);
pub const trace_printk = @intToPtr(*const fn (fmt: [*:0]const u8, fmt_size: u32, arg1: u64, arg2: u64, arg3: u64) c_long, 6);
pub const get_prandom_u32 = @intToPtr(*const fn () u32, 7);
pub const get_smp_processor_id = @intToPtr(*const fn () u32, 8);
pub const skb_store_bytes = @intToPtr(*const fn (skb: *kern.SkBuff, offset: u32, from: ?*const anyopaque, len: u32, flags: u64) c_long, 9);
pub const l3_csum_replace = @intToPtr(*const fn (skb: *kern.SkBuff, offset: u32, from: u64, to: u64, size: u64) c_long, 10);
pub const l4_csum_replace = @intToPtr(*const fn (skb: *kern.SkBuff, offset: u32, from: u64, to: u64, flags: u64) c_long, 11);
pub const tail_call = @intToPtr(*const fn (ctx: ?*anyopaque, prog_array_map: *const kern.MapDef, index: u32) c_long, 12);
pub const clone_redirect = @intToPtr(*const fn (skb: *kern.SkBuff, ifindex: u32, flags: u64) c_long, 13);
pub const get_current_pid_tgid = @intToPtr(*const fn () u64, 14);
pub const get_current_uid_gid = @intToPtr(*const fn () u64, 15);
pub const get_current_comm = @intToPtr(*const fn (buf: ?*anyopaque, size_of_buf: u32) c_long, 16);
pub const get_cgroup_classid = @intToPtr(*const fn (skb: *kern.SkBuff) u32, 17);
// Note vlan_proto is big endian
pub const skb_vlan_push = @intToPtr(*const fn (skb: *kern.SkBuff, vlan_proto: u16, vlan_tci: u16) c_long, 18);
pub const skb_vlan_pop = @intToPtr(*const fn (skb: *kern.SkBuff) c_long, 19);
pub const skb_get_tunnel_key = @intToPtr(*const fn (skb: *kern.SkBuff, key: *kern.TunnelKey, size: u32, flags: u64) c_long, 20);
pub const skb_set_tunnel_key = @intToPtr(*const fn (skb: *kern.SkBuff, key: *kern.TunnelKey, size: u32, flags: u64) c_long, 21);
pub const perf_event_read = @intToPtr(*const fn (map: *const kern.MapDef, flags: u64) u64, 22);
pub const redirect = @intToPtr(*const fn (ifindex: u32, flags: u64) c_long, 23);
pub const get_route_realm = @intToPtr(*const fn (skb: *kern.SkBuff) u32, 24);
pub const perf_event_output = @intToPtr(*const fn (ctx: ?*anyopaque, map: *const kern.MapDef, flags: u64, data: ?*anyopaque, size: u64) c_long, 25);
pub const skb_load_bytes = @intToPtr(*const fn (skb: ?*anyopaque, offset: u32, to: ?*anyopaque, len: u32) c_long, 26);
pub const get_stackid = @intToPtr(*const fn (ctx: ?*anyopaque, map: *const kern.MapDef, flags: u64) c_long, 27);
// from and to point to __be32
pub const csum_diff = @intToPtr(*const fn (from: *u32, from_size: u32, to: *u32, to_size: u32, seed: u32) i64, 28);
pub const skb_get_tunnel_opt = @intToPtr(*const fn (skb: *kern.SkBuff, opt: ?*anyopaque, size: u32) c_long, 29);
pub const skb_set_tunnel_opt = @intToPtr(*const fn (skb: *kern.SkBuff, opt: ?*anyopaque, size: u32) c_long, 30);
// proto is __be16
pub const skb_change_proto = @intToPtr(*const fn (skb: *kern.SkBuff, proto: u16, flags: u64) c_long, 31);
pub const skb_change_type = @intToPtr(*const fn (skb: *kern.SkBuff, skb_type: u32) c_long, 32);
pub const skb_under_cgroup = @intToPtr(*const fn (skb: *kern.SkBuff, map: ?*const anyopaque, index: u32) c_long, 33);
pub const get_hash_recalc = @intToPtr(*const fn (skb: *kern.SkBuff) u32, 34);
pub const get_current_task = @intToPtr(*const fn () u64, 35);
pub const probe_write_user = @intToPtr(*const fn (dst: ?*anyopaque, src: ?*const anyopaque, len: u32) c_long, 36);
pub const current_task_under_cgroup = @intToPtr(*const fn (map: *const kern.MapDef, index: u32) c_long, 37);
pub const skb_change_tail = @intToPtr(*const fn (skb: *kern.SkBuff, len: u32, flags: u64) c_long, 38);
pub const skb_pull_data = @intToPtr(*const fn (skb: *kern.SkBuff, len: u32) c_long, 39);
pub const csum_update = @intToPtr(*const fn (skb: *kern.SkBuff, csum: u32) i64, 40);
pub const set_hash_invalid = @intToPtr(*const fn (skb: *kern.SkBuff) void, 41);
pub const get_numa_node_id = @intToPtr(*const fn () c_long, 42);
pub const skb_change_head = @intToPtr(*const fn (skb: *kern.SkBuff, len: u32, flags: u64) c_long, 43);
pub const xdp_adjust_head = @intToPtr(*const fn (xdp_md: *kern.XdpMd, delta: c_int) c_long, 44);
pub const probe_read_str = @intToPtr(*const fn (dst: ?*anyopaque, size: u32, unsafe_ptr: ?*const anyopaque) c_long, 45);
pub const get_socket_cookie = @intToPtr(*const fn (ctx: ?*anyopaque) u64, 46);
pub const get_socket_uid = @intToPtr(*const fn (skb: *kern.SkBuff) u32, 47);
pub const set_hash = @intToPtr(*const fn (skb: *kern.SkBuff, hash: u32) c_long, 48);
pub const setsockopt = @intToPtr(*const fn (bpf_socket: *kern.SockOps, level: c_int, optname: c_int, optval: ?*anyopaque, optlen: c_int) c_long, 49);
pub const skb_adjust_room = @intToPtr(*const fn (skb: *kern.SkBuff, len_diff: i32, mode: u32, flags: u64) c_long, 50);
pub const redirect_map = @intToPtr(*const fn (map: *const kern.MapDef, key: u32, flags: u64) c_long, 51);
pub const sk_redirect_map = @intToPtr(*const fn (skb: *kern.SkBuff, map: *const kern.MapDef, key: u32, flags: u64) c_long, 52);
pub const sock_map_update = @intToPtr(*const fn (skops: *kern.SockOps, map: *const kern.MapDef, key: ?*anyopaque, flags: u64) c_long, 53);
pub const xdp_adjust_meta = @intToPtr(*const fn (xdp_md: *kern.XdpMd, delta: c_int) c_long, 54);
pub const perf_event_read_value = @intToPtr(*const fn (map: *const kern.MapDef, flags: u64, buf: *kern.PerfEventValue, buf_size: u32) c_long, 55);
pub const perf_prog_read_value = @intToPtr(*const fn (ctx: *kern.PerfEventData, buf: *kern.PerfEventValue, buf_size: u32) c_long, 56);
pub const getsockopt = @intToPtr(*const fn (bpf_socket: ?*anyopaque, level: c_int, optname: c_int, optval: ?*anyopaque, optlen: c_int) c_long, 57);
pub const override_return = @intToPtr(*const fn (regs: *PtRegs, rc: u64) c_long, 58);
pub const sock_ops_cb_flags_set = @intToPtr(*const fn (bpf_sock: *kern.SockOps, argval: c_int) c_long, 59);
pub const msg_redirect_map = @intToPtr(*const fn (msg: *kern.SkMsgMd, map: *const kern.MapDef, key: u32, flags: u64) c_long, 60);
pub const msg_apply_bytes = @intToPtr(*const fn (msg: *kern.SkMsgMd, bytes: u32) c_long, 61);
pub const msg_cork_bytes = @intToPtr(*const fn (msg: *kern.SkMsgMd, bytes: u32) c_long, 62);
pub const msg_pull_data = @intToPtr(*const fn (msg: *kern.SkMsgMd, start: u32, end: u32, flags: u64) c_long, 63);
pub const bind = @intToPtr(*const fn (ctx: *kern.BpfSockAddr, addr: *kern.SockAddr, addr_len: c_int) c_long, 64);
pub const xdp_adjust_tail = @intToPtr(*const fn (xdp_md: *kern.XdpMd, delta: c_int) c_long, 65);
pub const skb_get_xfrm_state = @intToPtr(*const fn (skb: *kern.SkBuff, index: u32, xfrm_state: *kern.XfrmState, size: u32, flags: u64) c_long, 66);
pub const get_stack = @intToPtr(*const fn (ctx: ?*anyopaque, buf: ?*anyopaque, size: u32, flags: u64) c_long, 67);
pub const skb_load_bytes_relative = @intToPtr(*const fn (skb: ?*const anyopaque, offset: u32, to: ?*anyopaque, len: u32, start_header: u32) c_long, 68);
pub const fib_lookup = @intToPtr(*const fn (ctx: ?*anyopaque, params: *kern.FibLookup, plen: c_int, flags: u32) c_long, 69);
pub const sock_hash_update = @intToPtr(*const fn (skops: *kern.SockOps, map: *const kern.MapDef, key: ?*anyopaque, flags: u64) c_long, 70);
pub const msg_redirect_hash = @intToPtr(*const fn (msg: *kern.SkMsgMd, map: *const kern.MapDef, key: ?*anyopaque, flags: u64) c_long, 71);
pub const sk_redirect_hash = @intToPtr(*const fn (skb: *kern.SkBuff, map: *const kern.MapDef, key: ?*anyopaque, flags: u64) c_long, 72);
pub const lwt_push_encap = @intToPtr(*const fn (skb: *kern.SkBuff, typ: u32, hdr: ?*anyopaque, len: u32) c_long, 73);
pub const lwt_seg6_store_bytes = @intToPtr(*const fn (skb: *kern.SkBuff, offset: u32, from: ?*const anyopaque, len: u32) c_long, 74);
pub const lwt_seg6_adjust_srh = @intToPtr(*const fn (skb: *kern.SkBuff, offset: u32, delta: i32) c_long, 75);
pub const lwt_seg6_action = @intToPtr(*const fn (skb: *kern.SkBuff, action: u32, param: ?*anyopaque, param_len: u32) c_long, 76);
pub const rc_repeat = @intToPtr(*const fn (ctx: ?*anyopaque) c_long, 77);
pub const rc_keydown = @intToPtr(*const fn (ctx: ?*anyopaque, protocol: u32, scancode: u64, toggle: u32) c_long, 78);
pub const skb_cgroup_id = @intToPtr(*const fn (skb: *kern.SkBuff) u64, 79);
pub const get_current_cgroup_id = @intToPtr(*const fn () u64, 80);
pub const get_local_storage = @intToPtr(*const fn (map: ?*anyopaque, flags: u64) ?*anyopaque, 81);
pub const sk_select_reuseport = @intToPtr(*const fn (reuse: *kern.SkReusePortMd, map: *const kern.MapDef, key: ?*anyopaque, flags: u64) c_long, 82);
pub const skb_ancestor_cgroup_id = @intToPtr(*const fn (skb: *kern.SkBuff, ancestor_level: c_int) u64, 83);
pub const sk_lookup_tcp = @intToPtr(*const fn (ctx: ?*anyopaque, tuple: *kern.SockTuple, tuple_size: u32, netns: u64, flags: u64) ?*kern.Sock, 84);
pub const sk_lookup_udp = @intToPtr(*const fn (ctx: ?*anyopaque, tuple: *kern.SockTuple, tuple_size: u32, netns: u64, flags: u64) ?*kern.Sock, 85);
pub const sk_release = @intToPtr(*const fn (sock: *kern.Sock) c_long, 86);
pub const map_push_elem = @intToPtr(*const fn (map: *const kern.MapDef, value: ?*const anyopaque, flags: u64) c_long, 87);
pub const map_pop_elem = @intToPtr(*const fn (map: *const kern.MapDef, value: ?*anyopaque) c_long, 88);
pub const map_peek_elem = @intToPtr(*const fn (map: *const kern.MapDef, value: ?*anyopaque) c_long, 89);
pub const msg_push_data = @intToPtr(*const fn (msg: *kern.SkMsgMd, start: u32, len: u32, flags: u64) c_long, 90);
pub const msg_pop_data = @intToPtr(*const fn (msg: *kern.SkMsgMd, start: u32, len: u32, flags: u64) c_long, 91);
pub const rc_pointer_rel = @intToPtr(*const fn (ctx: ?*anyopaque, rel_x: i32, rel_y: i32) c_long, 92);
pub const spin_lock = @intToPtr(*const fn (lock: *kern.SpinLock) c_long, 93);
pub const spin_unlock = @intToPtr(*const fn (lock: *kern.SpinLock) c_long, 94);
pub const sk_fullsock = @intToPtr(*const fn (sk: *kern.Sock) ?*SkFullSock, 95);
pub const tcp_sock = @intToPtr(*const fn (sk: *kern.Sock) ?*kern.TcpSock, 96);
pub const skb_ecn_set_ce = @intToPtr(*const fn (skb: *kern.SkBuff) c_long, 97);
pub const get_listener_sock = @intToPtr(*const fn (sk: *kern.Sock) ?*kern.Sock, 98);
pub const skc_lookup_tcp = @intToPtr(*const fn (ctx: ?*anyopaque, tuple: *kern.SockTuple, tuple_size: u32, netns: u64, flags: u64) ?*kern.Sock, 99);
pub const tcp_check_syncookie = @intToPtr(*const fn (sk: *kern.Sock, iph: ?*anyopaque, iph_len: u32, th: *TcpHdr, th_len: u32) c_long, 100);
pub const sysctl_get_name = @intToPtr(*const fn (ctx: *kern.SysCtl, buf: ?*u8, buf_len: c_ulong, flags: u64) c_long, 101);
pub const sysctl_get_current_value = @intToPtr(*const fn (ctx: *kern.SysCtl, buf: ?*u8, buf_len: c_ulong) c_long, 102);
pub const sysctl_get_new_value = @intToPtr(*const fn (ctx: *kern.SysCtl, buf: ?*u8, buf_len: c_ulong) c_long, 103);
pub const sysctl_set_new_value = @intToPtr(*const fn (ctx: *kern.SysCtl, buf: ?*const u8, buf_len: c_ulong) c_long, 104);
pub const strtol = @intToPtr(*const fn (buf: *const u8, buf_len: c_ulong, flags: u64, res: *c_long) c_long, 105);
pub const strtoul = @intToPtr(*const fn (buf: *const u8, buf_len: c_ulong, flags: u64, res: *c_ulong) c_long, 106);
pub const sk_storage_get = @intToPtr(*const fn (map: *const kern.MapDef, sk: *kern.Sock, value: ?*anyopaque, flags: u64) ?*anyopaque, 107);
pub const sk_storage_delete = @intToPtr(*const fn (map: *const kern.MapDef, sk: *kern.Sock) c_long, 108);
pub const send_signal = @intToPtr(*const fn (sig: u32) c_long, 109);
pub const tcp_gen_syncookie = @intToPtr(*const fn (sk: *kern.Sock, iph: ?*anyopaque, iph_len: u32, th: *TcpHdr, th_len: u32) i64, 110);
pub const skb_output = @intToPtr(*const fn (ctx: ?*anyopaque, map: *const kern.MapDef, flags: u64, data: ?*anyopaque, size: u64) c_long, 111);
pub const probe_read_user = @intToPtr(*const fn (dst: ?*anyopaque, size: u32, unsafe_ptr: ?*const anyopaque) c_long, 112);
pub const probe_read_kernel = @intToPtr(*const fn (dst: ?*anyopaque, size: u32, unsafe_ptr: ?*const anyopaque) c_long, 113);
pub const probe_read_user_str = @intToPtr(*const fn (dst: ?*anyopaque, size: u32, unsafe_ptr: ?*const anyopaque) c_long, 114);
pub const probe_read_kernel_str = @intToPtr(*const fn (dst: ?*anyopaque, size: u32, unsafe_ptr: ?*const anyopaque) c_long, 115);
pub const tcp_send_ack = @intToPtr(*const fn (tp: ?*anyopaque, rcv_nxt: u32) c_long, 116);
pub const send_signal_thread = @intToPtr(*const fn (sig: u32) c_long, 117);
pub const jiffies64 = @intToPtr(*const fn () u64, 118);
pub const read_branch_records = @intToPtr(*const fn (ctx: *kern.PerfEventData, buf: ?*anyopaque, size: u32, flags: u64) c_long, 119);
pub const get_ns_current_pid_tgid = @intToPtr(*const fn (dev: u64, ino: u64, nsdata: *kern.PidNsInfo, size: u32) c_long, 120);
pub const xdp_output = @intToPtr(*const fn (ctx: ?*anyopaque, map: *const kern.MapDef, flags: u64, data: ?*anyopaque, size: u64) c_long, 121);
pub const get_netns_cookie = @intToPtr(*const fn (ctx: ?*anyopaque) u64, 122);
pub const get_current_ancestor_cgroup_id = @intToPtr(*const fn (ancestor_level: c_int) u64, 123);
pub const sk_assign = @intToPtr(*const fn (skb: *kern.SkBuff, sk: *kern.Sock, flags: u64) c_long, 124);
pub const ktime_get_boot_ns = @intToPtr(*const fn () u64, 125);
pub const seq_printf = @intToPtr(*const fn (m: *kern.SeqFile, fmt: ?*const u8, fmt_size: u32, data: ?*const anyopaque, data_len: u32) c_long, 126);
pub const seq_write = @intToPtr(*const fn (m: *kern.SeqFile, data: ?*const u8, len: u32) c_long, 127);
pub const sk_cgroup_id = @intToPtr(*const fn (sk: *kern.BpfSock) u64, 128);
pub const sk_ancestor_cgroup_id = @intToPtr(*const fn (sk: *kern.BpfSock, ancestor_level: c_long) u64, 129);
pub const ringbuf_output = @intToPtr(*const fn (ringbuf: ?*anyopaque, data: ?*anyopaque, size: u64, flags: u64) ?*anyopaque, 130);
pub const ringbuf_reserve = @intToPtr(*const fn (ringbuf: ?*anyopaque, size: u64, flags: u64) ?*anyopaque, 131);
pub const ringbuf_submit = @intToPtr(*const fn (data: ?*anyopaque, flags: u64) void, 132);
pub const ringbuf_discard = @intToPtr(*const fn (data: ?*anyopaque, flags: u64) void, 133);
pub const ringbuf_query = @intToPtr(*const fn (ringbuf: ?*anyopaque, flags: u64) u64, 134);
pub const csum_level = @intToPtr(*const fn (skb: *kern.SkBuff, level: u64) c_long, 135);
pub const skc_to_tcp6_sock = @intToPtr(*const fn (sk: ?*anyopaque) ?*kern.Tcp6Sock, 136);
pub const skc_to_tcp_sock = @intToPtr(*const fn (sk: ?*anyopaque) ?*kern.TcpSock, 137);
pub const skc_to_tcp_timewait_sock = @intToPtr(*const fn (sk: ?*anyopaque) ?*kern.TcpTimewaitSock, 138);
pub const skc_to_tcp_request_sock = @intToPtr(*const fn (sk: ?*anyopaque) ?*kern.TcpRequestSock, 139);
pub const skc_to_udp6_sock = @intToPtr(*const fn (sk: ?*anyopaque) ?*kern.Udp6Sock, 140);
pub const get_task_stack = @intToPtr(*const fn (task: ?*anyopaque, buf: ?*anyopaque, size: u32, flags: u64) c_long, 141);
