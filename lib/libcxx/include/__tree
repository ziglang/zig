// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP___TREE
#define _LIBCPP___TREE

#include <__algorithm/min.h>
#include <__assert>
#include <__config>
#include <__fwd/map.h>
#include <__fwd/pair.h>
#include <__fwd/set.h>
#include <__iterator/distance.h>
#include <__iterator/iterator_traits.h>
#include <__iterator/next.h>
#include <__memory/addressof.h>
#include <__memory/allocator_traits.h>
#include <__memory/compressed_pair.h>
#include <__memory/pointer_traits.h>
#include <__memory/swap_allocator.h>
#include <__memory/unique_ptr.h>
#include <__type_traits/can_extract_key.h>
#include <__type_traits/copy_cvref.h>
#include <__type_traits/enable_if.h>
#include <__type_traits/invoke.h>
#include <__type_traits/is_const.h>
#include <__type_traits/is_constructible.h>
#include <__type_traits/is_nothrow_assignable.h>
#include <__type_traits/is_nothrow_constructible.h>
#include <__type_traits/is_same.h>
#include <__type_traits/is_swappable.h>
#include <__type_traits/remove_const.h>
#include <__type_traits/remove_const_ref.h>
#include <__type_traits/remove_cvref.h>
#include <__utility/forward.h>
#include <__utility/move.h>
#include <__utility/pair.h>
#include <__utility/swap.h>
#include <limits>

#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
#  pragma GCC system_header
#endif

_LIBCPP_PUSH_MACROS
#include <__undef_macros>

_LIBCPP_BEGIN_NAMESPACE_STD

template <class _Tp, class _Compare, class _Allocator>
class __tree;
template <class _Tp, class _NodePtr, class _DiffType>
class __tree_iterator;
template <class _Tp, class _ConstNodePtr, class _DiffType>
class __tree_const_iterator;

template <class _Pointer>
class __tree_end_node;
template <class _VoidPtr>
class __tree_node_base;
template <class _Tp, class _VoidPtr>
class __tree_node;

template <class _Key, class _Value>
struct __value_type;

template <class _Allocator>
class __map_node_destructor;
template <class _TreeIterator>
class __map_iterator;
template <class _TreeIterator>
class __map_const_iterator;

/*

_NodePtr algorithms

The algorithms taking _NodePtr are red black tree algorithms.  Those
algorithms taking a parameter named __root should assume that __root
points to a proper red black tree (unless otherwise specified).

Each algorithm herein assumes that __root->__parent_ points to a non-null
structure which has a member __left_ which points back to __root.  No other
member is read or written to at __root->__parent_.

__root->__parent_ will be referred to below (in comments only) as end_node.
end_node->__left_ is an externably accessible lvalue for __root, and can be
changed by node insertion and removal (without explicit reference to end_node).

All nodes (with the exception of end_node), even the node referred to as
__root, have a non-null __parent_ field.

*/

// Returns:  true if __x is a left child of its parent, else false
// Precondition:  __x != nullptr.
template <class _NodePtr>
inline _LIBCPP_HIDE_FROM_ABI bool __tree_is_left_child(_NodePtr __x) _NOEXCEPT {
  return __x == __x->__parent_->__left_;
}

// Determines if the subtree rooted at __x is a proper red black subtree.  If
//    __x is a proper subtree, returns the black height (null counts as 1).  If
//    __x is an improper subtree, returns 0.
template <class _NodePtr>
unsigned __tree_sub_invariant(_NodePtr __x) {
  if (__x == nullptr)
    return 1;
  // parent consistency checked by caller
  // check __x->__left_ consistency
  if (__x->__left_ != nullptr && __x->__left_->__parent_ != __x)
    return 0;
  // check __x->__right_ consistency
  if (__x->__right_ != nullptr && __x->__right_->__parent_ != __x)
    return 0;
  // check __x->__left_ != __x->__right_ unless both are nullptr
  if (__x->__left_ == __x->__right_ && __x->__left_ != nullptr)
    return 0;
  // If this is red, neither child can be red
  if (!__x->__is_black_) {
    if (__x->__left_ && !__x->__left_->__is_black_)
      return 0;
    if (__x->__right_ && !__x->__right_->__is_black_)
      return 0;
  }
  unsigned __h = std::__tree_sub_invariant(__x->__left_);
  if (__h == 0)
    return 0; // invalid left subtree
  if (__h != std::__tree_sub_invariant(__x->__right_))
    return 0;                    // invalid or different height right subtree
  return __h + __x->__is_black_; // return black height of this node
}

// Determines if the red black tree rooted at __root is a proper red black tree.
//    __root == nullptr is a proper tree.  Returns true if __root is a proper
//    red black tree, else returns false.
template <class _NodePtr>
_LIBCPP_HIDE_FROM_ABI bool __tree_invariant(_NodePtr __root) {
  if (__root == nullptr)
    return true;
  // check __x->__parent_ consistency
  if (__root->__parent_ == nullptr)
    return false;
  if (!std::__tree_is_left_child(__root))
    return false;
  // root must be black
  if (!__root->__is_black_)
    return false;
  // do normal node checks
  return std::__tree_sub_invariant(__root) != 0;
}

// Returns:  pointer to the left-most node under __x.
template <class _NodePtr>
inline _LIBCPP_HIDE_FROM_ABI _NodePtr __tree_min(_NodePtr __x) _NOEXCEPT {
  _LIBCPP_ASSERT_INTERNAL(__x != nullptr, "Root node shouldn't be null");
  while (__x->__left_ != nullptr)
    __x = __x->__left_;
  return __x;
}

// Returns:  pointer to the right-most node under __x.
template <class _NodePtr>
inline _LIBCPP_HIDE_FROM_ABI _NodePtr __tree_max(_NodePtr __x) _NOEXCEPT {
  _LIBCPP_ASSERT_INTERNAL(__x != nullptr, "Root node shouldn't be null");
  while (__x->__right_ != nullptr)
    __x = __x->__right_;
  return __x;
}

// Returns:  pointer to the next in-order node after __x.
template <class _NodePtr>
_LIBCPP_HIDE_FROM_ABI _NodePtr __tree_next(_NodePtr __x) _NOEXCEPT {
  _LIBCPP_ASSERT_INTERNAL(__x != nullptr, "node shouldn't be null");
  if (__x->__right_ != nullptr)
    return std::__tree_min(__x->__right_);
  while (!std::__tree_is_left_child(__x))
    __x = __x->__parent_unsafe();
  return __x->__parent_unsafe();
}

template <class _EndNodePtr, class _NodePtr>
inline _LIBCPP_HIDE_FROM_ABI _EndNodePtr __tree_next_iter(_NodePtr __x) _NOEXCEPT {
  _LIBCPP_ASSERT_INTERNAL(__x != nullptr, "node shouldn't be null");
  if (__x->__right_ != nullptr)
    return static_cast<_EndNodePtr>(std::__tree_min(__x->__right_));
  while (!std::__tree_is_left_child(__x))
    __x = __x->__parent_unsafe();
  return static_cast<_EndNodePtr>(__x->__parent_);
}

// Returns:  pointer to the previous in-order node before __x.
// Note: __x may be the end node.
template <class _NodePtr, class _EndNodePtr>
inline _LIBCPP_HIDE_FROM_ABI _NodePtr __tree_prev_iter(_EndNodePtr __x) _NOEXCEPT {
  _LIBCPP_ASSERT_INTERNAL(__x != nullptr, "node shouldn't be null");
  if (__x->__left_ != nullptr)
    return std::__tree_max(__x->__left_);
  _NodePtr __xx = static_cast<_NodePtr>(__x);
  while (std::__tree_is_left_child(__xx))
    __xx = __xx->__parent_unsafe();
  return __xx->__parent_unsafe();
}

// Returns:  pointer to a node which has no children
template <class _NodePtr>
_LIBCPP_HIDE_FROM_ABI _NodePtr __tree_leaf(_NodePtr __x) _NOEXCEPT {
  _LIBCPP_ASSERT_INTERNAL(__x != nullptr, "node shouldn't be null");
  while (true) {
    if (__x->__left_ != nullptr) {
      __x = __x->__left_;
      continue;
    }
    if (__x->__right_ != nullptr) {
      __x = __x->__right_;
      continue;
    }
    break;
  }
  return __x;
}

// Effects:  Makes __x->__right_ the subtree root with __x as its left child
//           while preserving in-order order.
template <class _NodePtr>
_LIBCPP_HIDE_FROM_ABI void __tree_left_rotate(_NodePtr __x) _NOEXCEPT {
  _LIBCPP_ASSERT_INTERNAL(__x != nullptr, "node shouldn't be null");
  _LIBCPP_ASSERT_INTERNAL(__x->__right_ != nullptr, "node should have a right child");
  _NodePtr __y  = __x->__right_;
  __x->__right_ = __y->__left_;
  if (__x->__right_ != nullptr)
    __x->__right_->__set_parent(__x);
  __y->__parent_ = __x->__parent_;
  if (std::__tree_is_left_child(__x))
    __x->__parent_->__left_ = __y;
  else
    __x->__parent_unsafe()->__right_ = __y;
  __y->__left_ = __x;
  __x->__set_parent(__y);
}

// Effects:  Makes __x->__left_ the subtree root with __x as its right child
//           while preserving in-order order.
template <class _NodePtr>
_LIBCPP_HIDE_FROM_ABI void __tree_right_rotate(_NodePtr __x) _NOEXCEPT {
  _LIBCPP_ASSERT_INTERNAL(__x != nullptr, "node shouldn't be null");
  _LIBCPP_ASSERT_INTERNAL(__x->__left_ != nullptr, "node should have a left child");
  _NodePtr __y = __x->__left_;
  __x->__left_ = __y->__right_;
  if (__x->__left_ != nullptr)
    __x->__left_->__set_parent(__x);
  __y->__parent_ = __x->__parent_;
  if (std::__tree_is_left_child(__x))
    __x->__parent_->__left_ = __y;
  else
    __x->__parent_unsafe()->__right_ = __y;
  __y->__right_ = __x;
  __x->__set_parent(__y);
}

// Effects:  Rebalances __root after attaching __x to a leaf.
// Precondition:  __x has no children.
//                __x == __root or == a direct or indirect child of __root.
//                If __x were to be unlinked from __root (setting __root to
//                  nullptr if __root == __x), __tree_invariant(__root) == true.
// Postcondition: __tree_invariant(end_node->__left_) == true.  end_node->__left_
//                may be different than the value passed in as __root.
template <class _NodePtr>
_LIBCPP_HIDE_FROM_ABI void __tree_balance_after_insert(_NodePtr __root, _NodePtr __x) _NOEXCEPT {
  _LIBCPP_ASSERT_INTERNAL(__root != nullptr, "Root of the tree shouldn't be null");
  _LIBCPP_ASSERT_INTERNAL(__x != nullptr, "Can't attach null node to a leaf");
  __x->__is_black_ = __x == __root;
  while (__x != __root && !__x->__parent_unsafe()->__is_black_) {
    // __x->__parent_ != __root because __x->__parent_->__is_black == false
    if (std::__tree_is_left_child(__x->__parent_unsafe())) {
      _NodePtr __y = __x->__parent_unsafe()->__parent_unsafe()->__right_;
      if (__y != nullptr && !__y->__is_black_) {
        __x              = __x->__parent_unsafe();
        __x->__is_black_ = true;
        __x              = __x->__parent_unsafe();
        __x->__is_black_ = __x == __root;
        __y->__is_black_ = true;
      } else {
        if (!std::__tree_is_left_child(__x)) {
          __x = __x->__parent_unsafe();
          std::__tree_left_rotate(__x);
        }
        __x              = __x->__parent_unsafe();
        __x->__is_black_ = true;
        __x              = __x->__parent_unsafe();
        __x->__is_black_ = false;
        std::__tree_right_rotate(__x);
        break;
      }
    } else {
      _NodePtr __y = __x->__parent_unsafe()->__parent_->__left_;
      if (__y != nullptr && !__y->__is_black_) {
        __x              = __x->__parent_unsafe();
        __x->__is_black_ = true;
        __x              = __x->__parent_unsafe();
        __x->__is_black_ = __x == __root;
        __y->__is_black_ = true;
      } else {
        if (std::__tree_is_left_child(__x)) {
          __x = __x->__parent_unsafe();
          std::__tree_right_rotate(__x);
        }
        __x              = __x->__parent_unsafe();
        __x->__is_black_ = true;
        __x              = __x->__parent_unsafe();
        __x->__is_black_ = false;
        std::__tree_left_rotate(__x);
        break;
      }
    }
  }
}

// Precondition:  __z == __root or == a direct or indirect child of __root.
// Effects:  unlinks __z from the tree rooted at __root, rebalancing as needed.
// Postcondition: __tree_invariant(end_node->__left_) == true && end_node->__left_
//                nor any of its children refer to __z.  end_node->__left_
//                may be different than the value passed in as __root.
template <class _NodePtr>
_LIBCPP_HIDE_FROM_ABI void __tree_remove(_NodePtr __root, _NodePtr __z) _NOEXCEPT {
  _LIBCPP_ASSERT_INTERNAL(__root != nullptr, "Root node should not be null");
  _LIBCPP_ASSERT_INTERNAL(__z != nullptr, "The node to remove should not be null");
  _LIBCPP_ASSERT_INTERNAL(std::__tree_invariant(__root), "The tree invariants should hold");
  // __z will be removed from the tree.  Client still needs to destruct/deallocate it
  // __y is either __z, or if __z has two children, __tree_next(__z).
  // __y will have at most one child.
  // __y will be the initial hole in the tree (make the hole at a leaf)
  _NodePtr __y = (__z->__left_ == nullptr || __z->__right_ == nullptr) ? __z : std::__tree_next(__z);
  // __x is __y's possibly null single child
  _NodePtr __x = __y->__left_ != nullptr ? __y->__left_ : __y->__right_;
  // __w is __x's possibly null uncle (will become __x's sibling)
  _NodePtr __w = nullptr;
  // link __x to __y's parent, and find __w
  if (__x != nullptr)
    __x->__parent_ = __y->__parent_;
  if (std::__tree_is_left_child(__y)) {
    __y->__parent_->__left_ = __x;
    if (__y != __root)
      __w = __y->__parent_unsafe()->__right_;
    else
      __root = __x; // __w == nullptr
  } else {
    __y->__parent_unsafe()->__right_ = __x;
    // __y can't be root if it is a right child
    __w = __y->__parent_->__left_;
  }
  bool __removed_black = __y->__is_black_;
  // If we didn't remove __z, do so now by splicing in __y for __z,
  //    but copy __z's color.  This does not impact __x or __w.
  if (__y != __z) {
    // __z->__left_ != nulptr but __z->__right_ might == __x == nullptr
    __y->__parent_ = __z->__parent_;
    if (std::__tree_is_left_child(__z))
      __y->__parent_->__left_ = __y;
    else
      __y->__parent_unsafe()->__right_ = __y;
    __y->__left_ = __z->__left_;
    __y->__left_->__set_parent(__y);
    __y->__right_ = __z->__right_;
    if (__y->__right_ != nullptr)
      __y->__right_->__set_parent(__y);
    __y->__is_black_ = __z->__is_black_;
    if (__root == __z)
      __root = __y;
  }
  // There is no need to rebalance if we removed a red, or if we removed
  //     the last node.
  if (__removed_black && __root != nullptr) {
    // Rebalance:
    // __x has an implicit black color (transferred from the removed __y)
    //    associated with it, no matter what its color is.
    // If __x is __root (in which case it can't be null), it is supposed
    //    to be black anyway, and if it is doubly black, then the double
    //    can just be ignored.
    // If __x is red (in which case it can't be null), then it can absorb
    //    the implicit black just by setting its color to black.
    // Since __y was black and only had one child (which __x points to), __x
    //   is either red with no children, else null, otherwise __y would have
    //   different black heights under left and right pointers.
    // if (__x == __root || __x != nullptr && !__x->__is_black_)
    if (__x != nullptr)
      __x->__is_black_ = true;
    else {
      //  Else __x isn't root, and is "doubly black", even though it may
      //     be null.  __w can not be null here, else the parent would
      //     see a black height >= 2 on the __x side and a black height
      //     of 1 on the __w side (__w must be a non-null black or a red
      //     with a non-null black child).
      while (true) {
        if (!std::__tree_is_left_child(__w)) // if x is left child
        {
          if (!__w->__is_black_) {
            __w->__is_black_                    = true;
            __w->__parent_unsafe()->__is_black_ = false;
            std::__tree_left_rotate(__w->__parent_unsafe());
            // __x is still valid
            // reset __root only if necessary
            if (__root == __w->__left_)
              __root = __w;
            // reset sibling, and it still can't be null
            __w = __w->__left_->__right_;
          }
          // __w->__is_black_ is now true, __w may have null children
          if ((__w->__left_ == nullptr || __w->__left_->__is_black_) &&
              (__w->__right_ == nullptr || __w->__right_->__is_black_)) {
            __w->__is_black_ = false;
            __x              = __w->__parent_unsafe();
            // __x can no longer be null
            if (__x == __root || !__x->__is_black_) {
              __x->__is_black_ = true;
              break;
            }
            // reset sibling, and it still can't be null
            __w = std::__tree_is_left_child(__x) ? __x->__parent_unsafe()->__right_ : __x->__parent_->__left_;
            // continue;
          } else // __w has a red child
          {
            if (__w->__right_ == nullptr || __w->__right_->__is_black_) {
              // __w left child is non-null and red
              __w->__left_->__is_black_ = true;
              __w->__is_black_          = false;
              std::__tree_right_rotate(__w);
              // __w is known not to be root, so root hasn't changed
              // reset sibling, and it still can't be null
              __w = __w->__parent_unsafe();
            }
            // __w has a right red child, left child may be null
            __w->__is_black_                    = __w->__parent_unsafe()->__is_black_;
            __w->__parent_unsafe()->__is_black_ = true;
            __w->__right_->__is_black_          = true;
            std::__tree_left_rotate(__w->__parent_unsafe());
            break;
          }
        } else {
          if (!__w->__is_black_) {
            __w->__is_black_                    = true;
            __w->__parent_unsafe()->__is_black_ = false;
            std::__tree_right_rotate(__w->__parent_unsafe());
            // __x is still valid
            // reset __root only if necessary
            if (__root == __w->__right_)
              __root = __w;
            // reset sibling, and it still can't be null
            __w = __w->__right_->__left_;
          }
          // __w->__is_black_ is now true, __w may have null children
          if ((__w->__left_ == nullptr || __w->__left_->__is_black_) &&
              (__w->__right_ == nullptr || __w->__right_->__is_black_)) {
            __w->__is_black_ = false;
            __x              = __w->__parent_unsafe();
            // __x can no longer be null
            if (!__x->__is_black_ || __x == __root) {
              __x->__is_black_ = true;
              break;
            }
            // reset sibling, and it still can't be null
            __w = std::__tree_is_left_child(__x) ? __x->__parent_unsafe()->__right_ : __x->__parent_->__left_;
            // continue;
          } else // __w has a red child
          {
            if (__w->__left_ == nullptr || __w->__left_->__is_black_) {
              // __w right child is non-null and red
              __w->__right_->__is_black_ = true;
              __w->__is_black_           = false;
              std::__tree_left_rotate(__w);
              // __w is known not to be root, so root hasn't changed
              // reset sibling, and it still can't be null
              __w = __w->__parent_unsafe();
            }
            // __w has a left red child, right child may be null
            __w->__is_black_                    = __w->__parent_unsafe()->__is_black_;
            __w->__parent_unsafe()->__is_black_ = true;
            __w->__left_->__is_black_           = true;
            std::__tree_right_rotate(__w->__parent_unsafe());
            break;
          }
        }
      }
    }
  }
}

// node traits

template <class _Tp>
struct __is_tree_value_type_imp : false_type {};

template <class _Key, class _Value>
struct __is_tree_value_type_imp<__value_type<_Key, _Value> > : true_type {};

template <class... _Args>
struct __is_tree_value_type : false_type {};

template <class _One>
struct __is_tree_value_type<_One> : __is_tree_value_type_imp<__remove_cvref_t<_One> > {};

template <class _Tp>
struct __get_tree_key_type {
  using type _LIBCPP_NODEBUG = _Tp;
};

template <class _Key, class _ValueT>
struct __get_tree_key_type<__value_type<_Key, _ValueT> > {
  using type _LIBCPP_NODEBUG = _Key;
};

template <class _Tp>
using __get_tree_key_type_t _LIBCPP_NODEBUG = typename __get_tree_key_type<_Tp>::type;

template <class _Tp>
struct __get_node_value_type {
  using type _LIBCPP_NODEBUG = _Tp;
};

template <class _Key, class _ValueT>
struct __get_node_value_type<__value_type<_Key, _ValueT> > {
  using type _LIBCPP_NODEBUG = pair<const _Key, _ValueT>;
};

template <class _Tp>
using __get_node_value_type_t _LIBCPP_NODEBUG = typename __get_node_value_type<_Tp>::type;

template <class _NodePtr, class _NodeT = typename pointer_traits<_NodePtr>::element_type>
struct __tree_node_types;

template <class _NodePtr, class _Tp, class _VoidPtr>
struct __tree_node_types<_NodePtr, __tree_node<_Tp, _VoidPtr> > {
  using __node_base_pointer _LIBCPP_NODEBUG = __rebind_pointer_t<_VoidPtr, __tree_node_base<_VoidPtr> >;
  using __end_node_pointer _LIBCPP_NODEBUG  = __rebind_pointer_t<_VoidPtr, __tree_end_node<__node_base_pointer> >;

private:
  static_assert(is_same<typename pointer_traits<_VoidPtr>::element_type, void>::value,
                "_VoidPtr does not point to unqualified void type");
};

// node

template <class _Pointer>
class __tree_end_node {
public:
  typedef _Pointer pointer;
  pointer __left_;

  _LIBCPP_HIDE_FROM_ABI __tree_end_node() _NOEXCEPT : __left_() {}
};

template <class _VoidPtr>
class _LIBCPP_STANDALONE_DEBUG
__tree_node_base : public __tree_end_node<__rebind_pointer_t<_VoidPtr, __tree_node_base<_VoidPtr> > > {
public:
  using pointer                            = __rebind_pointer_t<_VoidPtr, __tree_node_base>;
  using __end_node_pointer _LIBCPP_NODEBUG = __rebind_pointer_t<_VoidPtr, __tree_end_node<pointer> >;

  pointer __right_;
  __end_node_pointer __parent_;
  bool __is_black_;

  _LIBCPP_HIDE_FROM_ABI pointer __parent_unsafe() const { return static_cast<pointer>(__parent_); }

  _LIBCPP_HIDE_FROM_ABI void __set_parent(pointer __p) { __parent_ = static_cast<__end_node_pointer>(__p); }

  ~__tree_node_base()                                  = delete;
  __tree_node_base(__tree_node_base const&)            = delete;
  __tree_node_base& operator=(__tree_node_base const&) = delete;
};

template <class _Tp, class _VoidPtr>
class _LIBCPP_STANDALONE_DEBUG __tree_node : public __tree_node_base<_VoidPtr> {
public:
  using __node_value_type _LIBCPP_NODEBUG = __get_node_value_type_t<_Tp>;

  __node_value_type __value_;

  _LIBCPP_HIDE_FROM_ABI __node_value_type& __get_value() { return __value_; }

  ~__tree_node()                             = delete;
  __tree_node(__tree_node const&)            = delete;
  __tree_node& operator=(__tree_node const&) = delete;
};

template <class _Allocator>
class __tree_node_destructor {
  typedef _Allocator allocator_type;
  typedef allocator_traits<allocator_type> __alloc_traits;

public:
  typedef typename __alloc_traits::pointer pointer;

private:
  allocator_type& __na_;

public:
  bool __value_constructed;

  _LIBCPP_HIDE_FROM_ABI __tree_node_destructor(const __tree_node_destructor&) = default;
  __tree_node_destructor& operator=(const __tree_node_destructor&)            = delete;

  _LIBCPP_HIDE_FROM_ABI explicit __tree_node_destructor(allocator_type& __na, bool __val = false) _NOEXCEPT
      : __na_(__na),
        __value_constructed(__val) {}

  _LIBCPP_HIDE_FROM_ABI void operator()(pointer __p) _NOEXCEPT {
    if (__value_constructed)
      __alloc_traits::destroy(__na_, std::addressof(__p->__value_));
    if (__p)
      __alloc_traits::deallocate(__na_, __p, 1);
  }

  template <class>
  friend class __map_node_destructor;
};

#if _LIBCPP_STD_VER >= 17
template <class _NodeType, class _Alloc>
struct __generic_container_node_destructor;
template <class _Tp, class _VoidPtr, class _Alloc>
struct __generic_container_node_destructor<__tree_node<_Tp, _VoidPtr>, _Alloc> : __tree_node_destructor<_Alloc> {
  using __tree_node_destructor<_Alloc>::__tree_node_destructor;
};
#endif

template <class _Tp, class _NodePtr, class _DiffType>
class __tree_iterator {
  typedef __tree_node_types<_NodePtr> _NodeTypes;
  typedef _NodePtr __node_pointer;
  typedef typename _NodeTypes::__node_base_pointer __node_base_pointer;
  typedef typename _NodeTypes::__end_node_pointer __end_node_pointer;

  __end_node_pointer __ptr_;

public:
  using iterator_category = bidirectional_iterator_tag;
  using value_type        = __get_node_value_type_t<_Tp>;
  using difference_type   = _DiffType;
  using reference         = value_type&;
  using pointer           = __rebind_pointer_t<_NodePtr, value_type>;

  _LIBCPP_HIDE_FROM_ABI __tree_iterator() _NOEXCEPT
#if _LIBCPP_STD_VER >= 14
      : __ptr_(nullptr)
#endif
  {
  }

  _LIBCPP_HIDE_FROM_ABI reference operator*() const { return __get_np()->__value_; }
  _LIBCPP_HIDE_FROM_ABI pointer operator->() const { return pointer_traits<pointer>::pointer_to(__get_np()->__value_); }

  _LIBCPP_HIDE_FROM_ABI __tree_iterator& operator++() {
    __ptr_ = std::__tree_next_iter<__end_node_pointer>(static_cast<__node_base_pointer>(__ptr_));
    return *this;
  }
  _LIBCPP_HIDE_FROM_ABI __tree_iterator operator++(int) {
    __tree_iterator __t(*this);
    ++(*this);
    return __t;
  }

  _LIBCPP_HIDE_FROM_ABI __tree_iterator& operator--() {
    __ptr_ = static_cast<__end_node_pointer>(std::__tree_prev_iter<__node_base_pointer>(__ptr_));
    return *this;
  }
  _LIBCPP_HIDE_FROM_ABI __tree_iterator operator--(int) {
    __tree_iterator __t(*this);
    --(*this);
    return __t;
  }

  friend _LIBCPP_HIDE_FROM_ABI bool operator==(const __tree_iterator& __x, const __tree_iterator& __y) {
    return __x.__ptr_ == __y.__ptr_;
  }
  friend _LIBCPP_HIDE_FROM_ABI bool operator!=(const __tree_iterator& __x, const __tree_iterator& __y) {
    return !(__x == __y);
  }

private:
  _LIBCPP_HIDE_FROM_ABI explicit __tree_iterator(__node_pointer __p) _NOEXCEPT : __ptr_(__p) {}
  _LIBCPP_HIDE_FROM_ABI explicit __tree_iterator(__end_node_pointer __p) _NOEXCEPT : __ptr_(__p) {}
  _LIBCPP_HIDE_FROM_ABI __node_pointer __get_np() const { return static_cast<__node_pointer>(__ptr_); }
  template <class, class, class>
  friend class __tree;
  template <class, class, class>
  friend class __tree_const_iterator;
  template <class>
  friend class __map_iterator;
  template <class, class, class, class>
  friend class map;
  template <class, class, class, class>
  friend class multimap;
  template <class, class, class>
  friend class set;
  template <class, class, class>
  friend class multiset;
};

template <class _Tp, class _NodePtr, class _DiffType>
class __tree_const_iterator {
  typedef __tree_node_types<_NodePtr> _NodeTypes;
  // NOLINTNEXTLINE(libcpp-nodebug-on-aliases) lldb relies on this alias for pretty printing
  using __node_pointer = _NodePtr;
  typedef typename _NodeTypes::__node_base_pointer __node_base_pointer;
  typedef typename _NodeTypes::__end_node_pointer __end_node_pointer;

  __end_node_pointer __ptr_;

public:
  using iterator_category = bidirectional_iterator_tag;
  using value_type        = __get_node_value_type_t<_Tp>;
  using difference_type   = _DiffType;
  using reference         = const value_type&;
  using pointer           = __rebind_pointer_t<_NodePtr, const value_type>;

  _LIBCPP_HIDE_FROM_ABI __tree_const_iterator() _NOEXCEPT
#if _LIBCPP_STD_VER >= 14
      : __ptr_(nullptr)
#endif
  {
  }

private:
  typedef __tree_iterator<_Tp, __node_pointer, difference_type> __non_const_iterator;

public:
  _LIBCPP_HIDE_FROM_ABI __tree_const_iterator(__non_const_iterator __p) _NOEXCEPT : __ptr_(__p.__ptr_) {}

  _LIBCPP_HIDE_FROM_ABI reference operator*() const { return __get_np()->__value_; }
  _LIBCPP_HIDE_FROM_ABI pointer operator->() const { return pointer_traits<pointer>::pointer_to(__get_np()->__value_); }

  _LIBCPP_HIDE_FROM_ABI __tree_const_iterator& operator++() {
    __ptr_ = std::__tree_next_iter<__end_node_pointer>(static_cast<__node_base_pointer>(__ptr_));
    return *this;
  }

  _LIBCPP_HIDE_FROM_ABI __tree_const_iterator operator++(int) {
    __tree_const_iterator __t(*this);
    ++(*this);
    return __t;
  }

  _LIBCPP_HIDE_FROM_ABI __tree_const_iterator& operator--() {
    __ptr_ = static_cast<__end_node_pointer>(std::__tree_prev_iter<__node_base_pointer>(__ptr_));
    return *this;
  }

  _LIBCPP_HIDE_FROM_ABI __tree_const_iterator operator--(int) {
    __tree_const_iterator __t(*this);
    --(*this);
    return __t;
  }

  friend _LIBCPP_HIDE_FROM_ABI bool operator==(const __tree_const_iterator& __x, const __tree_const_iterator& __y) {
    return __x.__ptr_ == __y.__ptr_;
  }
  friend _LIBCPP_HIDE_FROM_ABI bool operator!=(const __tree_const_iterator& __x, const __tree_const_iterator& __y) {
    return !(__x == __y);
  }

private:
  _LIBCPP_HIDE_FROM_ABI explicit __tree_const_iterator(__node_pointer __p) _NOEXCEPT : __ptr_(__p) {}
  _LIBCPP_HIDE_FROM_ABI explicit __tree_const_iterator(__end_node_pointer __p) _NOEXCEPT : __ptr_(__p) {}
  _LIBCPP_HIDE_FROM_ABI __node_pointer __get_np() const { return static_cast<__node_pointer>(__ptr_); }

  template <class, class, class>
  friend class __tree;
  template <class, class, class, class>
  friend class map;
  template <class, class, class, class>
  friend class multimap;
  template <class, class, class>
  friend class set;
  template <class, class, class>
  friend class multiset;
  template <class>
  friend class __map_const_iterator;
};

template <class _Tp, class _Compare>
#ifndef _LIBCPP_CXX03_LANG
_LIBCPP_DIAGNOSE_WARNING(!__is_invocable_v<_Compare const&, _Tp const&, _Tp const&>,
                         "the specified comparator type does not provide a viable const call operator")
#endif
int __diagnose_non_const_comparator();

template <class _Tp, class _Compare, class _Allocator>
class __tree {
public:
  using value_type = __get_node_value_type_t<_Tp>;
  typedef _Compare value_compare;
  typedef _Allocator allocator_type;

private:
  typedef allocator_traits<allocator_type> __alloc_traits;
  using key_type = __get_tree_key_type_t<_Tp>;

public:
  typedef typename __alloc_traits::pointer pointer;
  typedef typename __alloc_traits::const_pointer const_pointer;
  typedef typename __alloc_traits::size_type size_type;
  typedef typename __alloc_traits::difference_type difference_type;

public:
  using __void_pointer _LIBCPP_NODEBUG = typename __alloc_traits::void_pointer;

  using __node _LIBCPP_NODEBUG = __tree_node<_Tp, __void_pointer>;
  // NOLINTNEXTLINE(libcpp-nodebug-on-aliases) lldb relies on this alias for pretty printing
  using __node_pointer = __rebind_pointer_t<__void_pointer, __node>;

  using __node_base _LIBCPP_NODEBUG         = __tree_node_base<__void_pointer>;
  using __node_base_pointer _LIBCPP_NODEBUG = __rebind_pointer_t<__void_pointer, __node_base>;

  using __end_node_t _LIBCPP_NODEBUG       = __tree_end_node<__node_base_pointer>;
  using __end_node_pointer _LIBCPP_NODEBUG = __rebind_pointer_t<__void_pointer, __end_node_t>;

  using __parent_pointer _LIBCPP_NODEBUG = __end_node_pointer; // TODO: Remove this once the uses in <map> are removed

  typedef __rebind_alloc<__alloc_traits, __node> __node_allocator;
  typedef allocator_traits<__node_allocator> __node_traits;

// TODO(LLVM 22): Remove this check
#ifndef _LIBCPP_ABI_TREE_REMOVE_NODE_POINTER_UB
  static_assert(sizeof(__node_base_pointer) == sizeof(__end_node_pointer) && _LIBCPP_ALIGNOF(__node_base_pointer) ==
                    _LIBCPP_ALIGNOF(__end_node_pointer),
                "It looks like you are using std::__tree (an implementation detail for (multi)map/set) with a fancy "
                "pointer type that thas a different representation depending on whether it points to a __tree base "
                "pointer or a __tree node pointer (both of which are implementation details of the standard library). "
                "This means that your ABI is being broken between LLVM 19 and LLVM 20. If you don't care about your "
                "ABI being broken, define the _LIBCPP_ABI_TREE_REMOVE_NODE_POINTER_UB macro to silence this "
                "diagnostic.");
#endif

private:
  // check for sane allocator pointer rebinding semantics. Rebinding the
  // allocator for a new pointer type should be exactly the same as rebinding
  // the pointer using 'pointer_traits'.
  static_assert(is_same<__node_pointer, typename __node_traits::pointer>::value,
                "Allocator does not rebind pointers in a sane manner.");
  typedef __rebind_alloc<__node_traits, __node_base> __node_base_allocator;
  typedef allocator_traits<__node_base_allocator> __node_base_traits;
  static_assert(is_same<__node_base_pointer, typename __node_base_traits::pointer>::value,
                "Allocator does not rebind pointers in a sane manner.");

private:
  __end_node_pointer __begin_node_;
  _LIBCPP_COMPRESSED_PAIR(__end_node_t, __end_node_, __node_allocator, __node_alloc_);
  _LIBCPP_COMPRESSED_PAIR(size_type, __size_, value_compare, __value_comp_);

public:
  _LIBCPP_HIDE_FROM_ABI __end_node_pointer __end_node() _NOEXCEPT {
    return pointer_traits<__end_node_pointer>::pointer_to(__end_node_);
  }
  _LIBCPP_HIDE_FROM_ABI __end_node_pointer __end_node() const _NOEXCEPT {
    return pointer_traits<__end_node_pointer>::pointer_to(const_cast<__end_node_t&>(__end_node_));
  }
  _LIBCPP_HIDE_FROM_ABI __node_allocator& __node_alloc() _NOEXCEPT { return __node_alloc_; }

private:
  _LIBCPP_HIDE_FROM_ABI const __node_allocator& __node_alloc() const _NOEXCEPT { return __node_alloc_; }
  _LIBCPP_HIDE_FROM_ABI __end_node_pointer& __begin_node() _NOEXCEPT { return __begin_node_; }
  _LIBCPP_HIDE_FROM_ABI const __end_node_pointer& __begin_node() const _NOEXCEPT { return __begin_node_; }

public:
  _LIBCPP_HIDE_FROM_ABI allocator_type __alloc() const _NOEXCEPT { return allocator_type(__node_alloc()); }

private:
  _LIBCPP_HIDE_FROM_ABI size_type& size() _NOEXCEPT { return __size_; }

public:
  _LIBCPP_HIDE_FROM_ABI const size_type& size() const _NOEXCEPT { return __size_; }
  _LIBCPP_HIDE_FROM_ABI value_compare& value_comp() _NOEXCEPT { return __value_comp_; }
  _LIBCPP_HIDE_FROM_ABI const value_compare& value_comp() const _NOEXCEPT { return __value_comp_; }

public:
  _LIBCPP_HIDE_FROM_ABI __node_pointer __root() const _NOEXCEPT {
    return static_cast<__node_pointer>(__end_node()->__left_);
  }

  _LIBCPP_HIDE_FROM_ABI __node_base_pointer* __root_ptr() const _NOEXCEPT {
    return std::addressof(__end_node()->__left_);
  }

  typedef __tree_iterator<_Tp, __node_pointer, difference_type> iterator;
  typedef __tree_const_iterator<_Tp, __node_pointer, difference_type> const_iterator;

  _LIBCPP_HIDE_FROM_ABI explicit __tree(const value_compare& __comp) _NOEXCEPT_(
      is_nothrow_default_constructible<__node_allocator>::value&& is_nothrow_copy_constructible<value_compare>::value);
  _LIBCPP_HIDE_FROM_ABI explicit __tree(const allocator_type& __a);
  _LIBCPP_HIDE_FROM_ABI __tree(const value_compare& __comp, const allocator_type& __a);
  _LIBCPP_HIDE_FROM_ABI __tree(const __tree& __t);
  _LIBCPP_HIDE_FROM_ABI __tree& operator=(const __tree& __t);
  template <class _ForwardIterator>
  _LIBCPP_HIDE_FROM_ABI void __assign_unique(_ForwardIterator __first, _ForwardIterator __last);
  template <class _InputIterator>
  _LIBCPP_HIDE_FROM_ABI void __assign_multi(_InputIterator __first, _InputIterator __last);
  _LIBCPP_HIDE_FROM_ABI __tree(__tree&& __t) _NOEXCEPT_(
      is_nothrow_move_constructible<__node_allocator>::value&& is_nothrow_move_constructible<value_compare>::value);
  _LIBCPP_HIDE_FROM_ABI __tree(__tree&& __t, const allocator_type& __a);
  _LIBCPP_HIDE_FROM_ABI __tree& operator=(__tree&& __t)
      _NOEXCEPT_(is_nothrow_move_assignable<value_compare>::value &&
                 ((__node_traits::propagate_on_container_move_assignment::value &&
                   is_nothrow_move_assignable<__node_allocator>::value) ||
                  allocator_traits<__node_allocator>::is_always_equal::value));

  _LIBCPP_HIDE_FROM_ABI ~__tree();

  _LIBCPP_HIDE_FROM_ABI iterator begin() _NOEXCEPT { return iterator(__begin_node()); }
  _LIBCPP_HIDE_FROM_ABI const_iterator begin() const _NOEXCEPT { return const_iterator(__begin_node()); }
  _LIBCPP_HIDE_FROM_ABI iterator end() _NOEXCEPT { return iterator(__end_node()); }
  _LIBCPP_HIDE_FROM_ABI const_iterator end() const _NOEXCEPT { return const_iterator(__end_node()); }

  _LIBCPP_HIDE_FROM_ABI size_type max_size() const _NOEXCEPT {
    return std::min<size_type>(__node_traits::max_size(__node_alloc()), numeric_limits<difference_type >::max());
  }

  _LIBCPP_HIDE_FROM_ABI void clear() _NOEXCEPT;

  _LIBCPP_HIDE_FROM_ABI void swap(__tree& __t)
#if _LIBCPP_STD_VER <= 11
      _NOEXCEPT_(__is_nothrow_swappable_v<value_compare> &&
                 (!__node_traits::propagate_on_container_swap::value || __is_nothrow_swappable_v<__node_allocator>));
#else
      _NOEXCEPT_(__is_nothrow_swappable_v<value_compare>);
#endif

  template <class _Key, class... _Args>
  _LIBCPP_HIDE_FROM_ABI pair<iterator, bool> __emplace_unique_key_args(_Key const&, _Args&&... __args);
  template <class _Key, class... _Args>
  _LIBCPP_HIDE_FROM_ABI pair<iterator, bool> __emplace_hint_unique_key_args(const_iterator, _Key const&, _Args&&...);

  template <class... _Args>
  _LIBCPP_HIDE_FROM_ABI pair<iterator, bool> __emplace_unique_impl(_Args&&... __args);

  template <class... _Args>
  _LIBCPP_HIDE_FROM_ABI iterator __emplace_hint_unique_impl(const_iterator __p, _Args&&... __args);

  template <class... _Args>
  _LIBCPP_HIDE_FROM_ABI iterator __emplace_multi(_Args&&... __args);

  template <class... _Args>
  _LIBCPP_HIDE_FROM_ABI iterator __emplace_hint_multi(const_iterator __p, _Args&&... __args);

  template <class _Pp>
  _LIBCPP_HIDE_FROM_ABI pair<iterator, bool> __emplace_unique(_Pp&& __x) {
    return __emplace_unique_extract_key(std::forward<_Pp>(__x), __can_extract_key<_Pp, key_type>());
  }

  template <class _First,
            class _Second,
            __enable_if_t<__can_extract_map_key<_First, key_type, value_type>::value, int> = 0>
  _LIBCPP_HIDE_FROM_ABI pair<iterator, bool> __emplace_unique(_First&& __f, _Second&& __s) {
    return __emplace_unique_key_args(__f, std::forward<_First>(__f), std::forward<_Second>(__s));
  }

  template <class... _Args>
  _LIBCPP_HIDE_FROM_ABI pair<iterator, bool> __emplace_unique(_Args&&... __args) {
    return __emplace_unique_impl(std::forward<_Args>(__args)...);
  }

  template <class _Pp>
  _LIBCPP_HIDE_FROM_ABI pair<iterator, bool> __emplace_unique_extract_key(_Pp&& __x, __extract_key_fail_tag) {
    return __emplace_unique_impl(std::forward<_Pp>(__x));
  }

  template <class _Pp>
  _LIBCPP_HIDE_FROM_ABI pair<iterator, bool> __emplace_unique_extract_key(_Pp&& __x, __extract_key_self_tag) {
    return __emplace_unique_key_args(__x, std::forward<_Pp>(__x));
  }

  template <class _Pp>
  _LIBCPP_HIDE_FROM_ABI pair<iterator, bool> __emplace_unique_extract_key(_Pp&& __x, __extract_key_first_tag) {
    return __emplace_unique_key_args(__x.first, std::forward<_Pp>(__x));
  }

  template <class _Pp>
  _LIBCPP_HIDE_FROM_ABI iterator __emplace_hint_unique(const_iterator __p, _Pp&& __x) {
    return __emplace_hint_unique_extract_key(__p, std::forward<_Pp>(__x), __can_extract_key<_Pp, key_type>());
  }

  template <class _First,
            class _Second,
            __enable_if_t<__can_extract_map_key<_First, key_type, value_type>::value, int> = 0>
  _LIBCPP_HIDE_FROM_ABI iterator __emplace_hint_unique(const_iterator __p, _First&& __f, _Second&& __s) {
    return __emplace_hint_unique_key_args(__p, __f, std::forward<_First>(__f), std::forward<_Second>(__s)).first;
  }

  template <class... _Args>
  _LIBCPP_HIDE_FROM_ABI iterator __emplace_hint_unique(const_iterator __p, _Args&&... __args) {
    return __emplace_hint_unique_impl(__p, std::forward<_Args>(__args)...);
  }

  template <class _Pp>
  _LIBCPP_HIDE_FROM_ABI iterator
  __emplace_hint_unique_extract_key(const_iterator __p, _Pp&& __x, __extract_key_fail_tag) {
    return __emplace_hint_unique_impl(__p, std::forward<_Pp>(__x));
  }

  template <class _Pp>
  _LIBCPP_HIDE_FROM_ABI iterator
  __emplace_hint_unique_extract_key(const_iterator __p, _Pp&& __x, __extract_key_self_tag) {
    return __emplace_hint_unique_key_args(__p, __x, std::forward<_Pp>(__x)).first;
  }

  template <class _Pp>
  _LIBCPP_HIDE_FROM_ABI iterator
  __emplace_hint_unique_extract_key(const_iterator __p, _Pp&& __x, __extract_key_first_tag) {
    return __emplace_hint_unique_key_args(__p, __x.first, std::forward<_Pp>(__x)).first;
  }

  template <class _ValueT = _Tp, __enable_if_t<__is_tree_value_type<_ValueT>::value, int> = 0>
  _LIBCPP_HIDE_FROM_ABI void
  __insert_unique_from_orphaned_node(const_iterator __p, __get_node_value_type_t<_Tp>&& __value) {
    __emplace_hint_unique(__p, const_cast<key_type&&>(__value.first), std::move(__value.second));
  }

  template <class _ValueT = _Tp, __enable_if_t<!__is_tree_value_type<_ValueT>::value, int> = 0>
  _LIBCPP_HIDE_FROM_ABI void __insert_unique_from_orphaned_node(const_iterator __p, _Tp&& __value) {
    __emplace_hint_unique(__p, std::move(__value));
  }

  template <class _ValueT = _Tp, __enable_if_t<__is_tree_value_type<_ValueT>::value, int> = 0>
  _LIBCPP_HIDE_FROM_ABI void __insert_multi_from_orphaned_node(const_iterator __p, value_type&& __value) {
    __emplace_hint_multi(__p, const_cast<key_type&&>(__value.first), std::move(__value.second));
  }

  template <class _ValueT = _Tp, __enable_if_t<!__is_tree_value_type<_ValueT>::value, int> = 0>
  _LIBCPP_HIDE_FROM_ABI void __insert_multi_from_orphaned_node(const_iterator __p, _Tp&& __value) {
    __emplace_hint_multi(__p, std::move(__value));
  }

  _LIBCPP_HIDE_FROM_ABI pair<iterator, bool> __node_assign_unique(const value_type& __v, __node_pointer __dest);

  _LIBCPP_HIDE_FROM_ABI iterator __node_insert_multi(__node_pointer __nd);
  _LIBCPP_HIDE_FROM_ABI iterator __node_insert_multi(const_iterator __p, __node_pointer __nd);

  _LIBCPP_HIDE_FROM_ABI iterator __remove_node_pointer(__node_pointer) _NOEXCEPT;

#if _LIBCPP_STD_VER >= 17
  template <class _NodeHandle, class _InsertReturnType>
  _LIBCPP_HIDE_FROM_ABI _InsertReturnType __node_handle_insert_unique(_NodeHandle&&);
  template <class _NodeHandle>
  _LIBCPP_HIDE_FROM_ABI iterator __node_handle_insert_unique(const_iterator, _NodeHandle&&);
  template <class _Tree>
  _LIBCPP_HIDE_FROM_ABI void __node_handle_merge_unique(_Tree& __source);

  template <class _NodeHandle>
  _LIBCPP_HIDE_FROM_ABI iterator __node_handle_insert_multi(_NodeHandle&&);
  template <class _NodeHandle>
  _LIBCPP_HIDE_FROM_ABI iterator __node_handle_insert_multi(const_iterator, _NodeHandle&&);
  template <class _Tree>
  _LIBCPP_HIDE_FROM_ABI void __node_handle_merge_multi(_Tree& __source);

  template <class _NodeHandle>
  _LIBCPP_HIDE_FROM_ABI _NodeHandle __node_handle_extract(key_type const&);
  template <class _NodeHandle>
  _LIBCPP_HIDE_FROM_ABI _NodeHandle __node_handle_extract(const_iterator);
#endif

  _LIBCPP_HIDE_FROM_ABI iterator erase(const_iterator __p);
  _LIBCPP_HIDE_FROM_ABI iterator erase(const_iterator __f, const_iterator __l);
  template <class _Key>
  _LIBCPP_HIDE_FROM_ABI size_type __erase_unique(const _Key& __k);
  template <class _Key>
  _LIBCPP_HIDE_FROM_ABI size_type __erase_multi(const _Key& __k);

  _LIBCPP_HIDE_FROM_ABI void
  __insert_node_at(__end_node_pointer __parent, __node_base_pointer& __child, __node_base_pointer __new_node) _NOEXCEPT;

  template <class _Key>
  _LIBCPP_HIDE_FROM_ABI iterator find(const _Key& __v);
  template <class _Key>
  _LIBCPP_HIDE_FROM_ABI const_iterator find(const _Key& __v) const;

  template <class _Key>
  _LIBCPP_HIDE_FROM_ABI size_type __count_unique(const _Key& __k) const;
  template <class _Key>
  _LIBCPP_HIDE_FROM_ABI size_type __count_multi(const _Key& __k) const;

  template <class _Key>
  _LIBCPP_HIDE_FROM_ABI iterator lower_bound(const _Key& __v) {
    return __lower_bound(__v, __root(), __end_node());
  }
  template <class _Key>
  _LIBCPP_HIDE_FROM_ABI iterator __lower_bound(const _Key& __v, __node_pointer __root, __end_node_pointer __result);
  template <class _Key>
  _LIBCPP_HIDE_FROM_ABI const_iterator lower_bound(const _Key& __v) const {
    return __lower_bound(__v, __root(), __end_node());
  }
  template <class _Key>
  _LIBCPP_HIDE_FROM_ABI const_iterator
  __lower_bound(const _Key& __v, __node_pointer __root, __end_node_pointer __result) const;
  template <class _Key>
  _LIBCPP_HIDE_FROM_ABI iterator upper_bound(const _Key& __v) {
    return __upper_bound(__v, __root(), __end_node());
  }
  template <class _Key>
  _LIBCPP_HIDE_FROM_ABI iterator __upper_bound(const _Key& __v, __node_pointer __root, __end_node_pointer __result);
  template <class _Key>
  _LIBCPP_HIDE_FROM_ABI const_iterator upper_bound(const _Key& __v) const {
    return __upper_bound(__v, __root(), __end_node());
  }
  template <class _Key>
  _LIBCPP_HIDE_FROM_ABI const_iterator
  __upper_bound(const _Key& __v, __node_pointer __root, __end_node_pointer __result) const;
  template <class _Key>
  _LIBCPP_HIDE_FROM_ABI pair<iterator, iterator> __equal_range_unique(const _Key& __k);
  template <class _Key>
  _LIBCPP_HIDE_FROM_ABI pair<const_iterator, const_iterator> __equal_range_unique(const _Key& __k) const;

  template <class _Key>
  _LIBCPP_HIDE_FROM_ABI pair<iterator, iterator> __equal_range_multi(const _Key& __k);
  template <class _Key>
  _LIBCPP_HIDE_FROM_ABI pair<const_iterator, const_iterator> __equal_range_multi(const _Key& __k) const;

  typedef __tree_node_destructor<__node_allocator> _Dp;
  typedef unique_ptr<__node, _Dp> __node_holder;

  _LIBCPP_HIDE_FROM_ABI __node_holder remove(const_iterator __p) _NOEXCEPT;

  // FIXME: Make this function const qualified. Unfortunately doing so
  // breaks existing code which uses non-const callable comparators.
  template <class _Key>
  _LIBCPP_HIDE_FROM_ABI __node_base_pointer& __find_equal(__end_node_pointer& __parent, const _Key& __v);
  template <class _Key>
  _LIBCPP_HIDE_FROM_ABI __node_base_pointer& __find_equal(__end_node_pointer& __parent, const _Key& __v) const {
    return const_cast<__tree*>(this)->__find_equal(__parent, __v);
  }
  template <class _Key>
  _LIBCPP_HIDE_FROM_ABI __node_base_pointer&
  __find_equal(const_iterator __hint, __end_node_pointer& __parent, __node_base_pointer& __dummy, const _Key& __v);

  _LIBCPP_HIDE_FROM_ABI void __copy_assign_alloc(const __tree& __t) {
    __copy_assign_alloc(__t, integral_constant<bool, __node_traits::propagate_on_container_copy_assignment::value>());
  }

  _LIBCPP_HIDE_FROM_ABI void __copy_assign_alloc(const __tree& __t, true_type) {
    if (__node_alloc() != __t.__node_alloc())
      clear();
    __node_alloc() = __t.__node_alloc();
  }
  _LIBCPP_HIDE_FROM_ABI void __copy_assign_alloc(const __tree&, false_type) {}

private:
  _LIBCPP_HIDE_FROM_ABI __node_base_pointer& __find_leaf_low(__end_node_pointer& __parent, const value_type& __v);

  _LIBCPP_HIDE_FROM_ABI __node_base_pointer& __find_leaf_high(__end_node_pointer& __parent, const value_type& __v);

  _LIBCPP_HIDE_FROM_ABI __node_base_pointer&
  __find_leaf(const_iterator __hint, __end_node_pointer& __parent, const value_type& __v);

  template <class... _Args>
  _LIBCPP_HIDE_FROM_ABI __node_holder __construct_node(_Args&&... __args);

  // TODO: Make this _LIBCPP_HIDE_FROM_ABI
  _LIBCPP_HIDDEN void destroy(__node_pointer __nd) _NOEXCEPT;

  _LIBCPP_HIDE_FROM_ABI void __move_assign(__tree& __t, false_type);
  _LIBCPP_HIDE_FROM_ABI void __move_assign(__tree& __t, true_type) _NOEXCEPT_(
      is_nothrow_move_assignable<value_compare>::value&& is_nothrow_move_assignable<__node_allocator>::value);

  _LIBCPP_HIDE_FROM_ABI void __move_assign_alloc(__tree& __t)
      _NOEXCEPT_(!__node_traits::propagate_on_container_move_assignment::value ||
                 is_nothrow_move_assignable<__node_allocator>::value) {
    __move_assign_alloc(__t, integral_constant<bool, __node_traits::propagate_on_container_move_assignment::value>());
  }

  _LIBCPP_HIDE_FROM_ABI void __move_assign_alloc(__tree& __t, true_type)
      _NOEXCEPT_(is_nothrow_move_assignable<__node_allocator>::value) {
    __node_alloc() = std::move(__t.__node_alloc());
  }
  _LIBCPP_HIDE_FROM_ABI void __move_assign_alloc(__tree&, false_type) _NOEXCEPT {}

  template <class _From, class _ValueT = _Tp, __enable_if_t<__is_tree_value_type<_ValueT>::value, int> = 0>
  _LIBCPP_HIDE_FROM_ABI static void __assign_value(__get_node_value_type_t<value_type>& __lhs, _From&& __rhs) {
    using __key_type = __remove_const_t<typename value_type::first_type>;

    // This is technically UB, since the object was constructed as `const`.
    // Clang doesn't optimize on this currently though.
    const_cast<__key_type&>(__lhs.first) = const_cast<__copy_cvref_t<_From, __key_type>&&>(__rhs.first);
    __lhs.second                         = std::forward<_From>(__rhs).second;
  }

  template <class _To, class _From, class _ValueT = _Tp, __enable_if_t<!__is_tree_value_type<_ValueT>::value, int> = 0>
  _LIBCPP_HIDE_FROM_ABI static void __assign_value(_To& __lhs, _From&& __rhs) {
    __lhs = std::forward<_From>(__rhs);
  }

  struct _DetachedTreeCache {
    _LIBCPP_HIDE_FROM_ABI explicit _DetachedTreeCache(__tree* __t) _NOEXCEPT
        : __t_(__t),
          __cache_root_(__detach_from_tree(__t)) {
      __advance();
    }

    _LIBCPP_HIDE_FROM_ABI __node_pointer __get() const _NOEXCEPT { return __cache_elem_; }

    _LIBCPP_HIDE_FROM_ABI void __advance() _NOEXCEPT {
      __cache_elem_ = __cache_root_;
      if (__cache_root_) {
        __cache_root_ = __detach_next(__cache_root_);
      }
    }

    _LIBCPP_HIDE_FROM_ABI ~_DetachedTreeCache() {
      __t_->destroy(__cache_elem_);
      if (__cache_root_) {
        while (__cache_root_->__parent_ != nullptr)
          __cache_root_ = static_cast<__node_pointer>(__cache_root_->__parent_);
        __t_->destroy(__cache_root_);
      }
    }

    _DetachedTreeCache(_DetachedTreeCache const&)            = delete;
    _DetachedTreeCache& operator=(_DetachedTreeCache const&) = delete;

  private:
    _LIBCPP_HIDE_FROM_ABI static __node_pointer __detach_from_tree(__tree* __t) _NOEXCEPT;
    _LIBCPP_HIDE_FROM_ABI static __node_pointer __detach_next(__node_pointer) _NOEXCEPT;

    __tree* __t_;
    __node_pointer __cache_root_;
    __node_pointer __cache_elem_;
  };
};

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(const value_compare& __comp) _NOEXCEPT_(
    is_nothrow_default_constructible<__node_allocator>::value&& is_nothrow_copy_constructible<value_compare>::value)
    : __size_(0), __value_comp_(__comp) {
  __begin_node() = __end_node();
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(const allocator_type& __a)
    : __begin_node_(), __node_alloc_(__node_allocator(__a)), __size_(0) {
  __begin_node() = __end_node();
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(const value_compare& __comp, const allocator_type& __a)
    : __begin_node_(), __node_alloc_(__node_allocator(__a)), __size_(0), __value_comp_(__comp) {
  __begin_node() = __end_node();
}

// Precondition:  size() != 0
template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_pointer
__tree<_Tp, _Compare, _Allocator>::_DetachedTreeCache::__detach_from_tree(__tree* __t) _NOEXCEPT {
  __node_pointer __cache                = static_cast<__node_pointer>(__t->__begin_node());
  __t->__begin_node()                   = __t->__end_node();
  __t->__end_node()->__left_->__parent_ = nullptr;
  __t->__end_node()->__left_            = nullptr;
  __t->size()                           = 0;
  // __cache->__left_ == nullptr
  if (__cache->__right_ != nullptr)
    __cache = static_cast<__node_pointer>(__cache->__right_);
  // __cache->__left_ == nullptr
  // __cache->__right_ == nullptr
  return __cache;
}

// Precondition:  __cache != nullptr
//    __cache->left_ == nullptr
//    __cache->right_ == nullptr
//    This is no longer a red-black tree
template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_pointer
__tree<_Tp, _Compare, _Allocator>::_DetachedTreeCache::__detach_next(__node_pointer __cache) _NOEXCEPT {
  if (__cache->__parent_ == nullptr)
    return nullptr;
  if (std::__tree_is_left_child(static_cast<__node_base_pointer>(__cache))) {
    __cache->__parent_->__left_ = nullptr;
    __cache                     = static_cast<__node_pointer>(__cache->__parent_);
    if (__cache->__right_ == nullptr)
      return __cache;
    return static_cast<__node_pointer>(std::__tree_leaf(__cache->__right_));
  }
  // __cache is right child
  __cache->__parent_unsafe()->__right_ = nullptr;
  __cache                              = static_cast<__node_pointer>(__cache->__parent_);
  if (__cache->__left_ == nullptr)
    return __cache;
  return static_cast<__node_pointer>(std::__tree_leaf(__cache->__left_));
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>& __tree<_Tp, _Compare, _Allocator>::operator=(const __tree& __t) {
  if (this != std::addressof(__t)) {
    value_comp() = __t.value_comp();
    __copy_assign_alloc(__t);
    __assign_multi(__t.begin(), __t.end());
  }
  return *this;
}

template <class _Tp, class _Compare, class _Allocator>
template <class _ForwardIterator>
void __tree<_Tp, _Compare, _Allocator>::__assign_unique(_ForwardIterator __first, _ForwardIterator __last) {
  typedef iterator_traits<_ForwardIterator> _ITraits;
  typedef typename _ITraits::value_type _ItValueType;
  static_assert(
      is_same<_ItValueType, value_type>::value, "__assign_unique may only be called with the containers value type");
  static_assert(
      __has_forward_iterator_category<_ForwardIterator>::value, "__assign_unique requires a forward iterator");
  if (size() != 0) {
    _DetachedTreeCache __cache(this);
    for (; __cache.__get() != nullptr && __first != __last; ++__first) {
      if (__node_assign_unique(*__first, __cache.__get()).second)
        __cache.__advance();
    }
  }
  for (; __first != __last; ++__first)
    __emplace_unique(*__first);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _InputIterator>
void __tree<_Tp, _Compare, _Allocator>::__assign_multi(_InputIterator __first, _InputIterator __last) {
  typedef iterator_traits<_InputIterator> _ITraits;
  typedef typename _ITraits::value_type _ItValueType;
  static_assert(
      is_same<_ItValueType, value_type>::value, "__assign_multi may only be called with the containers value_type");
  if (size() != 0) {
    _DetachedTreeCache __cache(this);
    for (; __cache.__get() && __first != __last; ++__first) {
      __assign_value(__cache.__get()->__value_, *__first);
      __node_insert_multi(__cache.__get());
      __cache.__advance();
    }
  }
  const_iterator __e = end();
  for (; __first != __last; ++__first)
    __emplace_hint_multi(__e, *__first);
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(const __tree& __t)
    : __begin_node_(),
      __node_alloc_(__node_traits::select_on_container_copy_construction(__t.__node_alloc())),
      __size_(0),
      __value_comp_(__t.value_comp()) {
  __begin_node() = __end_node();
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(__tree&& __t) _NOEXCEPT_(
    is_nothrow_move_constructible<__node_allocator>::value&& is_nothrow_move_constructible<value_compare>::value)
    : __begin_node_(std::move(__t.__begin_node_)),
      __end_node_(std::move(__t.__end_node_)),
      __node_alloc_(std::move(__t.__node_alloc_)),
      __size_(__t.__size_),
      __value_comp_(std::move(__t.__value_comp_)) {
  if (size() == 0)
    __begin_node() = __end_node();
  else {
    __end_node()->__left_->__parent_ = static_cast<__end_node_pointer>(__end_node());
    __t.__begin_node()               = __t.__end_node();
    __t.__end_node()->__left_        = nullptr;
    __t.size()                       = 0;
  }
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(__tree&& __t, const allocator_type& __a)
    : __node_alloc_(__node_allocator(__a)), __size_(0), __value_comp_(std::move(__t.value_comp())) {
  if (__a == __t.__alloc()) {
    if (__t.size() == 0)
      __begin_node() = __end_node();
    else {
      __begin_node()                   = __t.__begin_node();
      __end_node()->__left_            = __t.__end_node()->__left_;
      __end_node()->__left_->__parent_ = static_cast<__end_node_pointer>(__end_node());
      size()                           = __t.size();
      __t.__begin_node()               = __t.__end_node();
      __t.__end_node()->__left_        = nullptr;
      __t.size()                       = 0;
    }
  } else {
    __begin_node() = __end_node();
  }
}

template <class _Tp, class _Compare, class _Allocator>
void __tree<_Tp, _Compare, _Allocator>::__move_assign(__tree& __t, true_type)
    _NOEXCEPT_(is_nothrow_move_assignable<value_compare>::value&& is_nothrow_move_assignable<__node_allocator>::value) {
  destroy(static_cast<__node_pointer>(__end_node()->__left_));
  __begin_node_ = __t.__begin_node_;
  __end_node_   = __t.__end_node_;
  __move_assign_alloc(__t);
  __size_       = __t.__size_;
  __value_comp_ = std::move(__t.__value_comp_);
  if (size() == 0)
    __begin_node() = __end_node();
  else {
    __end_node()->__left_->__parent_ = static_cast<__end_node_pointer>(__end_node());
    __t.__begin_node()               = __t.__end_node();
    __t.__end_node()->__left_        = nullptr;
    __t.size()                       = 0;
  }
}

template <class _Tp, class _Compare, class _Allocator>
void __tree<_Tp, _Compare, _Allocator>::__move_assign(__tree& __t, false_type) {
  if (__node_alloc() == __t.__node_alloc())
    __move_assign(__t, true_type());
  else {
    value_comp()       = std::move(__t.value_comp());
    const_iterator __e = end();
    if (size() != 0) {
      _DetachedTreeCache __cache(this);
      while (__cache.__get() != nullptr && __t.size() != 0) {
        __assign_value(__cache.__get()->__value_, std::move(__t.remove(__t.begin())->__value_));
        __node_insert_multi(__cache.__get());
        __cache.__advance();
      }
    }
    while (__t.size() != 0) {
      __insert_multi_from_orphaned_node(__e, std::move(__t.remove(__t.begin())->__value_));
    }
  }
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>& __tree<_Tp, _Compare, _Allocator>::operator=(__tree&& __t)
    _NOEXCEPT_(is_nothrow_move_assignable<value_compare>::value &&
               ((__node_traits::propagate_on_container_move_assignment::value &&
                 is_nothrow_move_assignable<__node_allocator>::value) ||
                allocator_traits<__node_allocator>::is_always_equal::value)) {
  __move_assign(__t, integral_constant<bool, __node_traits::propagate_on_container_move_assignment::value>());
  return *this;
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::~__tree() {
  static_assert(is_copy_constructible<value_compare>::value, "Comparator must be copy-constructible.");
  destroy(__root());
}

template <class _Tp, class _Compare, class _Allocator>
void __tree<_Tp, _Compare, _Allocator>::destroy(__node_pointer __nd) _NOEXCEPT {
  if (__nd != nullptr) {
    destroy(static_cast<__node_pointer>(__nd->__left_));
    destroy(static_cast<__node_pointer>(__nd->__right_));
    __node_allocator& __na = __node_alloc();
    __node_traits::destroy(__na, std::addressof(__nd->__value_));
    __node_traits::deallocate(__na, __nd, 1);
  }
}

template <class _Tp, class _Compare, class _Allocator>
void __tree<_Tp, _Compare, _Allocator>::swap(__tree& __t)
#if _LIBCPP_STD_VER <= 11
    _NOEXCEPT_(__is_nothrow_swappable_v<value_compare> &&
               (!__node_traits::propagate_on_container_swap::value || __is_nothrow_swappable_v<__node_allocator>))
#else
    _NOEXCEPT_(__is_nothrow_swappable_v<value_compare>)
#endif
{
  using std::swap;
  swap(__begin_node_, __t.__begin_node_);
  swap(__end_node_, __t.__end_node_);
  std::__swap_allocator(__node_alloc(), __t.__node_alloc());
  swap(__size_, __t.__size_);
  swap(__value_comp_, __t.__value_comp_);
  if (size() == 0)
    __begin_node() = __end_node();
  else
    __end_node()->__left_->__parent_ = __end_node();
  if (__t.size() == 0)
    __t.__begin_node() = __t.__end_node();
  else
    __t.__end_node()->__left_->__parent_ = __t.__end_node();
}

template <class _Tp, class _Compare, class _Allocator>
void __tree<_Tp, _Compare, _Allocator>::clear() _NOEXCEPT {
  destroy(__root());
  size()                = 0;
  __begin_node()        = __end_node();
  __end_node()->__left_ = nullptr;
}

// Find lower_bound place to insert
// Set __parent to parent of null leaf
// Return reference to null leaf
template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer&
__tree<_Tp, _Compare, _Allocator>::__find_leaf_low(__end_node_pointer& __parent, const value_type& __v) {
  __node_pointer __nd = __root();
  if (__nd != nullptr) {
    while (true) {
      if (value_comp()(__nd->__value_, __v)) {
        if (__nd->__right_ != nullptr)
          __nd = static_cast<__node_pointer>(__nd->__right_);
        else {
          __parent = static_cast<__end_node_pointer>(__nd);
          return __nd->__right_;
        }
      } else {
        if (__nd->__left_ != nullptr)
          __nd = static_cast<__node_pointer>(__nd->__left_);
        else {
          __parent = static_cast<__end_node_pointer>(__nd);
          return __parent->__left_;
        }
      }
    }
  }
  __parent = __end_node();
  return __parent->__left_;
}

// Find upper_bound place to insert
// Set __parent to parent of null leaf
// Return reference to null leaf
template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer&
__tree<_Tp, _Compare, _Allocator>::__find_leaf_high(__end_node_pointer& __parent, const value_type& __v) {
  __node_pointer __nd = __root();
  if (__nd != nullptr) {
    while (true) {
      if (value_comp()(__v, __nd->__value_)) {
        if (__nd->__left_ != nullptr)
          __nd = static_cast<__node_pointer>(__nd->__left_);
        else {
          __parent = static_cast<__end_node_pointer>(__nd);
          return __parent->__left_;
        }
      } else {
        if (__nd->__right_ != nullptr)
          __nd = static_cast<__node_pointer>(__nd->__right_);
        else {
          __parent = static_cast<__end_node_pointer>(__nd);
          return __nd->__right_;
        }
      }
    }
  }
  __parent = __end_node();
  return __parent->__left_;
}

// Find leaf place to insert closest to __hint
// First check prior to __hint.
// Next check after __hint.
// Next do O(log N) search.
// Set __parent to parent of null leaf
// Return reference to null leaf
template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer& __tree<_Tp, _Compare, _Allocator>::__find_leaf(
    const_iterator __hint, __end_node_pointer& __parent, const value_type& __v) {
  if (__hint == end() || !value_comp()(*__hint, __v)) // check before
  {
    // __v <= *__hint
    const_iterator __prior = __hint;
    if (__prior == begin() || !value_comp()(__v, *--__prior)) {
      // *prev(__hint) <= __v <= *__hint
      if (__hint.__ptr_->__left_ == nullptr) {
        __parent = static_cast<__end_node_pointer>(__hint.__ptr_);
        return __parent->__left_;
      } else {
        __parent = static_cast<__end_node_pointer>(__prior.__ptr_);
        return static_cast<__node_base_pointer>(__prior.__ptr_)->__right_;
      }
    }
    // __v < *prev(__hint)
    return __find_leaf_high(__parent, __v);
  }
  // else __v > *__hint
  return __find_leaf_low(__parent, __v);
}

// Find place to insert if __v doesn't exist
// Set __parent to parent of null leaf
// Return reference to null leaf
// If __v exists, set parent to node of __v and return reference to node of __v
template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer&
__tree<_Tp, _Compare, _Allocator>::__find_equal(__end_node_pointer& __parent, const _Key& __v) {
  __node_pointer __nd           = __root();
  __node_base_pointer* __nd_ptr = __root_ptr();
  if (__nd != nullptr) {
    while (true) {
      if (value_comp()(__v, __nd->__value_)) {
        if (__nd->__left_ != nullptr) {
          __nd_ptr = std::addressof(__nd->__left_);
          __nd     = static_cast<__node_pointer>(__nd->__left_);
        } else {
          __parent = static_cast<__end_node_pointer>(__nd);
          return __parent->__left_;
        }
      } else if (value_comp()(__nd->__value_, __v)) {
        if (__nd->__right_ != nullptr) {
          __nd_ptr = std::addressof(__nd->__right_);
          __nd     = static_cast<__node_pointer>(__nd->__right_);
        } else {
          __parent = static_cast<__end_node_pointer>(__nd);
          return __nd->__right_;
        }
      } else {
        __parent = static_cast<__end_node_pointer>(__nd);
        return *__nd_ptr;
      }
    }
  }
  __parent = __end_node();
  return __parent->__left_;
}

// Find place to insert if __v doesn't exist
// First check prior to __hint.
// Next check after __hint.
// Next do O(log N) search.
// Set __parent to parent of null leaf
// Return reference to null leaf
// If __v exists, set parent to node of __v and return reference to node of __v
template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer& __tree<_Tp, _Compare, _Allocator>::__find_equal(
    const_iterator __hint, __end_node_pointer& __parent, __node_base_pointer& __dummy, const _Key& __v) {
  if (__hint == end() || value_comp()(__v, *__hint)) // check before
  {
    // __v < *__hint
    const_iterator __prior = __hint;
    if (__prior == begin() || value_comp()(*--__prior, __v)) {
      // *prev(__hint) < __v < *__hint
      if (__hint.__ptr_->__left_ == nullptr) {
        __parent = __hint.__ptr_;
        return __parent->__left_;
      } else {
        __parent = __prior.__ptr_;
        return static_cast<__node_base_pointer>(__prior.__ptr_)->__right_;
      }
    }
    // __v <= *prev(__hint)
    return __find_equal(__parent, __v);
  } else if (value_comp()(*__hint, __v)) // check after
  {
    // *__hint < __v
    const_iterator __next = std::next(__hint);
    if (__next == end() || value_comp()(__v, *__next)) {
      // *__hint < __v < *std::next(__hint)
      if (__hint.__get_np()->__right_ == nullptr) {
        __parent = __hint.__ptr_;
        return static_cast<__node_base_pointer>(__hint.__ptr_)->__right_;
      } else {
        __parent = __next.__ptr_;
        return __parent->__left_;
      }
    }
    // *next(__hint) <= __v
    return __find_equal(__parent, __v);
  }
  // else __v == *__hint
  __parent = __hint.__ptr_;
  __dummy  = static_cast<__node_base_pointer>(__hint.__ptr_);
  return __dummy;
}

template <class _Tp, class _Compare, class _Allocator>
void __tree<_Tp, _Compare, _Allocator>::__insert_node_at(
    __end_node_pointer __parent, __node_base_pointer& __child, __node_base_pointer __new_node) _NOEXCEPT {
  __new_node->__left_   = nullptr;
  __new_node->__right_  = nullptr;
  __new_node->__parent_ = __parent;
  // __new_node->__is_black_ is initialized in __tree_balance_after_insert
  __child = __new_node;
  if (__begin_node()->__left_ != nullptr)
    __begin_node() = static_cast<__end_node_pointer>(__begin_node()->__left_);
  std::__tree_balance_after_insert(__end_node()->__left_, __child);
  ++size();
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key, class... _Args>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>
__tree<_Tp, _Compare, _Allocator>::__emplace_unique_key_args(_Key const& __k, _Args&&... __args) {
  __end_node_pointer __parent;
  __node_base_pointer& __child = __find_equal(__parent, __k);
  __node_pointer __r           = static_cast<__node_pointer>(__child);
  bool __inserted              = false;
  if (__child == nullptr) {
    __node_holder __h = __construct_node(std::forward<_Args>(__args)...);
    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));
    __r        = __h.release();
    __inserted = true;
  }
  return pair<iterator, bool>(iterator(__r), __inserted);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key, class... _Args>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>
__tree<_Tp, _Compare, _Allocator>::__emplace_hint_unique_key_args(
    const_iterator __p, _Key const& __k, _Args&&... __args) {
  __end_node_pointer __parent;
  __node_base_pointer __dummy;
  __node_base_pointer& __child = __find_equal(__p, __parent, __dummy, __k);
  __node_pointer __r           = static_cast<__node_pointer>(__child);
  bool __inserted              = false;
  if (__child == nullptr) {
    __node_holder __h = __construct_node(std::forward<_Args>(__args)...);
    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));
    __r        = __h.release();
    __inserted = true;
  }
  return pair<iterator, bool>(iterator(__r), __inserted);
}

template <class _Tp, class _Compare, class _Allocator>
template <class... _Args>
typename __tree<_Tp, _Compare, _Allocator>::__node_holder
__tree<_Tp, _Compare, _Allocator>::__construct_node(_Args&&... __args) {
  __node_allocator& __na = __node_alloc();
  __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));
  __node_traits::construct(__na, std::addressof(__h->__value_), std::forward<_Args>(__args)...);
  __h.get_deleter().__value_constructed = true;
  return __h;
}

template <class _Tp, class _Compare, class _Allocator>
template <class... _Args>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>
__tree<_Tp, _Compare, _Allocator>::__emplace_unique_impl(_Args&&... __args) {
  __node_holder __h = __construct_node(std::forward<_Args>(__args)...);
  __end_node_pointer __parent;
  __node_base_pointer& __child = __find_equal(__parent, __h->__value_);
  __node_pointer __r           = static_cast<__node_pointer>(__child);
  bool __inserted              = false;
  if (__child == nullptr) {
    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));
    __r        = __h.release();
    __inserted = true;
  }
  return pair<iterator, bool>(iterator(__r), __inserted);
}

template <class _Tp, class _Compare, class _Allocator>
template <class... _Args>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__emplace_hint_unique_impl(const_iterator __p, _Args&&... __args) {
  __node_holder __h = __construct_node(std::forward<_Args>(__args)...);
  __end_node_pointer __parent;
  __node_base_pointer __dummy;
  __node_base_pointer& __child = __find_equal(__p, __parent, __dummy, __h->__value_);
  __node_pointer __r           = static_cast<__node_pointer>(__child);
  if (__child == nullptr) {
    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));
    __r = __h.release();
  }
  return iterator(__r);
}

template <class _Tp, class _Compare, class _Allocator>
template <class... _Args>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__emplace_multi(_Args&&... __args) {
  __node_holder __h = __construct_node(std::forward<_Args>(__args)...);
  __end_node_pointer __parent;
  __node_base_pointer& __child = __find_leaf_high(__parent, __h->__value_);
  __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));
  return iterator(static_cast<__node_pointer>(__h.release()));
}

template <class _Tp, class _Compare, class _Allocator>
template <class... _Args>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__emplace_hint_multi(const_iterator __p, _Args&&... __args) {
  __node_holder __h = __construct_node(std::forward<_Args>(__args)...);
  __end_node_pointer __parent;
  __node_base_pointer& __child = __find_leaf(__p, __parent, __h->__value_);
  __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));
  return iterator(static_cast<__node_pointer>(__h.release()));
}

template <class _Tp, class _Compare, class _Allocator>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>
__tree<_Tp, _Compare, _Allocator>::__node_assign_unique(const value_type& __v, __node_pointer __nd) {
  __end_node_pointer __parent;
  __node_base_pointer& __child = __find_equal(__parent, __v);
  __node_pointer __r           = static_cast<__node_pointer>(__child);
  bool __inserted              = false;
  if (__child == nullptr) {
    __assign_value(__nd->__value_, __v);
    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));
    __r        = __nd;
    __inserted = true;
  }
  return pair<iterator, bool>(iterator(__r), __inserted);
}

template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__node_insert_multi(__node_pointer __nd) {
  __end_node_pointer __parent;
  __node_base_pointer& __child = __find_leaf_high(__parent, __nd->__value_);
  __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));
  return iterator(__nd);
}

template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__node_insert_multi(const_iterator __p, __node_pointer __nd) {
  __end_node_pointer __parent;
  __node_base_pointer& __child = __find_leaf(__p, __parent, __nd->__value_);
  __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));
  return iterator(__nd);
}

template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__remove_node_pointer(__node_pointer __ptr) _NOEXCEPT {
  iterator __r(__ptr);
  ++__r;
  if (__begin_node() == __ptr)
    __begin_node() = __r.__ptr_;
  --size();
  std::__tree_remove(__end_node()->__left_, static_cast<__node_base_pointer>(__ptr));
  return __r;
}

#if _LIBCPP_STD_VER >= 17
template <class _Tp, class _Compare, class _Allocator>
template <class _NodeHandle, class _InsertReturnType>
_LIBCPP_HIDE_FROM_ABI _InsertReturnType
__tree<_Tp, _Compare, _Allocator>::__node_handle_insert_unique(_NodeHandle&& __nh) {
  if (__nh.empty())
    return _InsertReturnType{end(), false, _NodeHandle()};

  __node_pointer __ptr = __nh.__ptr_;
  __end_node_pointer __parent;
  __node_base_pointer& __child = __find_equal(__parent, __ptr->__value_);
  if (__child != nullptr)
    return _InsertReturnType{iterator(static_cast<__node_pointer>(__child)), false, std::move(__nh)};

  __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__ptr));
  __nh.__release_ptr();
  return _InsertReturnType{iterator(__ptr), true, _NodeHandle()};
}

template <class _Tp, class _Compare, class _Allocator>
template <class _NodeHandle>
_LIBCPP_HIDE_FROM_ABI typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__node_handle_insert_unique(const_iterator __hint, _NodeHandle&& __nh) {
  if (__nh.empty())
    return end();

  __node_pointer __ptr = __nh.__ptr_;
  __end_node_pointer __parent;
  __node_base_pointer __dummy;
  __node_base_pointer& __child = __find_equal(__hint, __parent, __dummy, __ptr->__value_);
  __node_pointer __r           = static_cast<__node_pointer>(__child);
  if (__child == nullptr) {
    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__ptr));
    __r = __ptr;
    __nh.__release_ptr();
  }
  return iterator(__r);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _NodeHandle>
_LIBCPP_HIDE_FROM_ABI _NodeHandle __tree<_Tp, _Compare, _Allocator>::__node_handle_extract(key_type const& __key) {
  iterator __it = find(__key);
  if (__it == end())
    return _NodeHandle();
  return __node_handle_extract<_NodeHandle>(__it);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _NodeHandle>
_LIBCPP_HIDE_FROM_ABI _NodeHandle __tree<_Tp, _Compare, _Allocator>::__node_handle_extract(const_iterator __p) {
  __node_pointer __np = __p.__get_np();
  __remove_node_pointer(__np);
  return _NodeHandle(__np, __alloc());
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Tree>
_LIBCPP_HIDE_FROM_ABI void __tree<_Tp, _Compare, _Allocator>::__node_handle_merge_unique(_Tree& __source) {
  static_assert(is_same<typename _Tree::__node_pointer, __node_pointer>::value, "");

  for (typename _Tree::iterator __i = __source.begin(); __i != __source.end();) {
    __node_pointer __src_ptr = __i.__get_np();
    __end_node_pointer __parent;
    __node_base_pointer& __child = __find_equal(__parent, __src_ptr->__value_);
    ++__i;
    if (__child != nullptr)
      continue;
    __source.__remove_node_pointer(__src_ptr);
    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__src_ptr));
  }
}

template <class _Tp, class _Compare, class _Allocator>
template <class _NodeHandle>
_LIBCPP_HIDE_FROM_ABI typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__node_handle_insert_multi(_NodeHandle&& __nh) {
  if (__nh.empty())
    return end();
  __node_pointer __ptr = __nh.__ptr_;
  __end_node_pointer __parent;
  __node_base_pointer& __child = __find_leaf_high(__parent, __ptr->__value_);
  __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__ptr));
  __nh.__release_ptr();
  return iterator(__ptr);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _NodeHandle>
_LIBCPP_HIDE_FROM_ABI typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__node_handle_insert_multi(const_iterator __hint, _NodeHandle&& __nh) {
  if (__nh.empty())
    return end();

  __node_pointer __ptr = __nh.__ptr_;
  __end_node_pointer __parent;
  __node_base_pointer& __child = __find_leaf(__hint, __parent, __ptr->__value_);
  __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__ptr));
  __nh.__release_ptr();
  return iterator(__ptr);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Tree>
_LIBCPP_HIDE_FROM_ABI void __tree<_Tp, _Compare, _Allocator>::__node_handle_merge_multi(_Tree& __source) {
  static_assert(is_same<typename _Tree::__node_pointer, __node_pointer>::value, "");

  for (typename _Tree::iterator __i = __source.begin(); __i != __source.end();) {
    __node_pointer __src_ptr = __i.__get_np();
    __end_node_pointer __parent;
    __node_base_pointer& __child = __find_leaf_high(__parent, __src_ptr->__value_);
    ++__i;
    __source.__remove_node_pointer(__src_ptr);
    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__src_ptr));
  }
}

#endif // _LIBCPP_STD_VER >= 17

template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::iterator __tree<_Tp, _Compare, _Allocator>::erase(const_iterator __p) {
  __node_pointer __np    = __p.__get_np();
  iterator __r           = __remove_node_pointer(__np);
  __node_allocator& __na = __node_alloc();
  __node_traits::destroy(__na, std::addressof(const_cast<value_type&>(*__p)));
  __node_traits::deallocate(__na, __np, 1);
  return __r;
}

template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::erase(const_iterator __f, const_iterator __l) {
  while (__f != __l)
    __f = erase(__f);
  return iterator(__l.__ptr_);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::size_type
__tree<_Tp, _Compare, _Allocator>::__erase_unique(const _Key& __k) {
  iterator __i = find(__k);
  if (__i == end())
    return 0;
  erase(__i);
  return 1;
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::size_type
__tree<_Tp, _Compare, _Allocator>::__erase_multi(const _Key& __k) {
  pair<iterator, iterator> __p = __equal_range_multi(__k);
  size_type __r                = 0;
  for (; __p.first != __p.second; ++__r)
    __p.first = erase(__p.first);
  return __r;
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::iterator __tree<_Tp, _Compare, _Allocator>::find(const _Key& __v) {
  iterator __p = __lower_bound(__v, __root(), __end_node());
  if (__p != end() && !value_comp()(__v, *__p))
    return __p;
  return end();
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::const_iterator
__tree<_Tp, _Compare, _Allocator>::find(const _Key& __v) const {
  const_iterator __p = __lower_bound(__v, __root(), __end_node());
  if (__p != end() && !value_comp()(__v, *__p))
    return __p;
  return end();
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::size_type
__tree<_Tp, _Compare, _Allocator>::__count_unique(const _Key& __k) const {
  __node_pointer __rt = __root();
  while (__rt != nullptr) {
    if (value_comp()(__k, __rt->__value_)) {
      __rt = static_cast<__node_pointer>(__rt->__left_);
    } else if (value_comp()(__rt->__value_, __k))
      __rt = static_cast<__node_pointer>(__rt->__right_);
    else
      return 1;
  }
  return 0;
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::size_type
__tree<_Tp, _Compare, _Allocator>::__count_multi(const _Key& __k) const {
  __end_node_pointer __result = __end_node();
  __node_pointer __rt         = __root();
  while (__rt != nullptr) {
    if (value_comp()(__k, __rt->__value_)) {
      __result = static_cast<__end_node_pointer>(__rt);
      __rt     = static_cast<__node_pointer>(__rt->__left_);
    } else if (value_comp()(__rt->__value_, __k))
      __rt = static_cast<__node_pointer>(__rt->__right_);
    else
      return std::distance(
          __lower_bound(__k, static_cast<__node_pointer>(__rt->__left_), static_cast<__end_node_pointer>(__rt)),
          __upper_bound(__k, static_cast<__node_pointer>(__rt->__right_), __result));
  }
  return 0;
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__lower_bound(const _Key& __v, __node_pointer __root, __end_node_pointer __result) {
  while (__root != nullptr) {
    if (!value_comp()(__root->__value_, __v)) {
      __result = static_cast<__end_node_pointer>(__root);
      __root   = static_cast<__node_pointer>(__root->__left_);
    } else
      __root = static_cast<__node_pointer>(__root->__right_);
  }
  return iterator(__result);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::const_iterator __tree<_Tp, _Compare, _Allocator>::__lower_bound(
    const _Key& __v, __node_pointer __root, __end_node_pointer __result) const {
  while (__root != nullptr) {
    if (!value_comp()(__root->__value_, __v)) {
      __result = static_cast<__end_node_pointer>(__root);
      __root   = static_cast<__node_pointer>(__root->__left_);
    } else
      __root = static_cast<__node_pointer>(__root->__right_);
  }
  return const_iterator(__result);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__upper_bound(const _Key& __v, __node_pointer __root, __end_node_pointer __result) {
  while (__root != nullptr) {
    if (value_comp()(__v, __root->__value_)) {
      __result = static_cast<__end_node_pointer>(__root);
      __root   = static_cast<__node_pointer>(__root->__left_);
    } else
      __root = static_cast<__node_pointer>(__root->__right_);
  }
  return iterator(__result);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::const_iterator __tree<_Tp, _Compare, _Allocator>::__upper_bound(
    const _Key& __v, __node_pointer __root, __end_node_pointer __result) const {
  while (__root != nullptr) {
    if (value_comp()(__v, __root->__value_)) {
      __result = static_cast<__end_node_pointer>(__root);
      __root   = static_cast<__node_pointer>(__root->__left_);
    } else
      __root = static_cast<__node_pointer>(__root->__right_);
  }
  return const_iterator(__result);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator, typename __tree<_Tp, _Compare, _Allocator>::iterator>
__tree<_Tp, _Compare, _Allocator>::__equal_range_unique(const _Key& __k) {
  typedef pair<iterator, iterator> _Pp;
  __end_node_pointer __result = __end_node();
  __node_pointer __rt         = __root();
  while (__rt != nullptr) {
    if (value_comp()(__k, __rt->__value_)) {
      __result = static_cast<__end_node_pointer>(__rt);
      __rt     = static_cast<__node_pointer>(__rt->__left_);
    } else if (value_comp()(__rt->__value_, __k))
      __rt = static_cast<__node_pointer>(__rt->__right_);
    else
      return _Pp(iterator(__rt),
                 iterator(__rt->__right_ != nullptr ? static_cast<__end_node_pointer>(std::__tree_min(__rt->__right_))
                                                    : __result));
  }
  return _Pp(iterator(__result), iterator(__result));
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
pair<typename __tree<_Tp, _Compare, _Allocator>::const_iterator,
     typename __tree<_Tp, _Compare, _Allocator>::const_iterator>
__tree<_Tp, _Compare, _Allocator>::__equal_range_unique(const _Key& __k) const {
  typedef pair<const_iterator, const_iterator> _Pp;
  __end_node_pointer __result = __end_node();
  __node_pointer __rt         = __root();
  while (__rt != nullptr) {
    if (value_comp()(__k, __rt->__value_)) {
      __result = static_cast<__end_node_pointer>(__rt);
      __rt     = static_cast<__node_pointer>(__rt->__left_);
    } else if (value_comp()(__rt->__value_, __k))
      __rt = static_cast<__node_pointer>(__rt->__right_);
    else
      return _Pp(
          const_iterator(__rt),
          const_iterator(
              __rt->__right_ != nullptr ? static_cast<__end_node_pointer>(std::__tree_min(__rt->__right_)) : __result));
  }
  return _Pp(const_iterator(__result), const_iterator(__result));
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator, typename __tree<_Tp, _Compare, _Allocator>::iterator>
__tree<_Tp, _Compare, _Allocator>::__equal_range_multi(const _Key& __k) {
  typedef pair<iterator, iterator> _Pp;
  __end_node_pointer __result = __end_node();
  __node_pointer __rt     = __root();
  while (__rt != nullptr) {
    if (value_comp()(__k, __rt->__value_)) {
      __result = static_cast<__end_node_pointer>(__rt);
      __rt     = static_cast<__node_pointer>(__rt->__left_);
    } else if (value_comp()(__rt->__value_, __k))
      __rt = static_cast<__node_pointer>(__rt->__right_);
    else
      return _Pp(__lower_bound(__k, static_cast<__node_pointer>(__rt->__left_), static_cast<__end_node_pointer>(__rt)),
                 __upper_bound(__k, static_cast<__node_pointer>(__rt->__right_), __result));
  }
  return _Pp(iterator(__result), iterator(__result));
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
pair<typename __tree<_Tp, _Compare, _Allocator>::const_iterator,
     typename __tree<_Tp, _Compare, _Allocator>::const_iterator>
__tree<_Tp, _Compare, _Allocator>::__equal_range_multi(const _Key& __k) const {
  typedef pair<const_iterator, const_iterator> _Pp;
  __end_node_pointer __result = __end_node();
  __node_pointer __rt     = __root();
  while (__rt != nullptr) {
    if (value_comp()(__k, __rt->__value_)) {
      __result = static_cast<__end_node_pointer>(__rt);
      __rt     = static_cast<__node_pointer>(__rt->__left_);
    } else if (value_comp()(__rt->__value_, __k))
      __rt = static_cast<__node_pointer>(__rt->__right_);
    else
      return _Pp(__lower_bound(__k, static_cast<__node_pointer>(__rt->__left_), static_cast<__end_node_pointer>(__rt)),
                 __upper_bound(__k, static_cast<__node_pointer>(__rt->__right_), __result));
  }
  return _Pp(const_iterator(__result), const_iterator(__result));
}

template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_holder
__tree<_Tp, _Compare, _Allocator>::remove(const_iterator __p) _NOEXCEPT {
  __node_pointer __np = __p.__get_np();
  if (__begin_node() == __p.__ptr_) {
    if (__np->__right_ != nullptr)
      __begin_node() = static_cast<__end_node_pointer>(__np->__right_);
    else
      __begin_node() = static_cast<__end_node_pointer>(__np->__parent_);
  }
  --size();
  std::__tree_remove(__end_node()->__left_, static_cast<__node_base_pointer>(__np));
  return __node_holder(__np, _Dp(__node_alloc(), true));
}

template <class _Tp, class _Compare, class _Allocator>
inline _LIBCPP_HIDE_FROM_ABI void swap(__tree<_Tp, _Compare, _Allocator>& __x, __tree<_Tp, _Compare, _Allocator>& __y)
    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y))) {
  __x.swap(__y);
}

_LIBCPP_END_NAMESPACE_STD

_LIBCPP_POP_MACROS

#endif // _LIBCPP___TREE
