const std = @import("std");
const ascii = std.ascii;
const fs = std.fs;
const io = std.io;
const mem = std.mem;
const process = std.process;
const assert = std.debug.assert;

pub fn main() !void {
    var arena_state = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    defer arena_state.deinit();
    const arena = arena_state.allocator();

    const args = try process.argsAlloc(arena);
    if (args.len < 1) usageAndExit(io.getStdErr(), "update_x86_cpu_model_enums", 1);
    if (args.len == 1) usageAndExit(io.getStdErr(), args[0], 1);
    if (mem.eql(u8, args[1], "--help")) usageAndExit(io.getStdOut(), args[0], 0);
    if (args.len != 4) usageAndExit(io.getStdErr(), args[0], 1);

    const zig_exe = args[1];
    if (mem.startsWith(u8, zig_exe, "-")) {
        usageAndExit(io.getStdErr(), args[0], 1);
    }

    const llvm_src_root = args[2];
    if (mem.startsWith(u8, llvm_src_root, "-")) {
        usageAndExit(io.getStdErr(), args[0], 1);
    }

    const zig_src_root = args[3];
    if (mem.startsWith(u8, zig_src_root, "-")) {
        usageAndExit(io.getStdErr(), args[0], 1);
    }

    var zig_src_dir = try fs.cwd().openDir(zig_src_root, .{});
    defer zig_src_dir.close();

    const def_file_path = try fs.path.join(arena, &.{
        llvm_src_root,
        "llvm/include/llvm/TargetParser/X86TargetParser.def",
    });

    var out_file = try zig_src_dir.createFile("lib/compiler_rt/cpu_model/x86.zig", .{});
    defer out_file.close();

    try out_file.writeAll(
        \\//! This file is auto-generated by tools/update_x86_cpu_model_enums.zig.
        \\//!
        \\//! If this file changes after updating LLVM, it might mean further changes are
        \\//! needed to the CPU type/subtype detection code in lib/compiler_rt/x86_cpu_model.zig.
        \\
        \\
    );

    const vendor_enum = blk: {
        const raw_enum_names = try preprocessCPUEnum(arena, zig_exe, def_file_path, &.{"X86_VENDOR(id, _1)=id"});

        const enum_fields = try arena.alloc(EnumField, raw_enum_names.len + 2);

        enum_fields[0] = .{ .name = "unknown" };
        for (enum_fields[1..][0..raw_enum_names.len], raw_enum_names) |*f, raw| {
            assert(mem.startsWith(u8, raw, "VENDOR_"));
            f.* = .{ .name = try llvmNameToZigName(arena, raw[7..]) };
        }
        enum_fields[1 + raw_enum_names.len] = .{ .name = "other" };

        break :blk enum_fields;
    };
    try writeEnum(out_file, "Vendor", vendor_enum);

    const type_enum = blk: {
        const raw_enum_names = try preprocessCPUEnum(arena, zig_exe, def_file_path, &.{"X86_CPU_TYPE(id, _1)=id"});

        const enum_fields = try arena.alloc(EnumField, raw_enum_names.len + 1);

        enum_fields[0] = .{ .name = "unknown" };
        for (enum_fields[1..][0..raw_enum_names.len], raw_enum_names) |*f, raw| {
            f.* = .{ .name = try llvmNameToZigName(arena, raw) };
        }

        break :blk enum_fields;
    };
    try writeEnum(out_file, "Type", type_enum);

    const subtype_enum = blk: {
        const raw_enum_names = try preprocessCPUEnum(arena, zig_exe, def_file_path, &.{"X86_CPU_SUBTYPE(id, _1)=id"});

        const enum_fields = try arena.alloc(EnumField, raw_enum_names.len + 1);

        enum_fields[0] = .{ .name = "unknown" };
        for (enum_fields[1..][0..raw_enum_names.len], raw_enum_names) |*f, raw| {
            f.* = .{ .name = try llvmNameToZigName(arena, raw) };
        }

        break :blk enum_fields;
    };
    try writeEnum(out_file, "Subtype", subtype_enum);

    // The enum values are specified by their position in the big list of X86_FEATURE(...) macros.
    // However, only the X86_FEATURE_COMPAT(...) values are used in compiler-rt for cpu detection.
    // The order is important because it is supposed to match the gcc version of the list
    // (https://github.com/gcc-mirror/gcc/blob/9693459e030977d6e906ea7eb587ed09ee4fddbd/gcc/common/config/i386/i386-cpuinfo.h#L154).
    //
    // Starting from LLVM 18, there are X86_MICROARCH_LEVEL(...) macros which also correspond to
    // FEATURE_* values in the big enum but their value is given by the priority (last parameter in the macro).
    const features_enum = blk: {
        const raw_enum_names = try preprocessCPUEnum(arena, zig_exe, def_file_path, &.{
            "X86_FEATURE(_0,_1)=^", // Marker to indicate we should ignore this line.
            "X86_FEATURE_COMPAT(_0,name,_2)=name",
            "X86_MICROARCH_LEVEL(_0,name,prio)=name=prio",
        });

        var enum_fields = std.ArrayList(EnumField).init(arena);

        for (raw_enum_names, 0..) |raw, i| {
            assert(raw.len > 0);
            switch (raw[0]) {
                '^' => {
                    // X86_FEATURE(...): does not contribute to compiler-rt feature enum
                },
                '"' => if (mem.indexOfScalar(u8, raw, '=')) |eq_pos| {
                    // X86_MICROARCH_LEVEL(...): line is of the form `"name"=prio'
                    assert(raw[eq_pos - 1] == '"');
                    const raw_name = raw[2 .. eq_pos - 1];
                    const raw_prio = raw[eq_pos + 1 ..];

                    try enum_fields.append(.{
                        .name = try llvmNameToZigName(arena, raw_name),
                        .value = std.fmt.parseUnsigned(u32, raw_prio, 10) catch unreachable,
                    });
                } else {
                    // X86_FEATURE_COMPAT(...): line is of the form `"name"'

                    assert(raw[raw.len - 1] == '"');
                    try enum_fields.append(.{
                        .name = try llvmNameToZigName(arena, raw[1 .. raw.len - 1]),
                        .value = @intCast(i),
                    });
                },
                else => unreachable,
            }
        }

        break :blk enum_fields.toOwnedSlice() catch unreachable;
    };
    try writeEnum(out_file, "Feature", features_enum);
}

fn usageAndExit(file: fs.File, arg0: []const u8, code: u8) noreturn {
    file.writer().print(
        \\Usage: {s} /path/to/zig-exe /path/to/llvm-project /path/to/zig-project
        \\
        \\Updates lib/compiler-rt/cpu_model/x86.zig from llvm/include/llvm/TargetParser/X86TargetParser.def
        \\
    , .{arg0}) catch process.exit(1);
    process.exit(code);
}

// The `defines` parameter are passed to the preprocessor as a `-D`.
// The output of the prepreocessor is split into lines and returned as an array of strings.
fn preprocessCPUEnum(arena: mem.Allocator, zig_exe: []const u8, def_path: []const u8, defines: []const []const u8) ![]const []const u8 {
    const preprocessed = blk: {
        const argv = argv_blk: {
            var argv = try std.ArrayListUnmanaged([]const u8).initCapacity(arena, 6 + defines.len);

            argv.appendAssumeCapacity(zig_exe);
            argv.appendAssumeCapacity("cc");
            argv.appendAssumeCapacity("-P");
            argv.appendAssumeCapacity("-E");
            argv.appendAssumeCapacity("-xc");
            for (defines) |def| argv.appendAssumeCapacity(try mem.concat(arena, u8, &.{ "-D", def }));
            argv.appendAssumeCapacity(def_path);

            assert(argv.items.len == argv.capacity);
            break :argv_blk argv.toOwnedSlice(arena) catch unreachable;
        };

        const result = try process.Child.run(.{
            .allocator = arena,
            .argv = argv,

            .max_output_bytes = 1024 * 1024,
        });
        if (result.stderr.len != 0) {
            std.debug.print("{s}\n", .{result.stderr});
            return error.ChildError;
        }
        if (result.term != .Exited) return error.ChildError;
        break :blk result.stdout;
    };

    var enum_fields = std.ArrayList([]const u8).init(arena);

    var lines = mem.tokenizeScalar(u8, preprocessed, '\n');
    while (lines.next()) |line| {
        try enum_fields.append(line);
    }

    return try enum_fields.toOwnedSlice();
}

const EnumField = struct {
    name: []const u8,
    value: ?u32 = null,
};

fn writeEnum(file: fs.File, enum_name: []const u8, enum_field: []const EnumField) !void {
    var writer = file.writer();

    try writer.print(
        \\pub const {s} = enum(u32) {{
        \\
    , .{enum_name});
    for (enum_field) |f| {
        if (f.name.len == 0) continue;

        if (ascii.isAlphabetic(f.name[0]) or f.name[0] == '_') {
            try writer.print("    {s}", .{f.name});
        } else {
            try writer.print("    @\"{s}\"", .{f.name});
        }

        if (f.value) |v| {
            try writer.print(" = {}", .{v});
        }
        try writer.writeAll(",\n");
    }
    try writer.writeAll(
        \\};
        \\
    );
}

fn llvmNameToZigName(arena: mem.Allocator, llvm_name: []const u8) ![]const u8 {
    const duped = try arena.dupe(u8, llvm_name);
    for (duped) |*byte| switch (byte.*) {
        '-', '.' => byte.* = '_',
        else => byte.* = ascii.toLower(byte.*),
    };
    return duped;
}
