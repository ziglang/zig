const std = @import("std");
const fs = std.fs;
const Allocator = std.mem.Allocator;
const print = std.debug.print;

pub fn main() anyerror!void {
    var arena_allocator = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    defer arena_allocator.deinit();
    const arena = arena_allocator.allocator();

    var args = try std.process.argsWithAllocator(arena);
    const arg0 = args.next().?;

    const opcodes_path = args.next() orelse usageAndExit(arg0, 0);
    const zig_path = args.next() orelse usageAndExit(arg0, 1);

    var descs = OpcodeDescList.init(arena);
    defer descs.deinit();
    var formats = OpcodeFormatList.init(arena);
    defer formats.deinit();

    var opcodes_dir = try fs.cwd().openDir(opcodes_path, .{ .iterate = true });
    defer opcodes_dir.close();
    var opcodes_iter = opcodes_dir.iterateAssumeFirstIteration();
    while (try opcodes_iter.next()) |opcodes_file| {
        if (opcodes_file.kind != .file) continue;
        if (!std.mem.endsWith(u8, opcodes_file.name, ".txt")) continue;

        // exclude LSX, LASX, LVZ, LBT for now
        if (std.mem.indexOf(u8, opcodes_file.name, "lvz") != null) continue;
        if (std.mem.indexOf(u8, opcodes_file.name, "lsx") != null) continue;
        if (std.mem.indexOf(u8, opcodes_file.name, "lasx") != null) continue;
        if (std.mem.indexOf(u8, opcodes_file.name, "lbt") != null) continue;

        print("Loading desc file: {s}\n", .{opcodes_file.name});

        const file = try opcodes_dir.openFile(opcodes_file.name, .{});
        defer file.close();
        try loadFromDescFile(&descs, arena, file);
    }
    std.mem.sort(OpcodeDesc, descs.items, false, struct {
        fn cmp(_: bool, lhs: OpcodeDesc, rhs: OpcodeDesc) bool {
            return std.mem.order(u8, lhs.name, rhs.name) == .lt;
        }
    }.cmp);

    print("Loaded {} instructions\n", .{descs.items.len});
    for (descs.items) |desc| {
        var format = desc.format;
        // wipe out register bank information, because they are the same formats for encoding
        inline for (&format) |*slot| {
            switch (slot.*) {
                else => {},
                .reg => |*reg| {
                    reg.class = .int;
                },
            }
        }
        try formats.put(format, .{});
    }
    print("Found {} formats\n", .{formats.count()});

    var zig_dir = try fs.cwd().openDir(zig_path, .{});
    defer zig_dir.close();
    const out_file = try zig_dir.createFile("src/arch/loongarch/encoding.zig", .{});
    defer out_file.close();
    const out_writer = out_file.writer();

    // TODO: include commit hash of loongarch-opcodes
    try out_writer.writeAll("// This file is auto-generated by tools/gen_loongarch_encoding.zig\n\n");
    try out_writer.writeAll(
        \\const Register = @import("bits.zig").Register;
        \\
        \\pub const OpCode = enum {
        \\
    );
    for (descs.items) |*desc| {
        const name_buf = try arena.dupe(u8, desc.name);
        defer arena.free(name_buf);
        std.mem.replaceScalar(u8, name_buf, '.', '_');

        if (std.zig.isValidId(name_buf)) {
            try out_writer.print("    {s},\n", .{name_buf});
        } else {
            try out_writer.print("    @\"{s}\",\n", .{name_buf});
        }
    }
    try out_writer.writeAll(
        \\
        \\    pub fn enc(opcode: OpCode) u32 {
        \\        return switch (opcode) {
        \\
    );
    for (descs.items) |*desc| {
        const name_buf = try arena.dupe(u8, desc.name);
        defer arena.free(name_buf);
        std.mem.replaceScalar(u8, name_buf, '.', '_');

        if (std.zig.isValidId(name_buf)) {
            try out_writer.print("            .{s}", .{name_buf});
        } else {
            try out_writer.print("            .@\"{s}\"", .{name_buf});
        }
        try out_writer.print(" => 0x{x:0>8},\n", .{desc.word});
    }
    try out_writer.writeAll(
        \\        };
        \\    }
        \\};
        \\
        \\pub const Data = union(enum) {
        \\
    );
    var format_iter1 = formats.keyIterator();
    while (format_iter1.next()) |format| {
        var format_buf = std.ArrayList(u8).init(arena);
        defer format_buf.deinit();
        try OpcodeDesc.stringifyFormat(format, format_buf.writer());
        const format_str = format_buf.items;
        if (std.mem.eql(u8, format_str, "EMPTY")) {
            try out_writer.writeAll(
                \\    EMPTY,
                \\
            );
        } else {
            try out_writer.print("    {s}: struct {{", .{format_str});
            if (format.len != 1) try out_writer.writeAll(" ");
            for (format, 0..) |slot, slot_i| {
                if (slot == .none) continue;
                if (slot_i != 0) try out_writer.writeAll(", ");
                switch (slot) {
                    .none => unreachable,
                    .reg => |_| {
                        try out_writer.writeAll("Register");
                    },
                    .imm => |imm| {
                        try out_writer.print("{}", .{imm});
                    },
                }
            }
            if (format.len != 1) try out_writer.writeAll(" ");
            try out_writer.writeAll("},\n");
        }
    }
    try out_writer.writeAll(
        \\
        \\    pub fn enc(self: Data) u32 {
        \\        return switch (self) {
        \\
    );
    var format_iter3 = formats.keyIterator();
    while (format_iter3.next()) |format| {
        var format_buf = std.ArrayList(u8).init(arena);
        defer format_buf.deinit();
        try OpcodeDesc.stringifyFormat(format, format_buf.writer());
        const format_str = format_buf.items;
        if (std.mem.eql(u8, format_str, "EMPTY")) {
            try out_writer.writeAll(
                \\            .EMPTY => 0,
                \\
            );
        } else {
            try out_writer.print("            .{s} => |data| ", .{format_str});
            for (format, 0..) |slot, slot_i| {
                if (slot == .none) continue;
                if (slot_i != 0) try out_writer.writeAll(" | ");
                switch (slot) {
                    .none => unreachable,
                    .reg => |reg| {
                        const reg_off = reg.index.offset();
                        if (reg_off == 0) {
                            try out_writer.print("data[{}].enc()", .{slot_i});
                        } else {
                            try out_writer.print("(@as(u32, data[{}].enc()) << {})", .{ slot_i, reg_off });
                        }
                    },
                    .imm => |imm| {
                        const imm_off = imm.index.offset();
                        if (imm_off == 0) {
                            try out_writer.print("@as(u32, @intCast(@as(u{}, @bitCast(data[{}]))))", .{ imm.length, slot_i });
                        } else {
                            try out_writer.print("(@as(u32, @as(u{}, @bitCast(data[{}]))) << {})", .{ imm.length, slot_i, imm_off });
                        }
                    },
                }
            }
            try out_writer.print(",\n", .{});
        }
    }
    try out_writer.writeAll(
        \\        };
        \\    }
        \\};
        \\
        \\pub const Format = @import("std").meta.Tag(Data);
        \\
        \\pub const Inst = struct {
        \\    opcode: OpCode,
        \\    data: Data,
        \\
    );
    for (descs.items) |*desc| {
        try out_writer.writeAll("\n");
        const name_buf = try arena.dupe(u8, desc.name);
        defer arena.free(name_buf);
        std.mem.replaceScalar(u8, name_buf, '.', '_');

        try out_writer.writeAll("    // Workaround https://github.com/ziglang/zig/issues/24127\n");
        if (std.zig.isValidId(name_buf)) {
            try out_writer.print("    pub noinline fn {s}(", .{name_buf});
        } else {
            try out_writer.print("    pub noinline fn @\"{s}\"(", .{name_buf});
        }
        for (desc.format, 0..) |slot, slot_i| {
            if (slot == .none) continue;
            if (slot_i != 0) try out_writer.writeAll(", ");
            switch (slot) {
                .none => unreachable,
                .reg => |_| {
                    try out_writer.print("f{}: Register", .{slot_i});
                },
                .imm => |imm| {
                    try out_writer.print("f{}: {}", .{ slot_i, imm });
                },
            }
        }
        try out_writer.writeAll(") Inst {\n        return .{ .opcode = ");
        if (std.zig.isValidId(name_buf)) {
            try out_writer.print(".{s}", .{name_buf});
        } else {
            try out_writer.print(".@\"{s}\"", .{name_buf});
        }

        var format_buf = std.ArrayList(u8).init(arena);
        defer format_buf.deinit();
        try OpcodeDesc.stringifyFormat(&desc.format, format_buf.writer());
        const format_str = format_buf.items;

        try out_writer.writeAll(", .data = ");
        if (std.mem.eql(u8, format_str, "EMPTY")) {
            try out_writer.writeAll(".EMPTY");
        } else {
            try out_writer.print(".{{ .{s} = .{{", .{format_str});
            if (desc.format[1] != .none) try out_writer.writeAll(" ");
            for (desc.format, 0..) |slot, slot_i| {
                if (slot == .none) continue;
                if (slot_i != 0) try out_writer.writeAll(", ");
                try out_writer.print("f{}", .{slot_i});
            }
            if (desc.format[1] != .none) try out_writer.writeAll(" ");
            try out_writer.writeAll("} }");
        }
        try out_writer.writeAll(" };\n    }\n");
    }
    try out_writer.writeAll(
        \\};
        \\
    );
}

fn usageAndExit(arg0: []const u8, code: u8) noreturn {
    const stderr = std.io.getStdErr();
    stderr.writer().print(
        \\Usage: {s} /path/loongarch-opcodes /path/zig
        \\
        \\Updates src/arch/loongarch/encoding.zig from https://github.com/loongson-community/loongarch-opcodes.git.
        \\
    , .{arg0}) catch std.process.exit(1);
    std.process.exit(code);
}

const OpcodeDescList = std.ArrayList(OpcodeDesc);
const OpcodeFormatList = std.AutoHashMap(OpcodeDesc.Format, struct {});

const OpcodeDesc = struct {
    word: u64,
    name: []u8,
    format: Format,

    pub const Format = [8]Slot;

    pub fn stringifyFormat(slots: *Format, writer: anytype) !void {
        var all_none = true;
        for (slots) |slot| {
            if (slot == .none) continue;
            all_none = false;
            switch (slot) {
                .none => unreachable,
                .reg => |reg| {
                    switch (reg.index) {
                        .d => try writer.print("D", .{}),
                        .j => try writer.print("J", .{}),
                        .k => try writer.print("K", .{}),
                        .a => try writer.print("A", .{}),
                        else => try writer.print("{}", .{reg.index}),
                    }
                },
                .imm => |imm| {
                    switch (imm.sign) {
                        .signed => try writer.print("S{}{}", .{ imm.index, imm.length }),
                        .unsigned => try writer.print("U{}{}", .{ imm.index, imm.length }),
                    }
                },
            }
        }
        if (all_none) try writer.writeAll("EMPTY");
    }

    const Slot = union(enum) {
        reg: struct {
            class: enum { int, fp, fcc, lbt_scratch, lsx, lasx },
            index: Index,
        },
        imm: struct {
            sign: std.builtin.Signedness,
            index: Index,
            length: u5,

            pub fn format(imm: @This(), comptime _: []const u8, _: std.fmt.FormatOptions, writer: anytype) !void {
                try writer.print("{c}{}", .{
                    @as(u8, switch (imm.sign) {
                        .signed => 'i',
                        .unsigned => 'u',
                    }),
                    imm.length,
                });
            }
        },
        none,

        pub fn format(ctx: Slot, comptime _: []const u8, _: std.fmt.FormatOptions, writer: anytype) !void {
            switch (ctx) {
                .none => try writer.print("none", .{}),
                .reg => |reg| {
                    try writer.print("reg({s})@{}", .{ @tagName(reg.class), reg.index });
                },
                .imm => |imm| {
                    try writer.print("imm({s})@{}:{}", .{ @tagName(imm.sign), imm.index, imm.length });
                },
            }
        }

        const Index = enum {
            // zig fmt: off
            d, j, k, a, m, n,
            // zig fmt: on

            pub fn offset(index: Index) u5 {
                return switch (index) {
                    .d => 0,
                    .j => 5,
                    .k => 10,
                    .a => 15,
                    .m => 16,
                    .n => 18,
                };
            }

            pub fn format(ctx: Index, comptime _: []const u8, _: std.fmt.FormatOptions, writer: anytype) !void {
                try writer.print("{s}", .{@tagName(ctx)});
            }
        };
    };
};

fn loadFromDescFile(list: *OpcodeDescList, allocator: Allocator, file: fs.File) !void {
    const reader = file.reader();

    var line_buf: [256]u8 = undefined;
    while (try reader.readUntilDelimiterOrEof(&line_buf, '\n')) |line_raw| {
        try parseOpcodeDesc(list, allocator, line_raw);
    }
}

fn parseOpcodeDesc(list: *OpcodeDescList, allocator: Allocator, line_raw: []const u8) !void {
    const line_trim = std.mem.trim(u8, line_raw, " \n");
    if (line_trim.len == 0) return;
    var line_split = std.mem.splitScalar(u8, line_trim, ' ');

    const word_str = line_split.next() orelse unreachable;
    const name_str = line_split.next() orelse return error.UnexpectedEol;
    while (line_split.peek()) |part| {
        if (part.len != 0) break;
        _ = line_split.next();
    }
    const format_str = line_split.next() orelse return error.UnexpectedEol;

    const word = try std.fmt.parseInt(u64, word_str, 16);
    const name = try allocator.dupe(u8, name_str);
    var desc = OpcodeDesc{
        .word = word,
        .name = name,
        .format = [1]OpcodeDesc.Slot{.none} ** 8,
    };

    print("  Instruction: {s} {s}\n", .{ name_str, format_str });
    var format_lexer = FormatLexer.init(format_str);
    try format_lexer.parse(&desc);
    for (&desc.format) |slot| {
        if (slot == .none) continue;
        print("      {}\n", .{slot});
    }

    try list.append(desc);
}

const FormatLexer = struct {
    buf: []const u8,

    pub fn init(desc: []const u8) FormatLexer {
        return .{ .buf = desc };
    }

    pub fn parse(self: *FormatLexer, desc: *OpcodeDesc) !void {
        if (std.mem.eql(u8, self.buf, "EMPTY")) return;
        var slot_i: u3 = 0;
        while (self.tryParse(FormatLexer.tryParseRegSlot)) |slot| {
            desc.format[slot_i] = slot;
            slot_i += 1;
        }
        while (self.tryParse(FormatLexer.tryParseImmSlots)) |slots| {
            for (slots) |slot| {
                if (slot == .none) continue;
                desc.format[slot_i] = slot;
                slot_i += 1;
            }
        }
        if (self.buf.len != 0) return error.UnexpectedRemaining;
    }

    fn nextChar(self: *FormatLexer) !u8 {
        if (self.buf.len == 0) return error.UnexpectedEnd;
        const ch = self.buf[0];
        self.buf = self.buf[1..];
        return ch;
    }

    pub fn tryParse(self: *FormatLexer, comptime func: anytype) ?(@typeInfo(@typeInfo(@TypeOf(func)).@"fn".return_type.?).error_union.payload) {
        const buf = self.buf;
        if (func(self) catch null) |result| {
            return result;
        } else {
            self.buf = buf;
            return null;
        }
    }

    pub fn tryParseRegSlot(self: *FormatLexer) !OpcodeDesc.Slot {
        switch (try self.nextChar()) {
            'D' => return .{ .reg = .{ .class = .int, .index = .d } },
            'J' => return .{ .reg = .{ .class = .int, .index = .j } },
            'K' => return .{ .reg = .{ .class = .int, .index = .k } },
            'A' => return .{ .reg = .{ .class = .int, .index = .a } },
            'F' => return .{ .reg = .{ .class = .fp, .index = try self.tryParseIndex() } },
            'C' => return .{ .reg = .{ .class = .fcc, .index = try self.tryParseIndex() } },
            'T' => return .{ .reg = .{ .class = .lbt_scratch, .index = try self.tryParseIndex() } },
            'V' => return .{ .reg = .{ .class = .lsx, .index = try self.tryParseIndex() } },
            'X' => return .{ .reg = .{ .class = .lasx, .index = try self.tryParseIndex() } },
            else => return error.UnknownRegSlot,
        }
    }

    pub fn tryParseImmSlots(self: *FormatLexer) ![8]OpcodeDesc.Slot {
        const signedness = try self.tryParseSignedness();

        var slots = [1]OpcodeDesc.Slot{.none} ** 8;
        var slot_i: u3 = 0;
        while (self.tryParse(FormatLexer.tryParseImmSlot)) |slot| {
            slots[slot_i] = slot;
            slots[slot_i].imm.sign = signedness;
            slot_i += 1;
        }
        return slots;
    }

    fn tryParseImmSlot(self: *FormatLexer) !OpcodeDesc.Slot {
        const index = try self.tryParseIndex();
        const length = try self.tryParseInt(u5);
        return .{ .imm = .{ .sign = undefined, .index = index, .length = length } };
    }

    pub fn tryParseIndex(self: *FormatLexer) !OpcodeDesc.Slot.Index {
        switch (try self.nextChar()) {
            'd' => return .d,
            'j' => return .j,
            'k' => return .k,
            'a' => return .a,
            'm' => return .m,
            'n' => return .n,
            else => return error.UnknownIndex,
        }
    }

    pub fn tryParseSignedness(self: *FormatLexer) !std.builtin.Signedness {
        return switch (try self.nextChar()) {
            'S' => .signed,
            'U' => .unsigned,
            else => return error.UnknownSignedness,
        };
    }

    pub fn tryParseInt(self: *FormatLexer, comptime T: type) !T {
        var len: usize = 0;
        while (true) {
            const ch = self.buf[len];
            if (ch < '0' or ch > '9') break;
            len += 1;
            if (len >= self.buf.len) break;
        }
        const str = self.buf[0..len];
        self.buf = self.buf[len..];
        return try std.fmt.parseInt(T, str, 10);
    }
};
