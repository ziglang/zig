<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <title>Documentation - The Zig Programming Language</title>
    <style type="text/css">
      body{
        background-color:#111;
        color: #bbb;
        font-family: sans-serif;
      }
      a {
        color: #88f;
        text-decoration: none;
      }
      table, th, td {
        border-collapse: collapse;
        border: 1px solid grey;
      }
      th, td {
        padding: 0.1em;
      }
      .t0_1, .t37, .t37_1 {
        font-weight: bold;
      }
      .t2_0 {
        color: grey;
      }
      .t31_1 {
        color: red;
      }
      .t32_1 {
        color: green;
      }
      .t36_1 {
        color: #0086b3;
      }
      .file {
        text-decoration: underline;
      }
      code {
        font-size: 12pt;
      }
      pre > code {
        display: block;
        overflow: auto;

        overflow-x: auto;
        padding: 0.5em;
        color: #ccc;
        background: #222;
      }
      .table-wrapper {
        width: 100%;
        overflow-y: auto;
      }

      .tok-kw {
          color: #eee;
          font-weight: bold;
      }
      .tok-str {
          color: #2e5;
      }
      .tok-builtin {
          color: #ff894c;
      }
      .tok-comment {
          color: #aa7;
          font-style: italic;
      }
      .tok-fn {
          color: #e33;
          font-weight: bold;
      }
      .tok-null {
          color: #ff8080;
      }
      .tok-number {
          color: #ff8080;
      }
      .tok-type {
          color: #68f;
          font-weight: bold;
      }

      /* Desktop */
      @media screen and (min-width: 56.25em) {
        #nav {
          width: 20em;
          height: 100%;
          position: fixed;
          overflow-y: scroll;
          left: 0;
          top: 0;
          padding-left: 1em;
        }
        #contents {
          max-width: 60em;
          padding-left: 22em;
          padding: 1em;
          padding-left: 24em;
        }
      }
      /* Mobile */
      @media screen and (max-width: 56.25em) {
        body, code {
          font-size: small;
        }
        #nav {
          border-bottom: 1px solid grey;
        }
      }
      h1 a, h2 a, h3 a, h4 a, h5 a {
        text-decoration: none;
        color: #aaa;
      }
      #nav a {
        color: #aaa;
        text-decoration: none;
      }
    </style>
  </head>
  <body>
    <div id="nav">
      <h3>Index</h3>
      {#nav#}
    </div>
    <div id="contents">
      {#header_open|Introduction#}
      <p>
      Zig is an open-source programming language designed for <strong>robustness</strong>,
      <strong>optimality</strong>, and <strong>clarity</strong>.
      </p>
      <ul>
        <li><strong>Robust</strong> - behavior is correct even for edge cases such as out of memory.</li>
        <li><strong>Optimal</strong> - write programs the best way they can behave and perform.</li>
        <li><strong>Clear</strong> - precisely communicate your intent to the compiler and other programmers. The language imposes a low overhead to reading code.</li>
      </ul>
      <p>
      Often the most efficient way to learn something new is to see examples, so
      this documentation shows how to use each of Zig's features. It is
      all on one page so you can search with your browser's search tool.
      </p>
      <p>
      If you search for something specific in this documentation and do not find it,
      please <a href="https://github.com/ziglang/www.ziglang.org/issues/new?title=I%20searched%20for%20___%20in%20the%20docs%20and%20didn%27t%20find%20it">file an issue</a> or <a href="https://webchat.freenode.net/?channels=%23zig">say something on IRC</a>.
      </p>
      <p>
      The code samples in this document are compiled and tested as part of the main test suite of Zig.
      This HTML document depends on no external files, so you can use it offline.
      </p>
      {#header_close#}
      {#header_open|Hello World#}

      {#code_begin|exe|hello#}
const std = @import("std");

pub fn main() !void {
    // If this program is run without stdout attached, exit with an error.
    var stdout_file = try std.io.getStdOut();
    // If this program encounters pipe failure when printing to stdout, exit
    // with an error.
    try stdout_file.write("Hello, world!\n");
}
      {#code_end#}
      <p>
      Usually you don't want to write to stdout. You want to write to stderr. And you
      don't care if it fails. It's more like a <em>warning message</em> that you want
      to emit. For that you can use a simpler API:
      </p>
      {#code_begin|exe|hello#}
const warn = @import("std").debug.warn;

pub fn main() void {
    warn("Hello, world!\n");
}
      {#code_end#}
      <p>
      Note that we also left off the {#syntax#}!{#endsyntax#} from the return type.
      In Zig, if your main function cannot fail, you must use the {#syntax#}void{#endsyntax#} return type.
      </p>
      {#see_also|Values|@import|Errors|Root Source File#}
      {#header_close#}
      {#header_open|Comments#}
      {#code_begin|test|comments#}
const assert = @import("std").debug.assert;

test "comments" {
    // Comments in Zig start with "//" and end at the next LF byte (end of line).
    // The below line is a comment, and won't be executed.

    //assert(false);

    const x = true;  // another comment
    assert(x);
}
      {#code_end#}
      <p>
      There are no multiline comments in Zig (e.g. like <code class="c">/* */</code>
      comments in C).  This helps allow Zig to have the property that each line
      of code can be tokenized out of context.
      </p>
      {#header_open|Doc comments#}
      <p>
      A doc comment is one that begins with exactly three slashes (i.e.
      {#syntax#}///{#endsyntax#} but not {#syntax#}////{#endsyntax#});
      multiple doc comments in a row are merged together to form a multiline
      doc comment.  The doc comment documents whatever immediately follows it.
      </p>
      {#code_begin|syntax|doc_comments#}
/// A structure for storing a timestamp, with nanosecond precision (this is a
/// multiline doc comment).
const Timestamp = struct {
    /// The number of seconds since the epoch (this is also a doc comment).
    seconds: i64,  // signed so we can represent pre-1970 (not a doc comment)
    /// The number of nanoseconds past the second (doc comment again).
    nanos: u32,

    /// Returns a `Timestamp` struct representing the Unix epoch; that is, the
    /// moment of 1970 Jan 1 00:00:00 UTC (this is a doc comment too).
    pub fn unixEpoch() Timestamp {
        return Timestamp{
            .seconds = 0,
            .nanos = 0,
        };
    }
};
      {#code_end#}
      <p>
      Doc comments are only allowed in certain places; eventually, it will
      become a compile error have a doc comment in an unexpected place, such as
      in the middle of an expression, or just before a non-doc comment.
      </p>
      {#header_close#}
      {#header_close#}
      {#header_open|Values#}
      {#code_begin|exe|values#}
const std = @import("std");
const warn = std.debug.warn;
const os = std.os;
const assert = std.debug.assert;

pub fn main() void {
    // integers
    const one_plus_one: i32 = 1 + 1;
    warn("1 + 1 = {}\n", one_plus_one);

    // floats
    const seven_div_three: f32 = 7.0 / 3.0;
    warn("7.0 / 3.0 = {}\n", seven_div_three);

    // boolean
    warn("{}\n{}\n{}\n",
        true and false,
        true or false,
        !true);
    
    // optional
    var optional_value: ?[]const u8 = null;
    assert(optional_value == null);

    warn("\noptional 1\ntype: {}\nvalue: {}\n",
        @typeName(@typeOf(optional_value)), optional_value);

    optional_value = "hi";
    assert(optional_value != null);

    warn("\noptional 2\ntype: {}\nvalue: {}\n",
        @typeName(@typeOf(optional_value)), optional_value);

    // error union
    var number_or_error: anyerror!i32 = error.ArgNotFound;

    warn("\nerror union 1\ntype: {}\nvalue: {}\n",
        @typeName(@typeOf(number_or_error)), number_or_error);
 
    number_or_error = 1234;

    warn("\nerror union 2\ntype: {}\nvalue: {}\n",
        @typeName(@typeOf(number_or_error)), number_or_error);
}
      {#code_end#}
      {#header_open|Primitive Types#}
      <div class="table-wrapper">
      <table>
        <tr>
          <th>
            Name
          </th>
          <th>
            C Equivalent
          </th>
          <th>
            Description
          </th>
        </tr>
        <tr>
            <td>{#syntax#}i8{#endsyntax#}</td>
          <td><code class="c">int8_t</code></td>
          <td>signed 8-bit integer</td>
        </tr>
        <tr>
            <td>{#syntax#}u8{#endsyntax#}</td>
          <td><code class="c">uint8_t</code></td>
          <td>unsigned 8-bit integer</td>
        </tr>
        <tr>
            <td>{#syntax#}i16{#endsyntax#}</td>
          <td><code class="c">int16_t</code></td>
          <td>signed 16-bit integer</td>
        </tr>
        <tr>
            <td>{#syntax#}u16{#endsyntax#}</td>
          <td><code class="c">uint16_t</code></td>
          <td>unsigned 16-bit integer</td>
        </tr>
        <tr>
            <td>{#syntax#}i32{#endsyntax#}</td>
          <td><code class="c">int32_t</code></td>
          <td>signed 32-bit integer</td>
        </tr>
        <tr>
            <td>{#syntax#}u32{#endsyntax#}</td>
          <td><code class="c">uint32_t</code></td>
          <td>unsigned 32-bit integer</td>
        </tr>
        <tr>
            <td>{#syntax#}i64{#endsyntax#}</td>
          <td><code class="c">int64_t</code></td>
          <td>signed 64-bit integer</td>
        </tr>
        <tr>
            <td>{#syntax#}u64{#endsyntax#}</td>
          <td><code class="c">uint64_t</code></td>
          <td>unsigned 64-bit integer</td>
        </tr>
        <tr>
            <td>{#syntax#}i128{#endsyntax#}</td>
          <td><code class="c">__int128</code></td>
          <td>signed 128-bit integer</td>
        </tr>
        <tr>
            <td>{#syntax#}u128{#endsyntax#}</td>
          <td><code class="c">unsigned __int128</code></td>
          <td>unsigned 128-bit integer</td>
        </tr>
        <tr>
            <td>{#syntax#}isize{#endsyntax#}</td>
          <td><code class="c">intptr_t</code></td>
          <td>signed pointer sized integer</td>
        </tr>
        <tr>
            <td>{#syntax#}usize{#endsyntax#}</td>
          <td><code class="c">uintptr_t</code></td>
          <td>unsigned pointer sized integer</td>
        </tr>

        <tr>
            <td>{#syntax#}c_short{#endsyntax#}</td>
          <td><code class="c">short</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
            <td>{#syntax#}c_ushort{#endsyntax#}</td>
          <td><code class="c">unsigned short</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
            <td>{#syntax#}c_int{#endsyntax#}</td>
          <td><code class="c">int</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
            <td>{#syntax#}c_uint{#endsyntax#}</td>
          <td><code class="c">unsigned int</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
            <td>{#syntax#}c_long{#endsyntax#}</td>
          <td><code class="c">long</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
            <td>{#syntax#}c_ulong{#endsyntax#}</td>
          <td><code class="c">unsigned long</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
            <td>{#syntax#}c_longlong{#endsyntax#}</td>
          <td><code class="c">long long</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
            <td>{#syntax#}c_ulonglong{#endsyntax#}</td>
          <td><code class="c">unsigned long long</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
            <td>{#syntax#}c_longdouble{#endsyntax#}</td>
          <td><code class="c">long double</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
            <td>{#syntax#}c_void{#endsyntax#}</td>
          <td><code class="c">void</code></td>
          <td>for ABI compatibility with C</td>
        </tr>

        <tr>
            <td>{#syntax#}f16{#endsyntax#}</td>
          <td><code class="c">_Float16</code></td>
          <td>16-bit floating point (10-bit mantissa) IEEE-754-2008 binary16</td>
        </tr>
        <tr>
            <td>{#syntax#}f32{#endsyntax#}</td>
          <td><code class="c">float</code></td>
          <td>32-bit floating point (23-bit mantissa) IEEE-754-2008 binary32</td>
        </tr>
        <tr>
            <td>{#syntax#}f64{#endsyntax#}</td>
          <td><code class="c">double</code></td>
          <td>64-bit floating point (52-bit mantissa) IEEE-754-2008 binary64</td>
        </tr>
        <tr>
            <td>{#syntax#}f128{#endsyntax#}</td>
            <td><code class="c">_Float128</code></td>
          <td>128-bit floating point (112-bit mantissa) IEEE-754-2008 binary128</td>
        </tr>
        <tr>
            <td>{#syntax#}bool{#endsyntax#}</td>
          <td><code class="c">bool</code></td>
          <td>{#syntax#}true{#endsyntax#} or {#syntax#}false{#endsyntax#}</td>
        </tr>
        <tr>
            <td>{#syntax#}void{#endsyntax#}</td>
          <td>(none)</td>
          <td>0 bit type</td>
        </tr>
        <tr>
            <td>{#syntax#}noreturn{#endsyntax#}</td>
          <td>(none)</td>
          <td>the type of {#syntax#}break{#endsyntax#}, {#syntax#}continue{#endsyntax#}, {#syntax#}return{#endsyntax#}, {#syntax#}unreachable{#endsyntax#}, and {#syntax#}while (true) {}{#endsyntax#}</td>
        </tr>
        <tr>
            <td>{#syntax#}type{#endsyntax#}</td>
          <td>(none)</td>
          <td>the type of types</td>
        </tr>
        <tr>
            <td>{#syntax#}anyerror{#endsyntax#}</td>
          <td>(none)</td>
          <td>an error code</td>
        </tr>
        <tr>
            <td>{#syntax#}comptime_int{#endsyntax#}</td>
          <td>(none)</td>
          <td>Only allowed for {#link|comptime#}-known values. The type of integer literals.</td>
        </tr>
        <tr>
            <td>{#syntax#}comptime_float{#endsyntax#}</td>
          <td>(none)</td>
          <td>Only allowed for {#link|comptime#}-known values. The type of float literals.</td>
        </tr>
      </table>
      </div>
      <p>
      In addition to the integer types above, arbitrary bit-width integers can be referenced by using
      an identifier of <code>i</code> or </code>u</code> followed by digits. For example, the identifier
      {#syntax#}i7{#endsyntax#} refers to a signed 7-bit integer. The maximum allowed bit-width of an
      integer type is {#syntax#}65535{#endsyntax#}.
      </p>
      {#see_also|Integers|Floats|void|Errors|@IntType#}
      {#header_close#}
      {#header_open|Primitive Values#}
      <div class="table-wrapper">
      <table>
        <tr>
          <th>
            Name
          </th>
          <th>
            Description
          </th>
        </tr>
        <tr>
            <td>{#syntax#}true{#endsyntax#} and {#syntax#}false{#endsyntax#}</td>
            <td>{#syntax#}bool{#endsyntax#} values</td>
        </tr>
        <tr>
            <td>{#syntax#}null{#endsyntax#}</td>
            <td>used to set an optional type to {#syntax#}null{#endsyntax#}</td>
        </tr>
        <tr>
            <td>{#syntax#}undefined{#endsyntax#}</td>
          <td>used to leave a value unspecified</td>
        </tr>
      </table>
      </div>
      {#see_also|Optionals|undefined#}
      {#header_close#}
      {#header_open|String Literals#}
      {#code_begin|test#}
const assert = @import("std").debug.assert;
const mem = @import("std").mem;

test "string literals" {
    // In Zig a string literal is an array of bytes.
    const normal_bytes = "hello";
    assert(@typeOf(normal_bytes) == [5]u8);
    assert(normal_bytes.len == 5);
    assert(normal_bytes[1] == 'e');
    assert('e' == '\x65');
    assert(mem.eql(u8, "hello", "h\x65llo"));

    // A C string literal is a null terminated pointer.
    const null_terminated_bytes = c"hello";
    assert(@typeOf(null_terminated_bytes) == [*]const u8);
    assert(null_terminated_bytes[5] == 0);
}
      {#code_end#}
      {#see_also|Arrays|Zig Test#}
      {#header_open|Escape Sequences#}
      <div class="table-wrapper">
      <table>
        <tr>
          <th>
            Escape Sequence
          </th>
          <th>
            Name
          </th>
        </tr>
        <tr>
            <td><code>\n</code></td>
          <td>Newline</td>
        </tr>
        <tr>
            <td><code>\r</code></td>
          <td>Carriage Return</td>
        </tr>
        <tr>
            <td><code>\t</code></td>
          <td>Tab</td>
        </tr>
        <tr>
            <td><code>\\</code></td>
          <td>Backslash</td>
        </tr>
        <tr>
            <td><code>\'</code></td>
          <td>Single Quote</td>
        </tr>
        <tr>
            <td><code>\"</code></td>
          <td>Double Quote</td>
        </tr>
        <tr>
            <td><code>\xNN</code></td>
          <td>hexadecimal 8-bit character code (2 digits)</td>
        </tr>
        <tr>
            <td><code>\uNNNN</code></td>
          <td>hexadecimal 16-bit Unicode character code UTF-8 encoded (4 digits)</td>
        </tr>
        <tr>
            <td><code>\UNNNNNN</code></td>
          <td>hexadecimal 24-bit Unicode character code UTF-8 encoded (6 digits)</td>
        </tr>
      </table>
      </div>
      <p>Note that the maximum valid Unicode point is {#syntax#}0x10ffff{#endsyntax#}.</p>
      {#header_close#}
      {#header_open|Multiline String Literals#}
      <p>
      Multiline string literals have no escapes and can span across multiple lines.
      To start a multiline string literal, use the {#syntax#}\\{#endsyntax#} token. Just like a comment,
      the string literal goes until the end of the line. The end of the line is
      not included in the string literal.
      However, if the next line begins with {#syntax#}\\{#endsyntax#} then a newline is appended and
      the string literal continues.
      </p>
      {#code_begin|syntax#}
const hello_world_in_c =
    \\#include <stdio.h>
    \\
    \\int main(int argc, char **argv) {
    \\    printf("hello world\n");
    \\    return 0;
    \\}
;
      {#code_end#}
      <p>
      For a multiline C string literal, prepend <code>c</code> to each {#syntax#}\\{#endsyntax#}:
      </p>
      {#code_begin|syntax#}
const c_string_literal =
    c\\#include <stdio.h>
    c\\
    c\\int main(int argc, char **argv) {
    c\\    printf("hello world\n");
    c\\    return 0;
    c\\}
;
      {#code_end#}
      <p>
      In this example the variable {#syntax#}c_string_literal{#endsyntax#} has type {#syntax#}[*]const u8{#endsyntax#} and
      has a terminating null byte.
      </p>
      {#see_also|@embedFile#}
      {#header_close#}
      {#header_close#}
      {#header_open|Assignment#}
      <p>Use the {#syntax#}const{#endsyntax#} keyword to assign a value to an identifier:</p>
      {#code_begin|test_err|cannot assign to constant#}
const x = 1234;

fn foo() void {
    // It works at global scope as well as inside functions.
    const y = 5678;

    // Once assigned, an identifier cannot be changed.
    y += 1;
}

test "assignment" {
    foo();
}
      {#code_end#}
      <p>{#syntax#}const{#endsyntax#} applies to all of the bytes that the identifier immediately addresses. {#link|Pointers#} have their own const-ness.</p>
      <p>If you need a variable that you can modify, use the {#syntax#}var{#endsyntax#} keyword:</p>
      {#code_begin|test#}
const assert = @import("std").debug.assert;

test "var" {
    var y: i32 = 5678;

    y += 1;

    assert(y == 5679);
}
      {#code_end#}
      <p>Variables must be initialized:</p>
      {#code_begin|test_err#}
test "initialization" {
    var x: i32;

    x = 1;
}
      {#code_end#}
      {#header_open|undefined#}
      <p>Use {#syntax#}undefined{#endsyntax#} to leave variables uninitialized:</p>
      {#code_begin|test#}
const assert = @import("std").debug.assert;

test "init with undefined" {
    var x: i32 = undefined;
    x = 1;
    assert(x == 1);
}
      {#code_end#}
      <p>
      {#syntax#}undefined{#endsyntax#} can be {#link|implicitly cast|Implicit Casts#} to any type.
          Once this happens, it is no longer possible to detect that the value is {#syntax#}undefined{#endsyntax#}.
              {#syntax#}undefined{#endsyntax#} means the value could be anything, even something that is nonsense
                  according to the type. Translated into English, {#syntax#}undefined{#endsyntax#} means "Not a meaningful
      value. Using this value would be a bug. The value will be unused, or overwritten before being used."
      </p>
      <p>
      In {#link|Debug#} mode, Zig writes {#syntax#}0xaa{#endsyntax#} bytes to undefined memory. This is to catch
      bugs early, and to help detect use of undefined memory in a debugger.
      </p>
      {#header_close#}
      {#header_close#}
      {#header_close#}
      {#header_open|Integers#}
      {#header_open|Integer Literals#}
      {#code_begin|syntax#}
const decimal_int = 98222;
const hex_int = 0xff;
const another_hex_int = 0xFF;
const octal_int = 0o755;
const binary_int = 0b11110000;
      {#code_end#}
      {#header_close#}
      {#header_open|Runtime Integer Values#}
      <p>
      Integer literals have no size limitation, and if any undefined behavior occurs,
      the compiler catches it.
      </p>
      <p>
      However, once an integer value is no longer known at compile-time, it must have a
      known size, and is vulnerable to undefined behavior.
      </p>
      {#code_begin|syntax#}
fn divide(a: i32, b: i32) i32 {
    return a / b;
}
      {#code_end#}
      <p>
      In this function, values {#syntax#}a{#endsyntax#} and {#syntax#}b{#endsyntax#} are known only at runtime,
      and thus this division operation is vulnerable to both integer overflow and
      division by zero.
      </p>
      <p>
      Operators such as {#syntax#}+{#endsyntax#} and {#syntax#}-{#endsyntax#} cause undefined behavior on
              integer overflow. Also available are operations such as {#syntax#}+%{#endsyntax#} and
                  {#syntax#}-%{#endsyntax#} which are defined to have wrapping arithmetic on all targets.
      </p>
      {#see_also|Integer Overflow|Division by Zero|Wrapping Operations#}
      {#header_close#}
      {#header_close#}
      {#header_open|Floats#}
      <p>Zig has the following floating point types:</p>
      <ul>
          <li>{#syntax#}f16{#endsyntax#} - IEEE-754-2008 binary16</li>
          <li>{#syntax#}f32{#endsyntax#} - IEEE-754-2008 binary32</li>
          <li>{#syntax#}f64{#endsyntax#} - IEEE-754-2008 binary64</li>
          <li>{#syntax#}f128{#endsyntax#} - IEEE-754-2008 binary128</li>
          <li>{#syntax#}c_longdouble{#endsyntax#} - matches <code class="c">long double</code> for the target C ABI</li>
      </ul>
      {#header_open|Float Literals#}
      <p>
      Float literals have type {#syntax#}comptime_float{#endsyntax#} which is guaranteed to hold at least all possible values
      that the largest other floating point type can hold. Float literals {#link|implicitly cast|Implicit Casts#} to any other type.
      </p>
      {#code_begin|syntax#}
const floating_point = 123.0E+77;
const another_float = 123.0;
const yet_another = 123.0e+77;

const hex_floating_point = 0x103.70p-5;
const another_hex_float = 0x103.70;
const yet_another_hex_float = 0x103.70P-5;
      {#code_end#}
      {#header_close#}
      {#header_open|Floating Point Operations#}
      <p>By default floating point operations use {#syntax#}Strict{#endsyntax#} mode,
          but you can switch to {#syntax#}Optimized{#endsyntax#} mode on a per-block basis:</p>
      {#code_begin|obj|foo#}
      {#code_release_fast#}
const builtin = @import("builtin");
const big = f64(1 << 40);

export fn foo_strict(x: f64) f64 {
    return x + big - big;
}

export fn foo_optimized(x: f64) f64 {
    @setFloatMode(builtin.FloatMode.Optimized);
    return x + big - big;
}
      {#code_end#}
      <p>For this test we have to separate code into two object files -
      otherwise the optimizer figures out all the values at compile-time,
      which operates in strict mode.</p>
      {#code_begin|exe|float_mode#}
      {#code_link_object|foo#}
const warn = @import("std").debug.warn;

extern fn foo_strict(x: f64) f64;
extern fn foo_optimized(x: f64) f64;

pub fn main() void {
    const x = 0.001;
    warn("optimized = {}\n", foo_optimized(x));
    warn("strict = {}\n", foo_strict(x));
}
      {#code_end#}
      {#see_also|@setFloatMode|Division by Zero#}
      {#header_close#}
      {#header_close#}
      {#header_open|Operators#}
      <p>
      There is no operator overloading. When you see an operator in Zig, you know that
      it is doing something from this table, and nothing else.
      </p>
      {#header_open|Table of Operators#}
      <div class="table-wrapper">
      <table>
        <tr>
          <th>
            Syntax
          </th>
          <th>
            Relevant Types
          </th>
          <th>
            Description
          </th>
          <th>
            Example
          </th>
        </tr>
        <tr>
          <td><pre>{#syntax#}a + b
a += b{#endsyntax#}</pre></td>
          <td>
            <ul>
              <li>{#link|Integers#}</li>
              <li>{#link|Floats#}</li>
            </ul>
          </td>
          <td>Addition.
            <ul>
              <li>Can cause {#link|overflow|Default Operations#} for integers.</li>
              <li>Invokes {#link|Peer Type Resolution#} for the operands.</li>
              <li>See also {#link|@addWithOverflow#}.</li>
            </ul>
          </td>
          <td>
            <pre>{#syntax#}2 + 5 == 7{#endsyntax#}</pre>
          </td>
        </tr>
        <tr>
          <td><pre>{#syntax#}a +% b
a +%= b{#endsyntax#}</pre></td>
          <td>
            <ul>
              <li>{#link|Integers#}</li>
            </ul>
          </td>
          <td>Wrapping Addition.
            <ul>
              <li>Guaranteed to have twos-complement wrapping behavior.</li>
              <li>Invokes {#link|Peer Type Resolution#} for the operands.</li>
              <li>See also {#link|@addWithOverflow#}.</li>
            </ul>
          </td>
          <td>
            <pre>{#syntax#}u32(std.math.maxInt(u32)) +% 1 == 0{#endsyntax#}</pre>
          </td>
        </tr>
        <tr>
          <td><pre>{#syntax#}a - b
a -= b{#endsyntax#}</pre></td>
          <td>
            <ul>
              <li>{#link|Integers#}</li>
              <li>{#link|Floats#}</li>
            </ul>
          </td>
          <td>Subtraction.
            <ul>
              <li>Can cause {#link|overflow|Default Operations#} for integers.</li>
              <li>Invokes {#link|Peer Type Resolution#} for the operands.</li>
              <li>See also {#link|@subWithOverflow#}.</li>
            </ul>
          </td>
          <td>
            <pre>{#syntax#}2 - 5 == -3{#endsyntax#}</pre>
          </td>
        </tr>
        <tr>
          <td><pre>{#syntax#}a -% b
a -%= b{#endsyntax#}</pre></td>
          <td>
            <ul>
              <li>{#link|Integers#}</li>
            </ul>
          </td>
          <td>Wrapping Subtraction.
            <ul>
              <li>Guaranteed to have twos-complement wrapping behavior.</li>
              <li>Invokes {#link|Peer Type Resolution#} for the operands.</li>
              <li>See also {#link|@subWithOverflow#}.</li>
            </ul>
          </td>
          <td>
            <pre>{#syntax#}u32(0) -% 1 == std.math.maxInt(u32){#endsyntax#}</pre>
          </td>
        </tr>
        <tr>
          <td><pre>{#syntax#}-a{#endsyntax#}</pre></td>
          <td>
            <ul>
              <li>{#link|Integers#}</li>
              <li>{#link|Floats#}</li>
            </ul>
          </td>
          <td>
            Negation.
            <ul>
              <li>Can cause {#link|overflow|Default Operations#} for integers.</li>
            </ul>
          </td>
          <td>
            <pre>{#syntax#}-1 == 0 - 1{#endsyntax#}</pre>
          </td>
        </tr>
        <tr>
          <td><pre>{#syntax#}-%a{#endsyntax#}</pre></td>
          <td>
            <ul>
              <li>{#link|Integers#}</li>
            </ul>
          </td>
          <td>
            Wrapping Negation.
            <ul>
              <li>Guaranteed to have twos-complement wrapping behavior.</li>
            </ul>
          </td>
          <td>
            <pre>{#syntax#}-%i32(std.math.minInt(i32)) == std.math.minInt(i32){#endsyntax#}</pre>
          </td>
        </tr>
        <tr>
          <td><pre>{#syntax#}a * b
a *= b{#endsyntax#}</pre></td>
          <td>
            <ul>
              <li>{#link|Integers#}</li>
              <li>{#link|Floats#}</li>
            </ul>
          </td>
          <td>Multiplication.
            <ul>
              <li>Can cause {#link|overflow|Default Operations#} for integers.</li>
              <li>Invokes {#link|Peer Type Resolution#} for the operands.</li>
              <li>See also {#link|@mulWithOverflow#}.</li>
            </ul>
          </td>
          <td>
            <pre>{#syntax#}2 * 5 == 10{#endsyntax#}</pre>
          </td>
        </tr>
        <tr>
          <td><pre>{#syntax#}a *% b
a *%= b{#endsyntax#}</pre></td>
          <td>
            <ul>
              <li>{#link|Integers#}</li>
            </ul>
          </td>
          <td>Wrapping Multiplication.
            <ul>
              <li>Guaranteed to have twos-complement wrapping behavior.</li>
              <li>Invokes {#link|Peer Type Resolution#} for the operands.</li>
              <li>See also {#link|@mulWithOverflow#}.</li>
            </ul>
          </td>
          <td>
            <pre>{#syntax#}u8(200) *% 2 == 144{#endsyntax#}</pre>
          </td>
        </tr>
        <tr>
          <td><pre>{#syntax#}a / b
a /= b{#endsyntax#}</pre></td>
          <td>
            <ul>
              <li>{#link|Integers#}</li>
              <li>{#link|Floats#}</li>
            </ul>
          </td>
          <td>Division.
            <ul>
              <li>Can cause {#link|overflow|Default Operations#} for integers.</li>
              <li>Can cause {#link|Division by Zero#} for integers.</li>
              <li>Can cause {#link|Division by Zero#} for floats in {#link|FloatMode.Optimized Mode|Floating Point Operations#}.</li>
              <li>For non-compile-time-known signed integers, must use
                {#link|@divTrunc#},
                {#link|@divFloor#}, or
                {#link|@divExact#} instead of {#syntax#}/{#endsyntax#}.
              </li>
              <li>Invokes {#link|Peer Type Resolution#} for the operands.</li>
            </ul>
          </td>
          <td>
            <pre>{#syntax#}10 / 5 == 2{#endsyntax#}</pre>
          </td>
        </tr>
        <tr>
          <td><pre>{#syntax#}a % b
a %= b{#endsyntax#}</pre></td>
          <td>
            <ul>
              <li>{#link|Integers#}</li>
              <li>{#link|Floats#}</li>
            </ul>
          </td>
          <td>Remainder Division.
            <ul>
              <li>Can cause {#link|Division by Zero#} for integers.</li>
              <li>Can cause {#link|Division by Zero#} for floats in {#link|FloatMode.Optimized Mode|Floating Point Operations#}.</li>
              <li>For non-compile-time-known signed integers, must use
                {#link|@rem#} or
                {#link|@mod#} instead of {#syntax#}%{#endsyntax#}.
              </li>
              <li>Invokes {#link|Peer Type Resolution#} for the operands.</li>
            </ul>
          </td>
          <td>
            <pre>{#syntax#}10 % 3 == 1{#endsyntax#}</pre>
          </td>
        </tr>
        <tr>
          <td><pre>{#syntax#}a << b
a <<= b{#endsyntax#}</pre></td>
          <td>
            <ul>
              <li>{#link|Integers#}</li>
            </ul>
          </td>
          <td>Bit Shift Left.
            <ul>
                <li>{#syntax#}b{#endsyntax#} must be {#link|comptime-known|comptime#} or have a type with log2 number of bits as {#syntax#}a{#endsyntax#}.</li>
              <li>See also {#link|@shlExact#}.</li>
              <li>See also {#link|@shlWithOverflow#}.</li>
            </ul>
          </td>
          <td>
            <pre>{#syntax#}1 << 8 == 256{#endsyntax#}</pre>
          </td>
        </tr>
        <tr>
          <td><pre>{#syntax#}a >> b
a >>= b{#endsyntax#}</pre></td>
          <td>
            <ul>
              <li>{#link|Integers#}</li>
            </ul>
          </td>
          <td>Bit Shift Right.
            <ul>
                <li>{#syntax#}b{#endsyntax#} must be {#link|comptime-known|comptime#} or have a type with log2 number of bits as {#syntax#}a{#endsyntax#}.</li>
              <li>See also {#link|@shrExact#}.</li>
            </ul>
          </td>
          <td>
            <pre>{#syntax#}10 >> 1 == 5{#endsyntax#}</pre>
          </td>
        </tr>
        <tr>
          <td><pre>{#syntax#}a & b
a &= b{#endsyntax#}</pre></td>
          <td>
            <ul>
              <li>{#link|Integers#}</li>
            </ul>
          </td>
          <td>Bitwise AND.
            <ul>
              <li>Invokes {#link|Peer Type Resolution#} for the operands.</li>
            </ul>
          </td>
          <td>
            <pre>{#syntax#}0b011 & 0b101 == 0b001{#endsyntax#}</pre>
          </td>
        </tr>
        <tr>
          <td><pre>{#syntax#}a | b
a |= b{#endsyntax#}</pre></td>
          <td>
            <ul>
              <li>{#link|Integers#}</li>
            </ul>
          </td>
          <td>Bitwise OR.
            <ul>
              <li>Invokes {#link|Peer Type Resolution#} for the operands.</li>
            </ul>
          </td>
          <td>
            <pre>{#syntax#}0b010 | 0b100 == 0b110{#endsyntax#}</pre>
          </td>
        </tr>
        <tr>
          <td><pre>{#syntax#}a ^ b
a ^= b{#endsyntax#}</pre></td>
          <td>
            <ul>
              <li>{#link|Integers#}</li>
            </ul>
          </td>
          <td>Bitwise XOR.
            <ul>
              <li>Invokes {#link|Peer Type Resolution#} for the operands.</li>
            </ul>
          </td>
          <td>
            <pre>{#syntax#}0b011 ^ 0b101 == 0b110{#endsyntax#}</pre>
          </td>
        </tr>
        <tr>
          <td><pre>{#syntax#}~a{#endsyntax#}</pre></td>
          <td>
            <ul>
              <li>{#link|Integers#}</li>
            </ul>
          </td>
          <td>
            Bitwise NOT.
          </td>
          <td>
            <pre>{#syntax#}~u8(0b0101111) == 0b1010000{#endsyntax#}</pre>
          </td>
        </tr>
        <tr>
          <td><pre>{#syntax#}a orelse b{#endsyntax#}</pre></td>
          <td>
            <ul>
              <li>{#link|Optionals#}</li>
            </ul>
          </td>
          <td>If {#syntax#}a{#endsyntax#} is {#syntax#}null{#endsyntax#},
                      returns {#syntax#}b{#endsyntax#} ("default value"),
                          otherwise returns the unwrapped value of {#syntax#}a{#endsyntax#}.
                              Note that {#syntax#}b{#endsyntax#} may be a value of type {#link|noreturn#}.
          </td>
          <td>
            <pre>{#syntax#}const value: ?u32 = null;
const unwrapped = value orelse 1234;
unwrapped == 1234{#endsyntax#}</pre>
          </td>
        </tr>
        <tr>
          <td><pre>{#syntax#}a.?{#endsyntax#}</pre></td>
          <td>
            <ul>
              <li>{#link|Optionals#}</li>
            </ul>
          </td>
          <td>
            Equivalent to:
            <pre>{#syntax#}a orelse unreachable{#endsyntax#}</pre>
          </td>
          <td>
            <pre>{#syntax#}const value: ?u32 = 5678;
value.? == 5678{#endsyntax#}</pre>
          </td>
        </tr>
        <tr>
          <td><pre>{#syntax#}a catch b
a catch |err| b{#endsyntax#}</pre></td>
          <td>
            <ul>
              <li>{#link|Error Unions|Errors#}</li>
            </ul>
          </td>
          <td>If {#syntax#}a{#endsyntax#} is an {#syntax#}error{#endsyntax#},
                      returns {#syntax#}b{#endsyntax#} ("default value"),
                          otherwise returns the unwrapped value of {#syntax#}a{#endsyntax#}.
                              Note that {#syntax#}b{#endsyntax#} may be a value of type {#link|noreturn#}.
                                  {#syntax#}err{#endsyntax#} is the {#syntax#}error{#endsyntax#} and is in scope of the expression {#syntax#}b{#endsyntax#}.
          </td>
          <td>
            <pre>{#syntax#}const value: anyerror!u32 = error.Broken;
const unwrapped = value catch 1234;
unwrapped == 1234{#endsyntax#}</pre>
          </td>
        </tr>
        <tr>
          <td><pre>{#syntax#}a and b{#endsyntax#}</pre></td>
          <td>
            <ul>
              <li>{#link|bool|Primitive Types#}</li>
            </ul>
          </td>
          <td>
              If {#syntax#}a{#endsyntax#} is {#syntax#}false{#endsyntax#}, returns {#syntax#}false{#endsyntax#}
                          without evaluating {#syntax#}b{#endsyntax#}. Otherwise, returns {#syntax#}b{#endsyntax#}.
          </td>
          <td>
            <pre>{#syntax#}false and true == false{#endsyntax#}</pre>
          </td>
        </tr>
        <tr>
          <td><pre>{#syntax#}a or b{#endsyntax#}</pre></td>
          <td>
            <ul>
              <li>{#link|bool|Primitive Types#}</li>
            </ul>
          </td>
          <td>
              If {#syntax#}a{#endsyntax#} is {#syntax#}true{#endsyntax#}, returns {#syntax#}true{#endsyntax#}
                          without evaluating {#syntax#}b{#endsyntax#}. Otherwise, returns {#syntax#}b{#endsyntax#}.
          </td>
          <td>
            <pre>{#syntax#}false or true == true{#endsyntax#}</pre>
          </td>
        </tr>
        <tr>
          <td><pre>{#syntax#}!a{#endsyntax#}</pre></td>
          <td>
            <ul>
              <li>{#link|bool|Primitive Types#}</li>
            </ul>
          </td>
          <td>
            Boolean NOT.
          </td>
          <td>
            <pre>{#syntax#}!false == true{#endsyntax#}</pre>
          </td>
        </tr>
        <tr>
          <td><pre>{#syntax#}a == b{#endsyntax#}</pre></td>
          <td>
            <ul>
              <li>{#link|Integers#}</li>
              <li>{#link|Floats#}</li>
              <li>{#link|bool|Primitive Types#}</li>
              <li>{#link|type|Primitive Types#}</li>
            </ul>
          </td>
          <td>
              Returns {#syntax#}true{#endsyntax#} if a and b are equal, otherwise returns {#syntax#}false{#endsyntax#}.
            Invokes {#link|Peer Type Resolution#} for the operands.
          </td>
          <td>
            <pre>{#syntax#}(1 == 1) == true{#endsyntax#}</pre>
          </td>
        </tr>
        <tr>
          <td><pre>{#syntax#}a == null{#endsyntax#}</pre></td>
          <td>
            <ul>
              <li>{#link|Optionals#}</li>
            </ul>
          </td>
          <td>
              Returns {#syntax#}true{#endsyntax#} if a is {#syntax#}null{#endsyntax#}, otherwise returns {#syntax#}false{#endsyntax#}.
          </td>
          <td>
            <pre>{#syntax#}const value: ?u32 = null;
value == null{#endsyntax#}</pre>
          </td>
        </tr>
        <tr>
          <td><pre>{#syntax#}a != b{#endsyntax#}</pre></td>
          <td>
            <ul>
              <li>{#link|Integers#}</li>
              <li>{#link|Floats#}</li>
              <li>{#link|bool|Primitive Types#}</li>
              <li>{#link|type|Primitive Types#}</li>
            </ul>
          </td>
          <td>
              Returns {#syntax#}false{#endsyntax#} if a and b are equal, otherwise returns {#syntax#}true{#endsyntax#}.
            Invokes {#link|Peer Type Resolution#} for the operands.
          </td>
          <td>
            <pre>{#syntax#}(1 != 1) == false{#endsyntax#}</pre>
          </td>
        </tr>
        <tr>
          <td><pre>{#syntax#}a > b{#endsyntax#}</pre></td>
          <td>
            <ul>
              <li>{#link|Integers#}</li>
              <li>{#link|Floats#}</li>
            </ul>
          </td>
          <td>
              Returns {#syntax#}true{#endsyntax#} if a is greater than b, otherwise returns {#syntax#}false{#endsyntax#}.
            Invokes {#link|Peer Type Resolution#} for the operands.
          </td>
          <td>
            <pre>{#syntax#}(2 > 1) == true{#endsyntax#}</pre>
          </td>
        </tr>
        <tr>
          <td><pre>{#syntax#}a >= b{#endsyntax#}</pre></td>
          <td>
            <ul>
              <li>{#link|Integers#}</li>
              <li>{#link|Floats#}</li>
            </ul>
          </td>
          <td>
              Returns {#syntax#}true{#endsyntax#} if a is greater than or equal to b, otherwise returns {#syntax#}false{#endsyntax#}.
            Invokes {#link|Peer Type Resolution#} for the operands.
          </td>
          <td>
            <pre>{#syntax#}(2 >= 1) == true{#endsyntax#}</pre>
          </td>
        </tr>
        <tr>
          <td><pre>{#syntax#}a < b{#endsyntax#}</pre></td>
          <td>
            <ul>
              <li>{#link|Integers#}</li>
              <li>{#link|Floats#}</li>
            </ul>
          </td>
          <td>
              Returns {#syntax#}true{#endsyntax#} if a is less than b, otherwise returns {#syntax#}false{#endsyntax#}.
            Invokes {#link|Peer Type Resolution#} for the operands.
          </td>
          <td>
            <pre>{#syntax#}(1 < 2) == true{#endsyntax#}></pre>
          </td>
        </tr>
        <tr>
          <td><pre>{#syntax#}a <= b{#endsyntax#}</pre></td>
          <td>
            <ul>
              <li>{#link|Integers#}</li>
              <li>{#link|Floats#}</li>
            </ul>
          </td>
          <td>
              Returns {#syntax#}true{#endsyntax#} if a is less than or equal to b, otherwise returns {#syntax#}false{#endsyntax#}.
            Invokes {#link|Peer Type Resolution#} for the operands.
          </td>
          <td>
            <pre>{#syntax#}(1 <= 2) == true{#endsyntax#}</pre>
          </td>
        </tr>
        <tr>
          <td><pre>{#syntax#}a ++ b{#endsyntax#}</pre></td>
          <td>
            <ul>
              <li>{#link|Arrays#}</li>
            </ul>
          </td>
          <td>
            Array concatenation.
            <ul>
                <li>Only available when {#syntax#}a{#endsyntax#} and {#syntax#}b{#endsyntax#} are {#link|compile-time known|comptime#}.
            </ul>
          </td>
          <td>
            <pre>{#syntax#}const mem = @import("std").mem;
const array1 = []u32{1,2};
const array2 = []u32{3,4};
const together = array1 ++ array2;
mem.eql(u32, together, []u32{1,2,3,4}){#endsyntax#}</pre>
          </td>
        </tr>
        <tr>
          <td><pre>{#syntax#}a ** b{#endsyntax#}</pre></td>
          <td>
            <ul>
              <li>{#link|Arrays#}</li>
            </ul>
          </td>
          <td>
            Array multiplication.
            <ul>
                <li>Only available when {#syntax#}a{#endsyntax#} and {#syntax#}b{#endsyntax#} are {#link|compile-time known|comptime#}.
            </ul>
          </td>
          <td>
            <pre>{#syntax#}const mem = @import("std").mem;
const pattern = "ab" ** 3;
mem.eql(u8, pattern, "ababab"){#endsyntax#}</pre>
          </td>
        </tr>
        <tr>
          <td><pre>{#syntax#}a.*{#endsyntax#}</pre></td>
          <td>
            <ul>
              <li>{#link|Pointers#}</li>
            </ul>
          </td>
          <td>
            Pointer dereference.
          </td>
          <td>
            <pre>{#syntax#}const x: u32 = 1234;
const ptr = &x;
x.* == 1234{#endsyntax#}</pre>
          </td>
        </tr>
        <tr>
          <td><pre>{#syntax#}&a{#endsyntax#}</pre></td>
          <td>
            All types
          </td>
          <td>
            Address of.
          </td>
          <td>
            <pre>{#syntax#}const x: u32 = 1234;
const ptr = &x;
x.* == 1234{#endsyntax#}</pre>
          </td>
        </tr>
        <tr>
          <td><pre>{#syntax#}a || b{#endsyntax#}</pre></td>
          <td>
            <ul>
              <li>{#link|Error Set Type#}</li>
            </ul>
          </td>
          <td>
              {#link|Merging Error Sets#}
          </td>
          <td>
            <pre>{#syntax#}const A = error{One};
const B = error{Two};
(A || B) == error{One, Two}{#endsyntax#}</pre>
          </td>
        </tr>
      </table>
      </div>
      {#header_close#}
      {#header_open|Precedence#}
      <pre>{#syntax#}x() x[] x.y
a!b
!x -x -%x ~x &x ?x
x{} x.* x.?
! * / % ** *% ||
+ - ++ +% -%
<< >>
&
^
|
== != < > <= >=
and
or
orelse catch
= *= /= %= += -= <<= >>= &= ^= |={#endsyntax#}</pre>
      {#header_close#}
      {#header_close#}
      {#header_open|Arrays#}
      {#code_begin|test|arrays#}
const assert = @import("std").debug.assert;
const mem = @import("std").mem;

// array literal
const message = []u8{ 'h', 'e', 'l', 'l', 'o' };

// get the size of an array
comptime {
    assert(message.len == 5);
}

// a string literal is an array literal
const same_message = "hello";

comptime {
    assert(mem.eql(u8, message, same_message));
    assert(@typeOf(message) == @typeOf(same_message));
}

test "iterate over an array" {
    var sum: usize = 0;
    for (message) |byte| {
        sum += byte;
    }
    assert(sum == usize('h') + usize('e') + usize('l') * 2 + usize('o'));
}

// modifiable array
var some_integers: [100]i32 = undefined;

test "modify an array" {
    for (some_integers) |*item, i| {
        item.* = @intCast(i32, i);
    }
    assert(some_integers[10] == 10);
    assert(some_integers[99] == 99);
}

// array concatenation works if the values are known
// at compile time
const part_one = []i32{ 1, 2, 3, 4 };
const part_two = []i32{ 5, 6, 7, 8 };
const all_of_it = part_one ++ part_two;
comptime {
    assert(mem.eql(i32, all_of_it, []i32{ 1, 2, 3, 4, 5, 6, 7, 8 }));
}

// remember that string literals are arrays
const hello = "hello";
const world = "world";
const hello_world = hello ++ " " ++ world;
comptime {
    assert(mem.eql(u8, hello_world, "hello world"));
}

// ** does repeating patterns
const pattern = "ab" ** 3;
comptime {
    assert(mem.eql(u8, pattern, "ababab"));
}

// initialize an array to zero
const all_zero = []u16{0} ** 10;

comptime {
    assert(all_zero.len == 10);
    assert(all_zero[5] == 0);
}

// use compile-time code to initialize an array
var fancy_array = init: {
    var initial_value: [10]Point = undefined;
    for (initial_value) |*pt, i| {
        pt.* = Point{
            .x = @intCast(i32, i),
            .y = @intCast(i32, i) * 2,
        };
    }
    break :init initial_value;
};
const Point = struct {
    x: i32,
    y: i32,
};

test "compile-time array initalization" {
    assert(fancy_array[4].x == 4);
    assert(fancy_array[4].y == 8);
}

// call a function to initialize an array
var more_points = []Point{makePoint(3)} ** 10;
fn makePoint(x: i32) Point {
    return Point{
        .x = x,
        .y = x * 2,
    };
}
test "array initialization with function calls" {
    assert(more_points[4].x == 3);
    assert(more_points[4].y == 6);
    assert(more_points.len == 10);
}
      {#code_end#}
      {#see_also|for|Slices#}
      {#header_close#}
      {#header_open|Pointers#}
      <p>
      Zig has two kinds of pointers:
      </p>
      <ul>
          <li>{#syntax#}*T{#endsyntax#} - pointer to exactly one item.
            <ul>
              <li>Supports deref syntax: {#syntax#}ptr.*{#endsyntax#}</li>
            </ul>
          </li>
          <li>{#syntax#}[*]T{#endsyntax#} - pointer to unknown number of items.
            <ul>
              <li>Supports index syntax: {#syntax#}ptr[i]{#endsyntax#}</li>
              <li>Supports slice syntax: {#syntax#}ptr[start..end]{#endsyntax#}</li>
              <li>Supports pointer arithmetic: {#syntax#}ptr + x{#endsyntax#}, {#syntax#}ptr - x{#endsyntax#}</li>
              <li>{#syntax#}T{#endsyntax#} must have a known size, which means that it cannot be
              {#syntax#}c_void{#endsyntax#} or any other {#link|@OpaqueType#}.</li>
            </ul>
          </li>
      </ul>
      <p>These types are closely related to {#link|Arrays#} and {#link|Slices#}:</p>
        <ul>
            <li>{#syntax#}*[N]T{#endsyntax#} - pointer to N items, same as single-item pointer to array.
            <ul>
                <li>Supports index syntax: {#syntax#}array_ptr[i]{#endsyntax#}</li>
                <li>Supports slice syntax: {#syntax#}array_ptr[start..end]{#endsyntax#}</li>
                <li>Supports len property: {#syntax#}array_ptr.len{#endsyntax#}</li>
            </ul>
            </li>
        </ul>
        <ul>
            <li>{#syntax#}[]T{#endsyntax#} - pointer to runtime-known number of items.
            <ul>
                <li>Supports index syntax: {#syntax#}slice[i]{#endsyntax#}</li>
                <li>Supports slice syntax: {#syntax#}slice[start..end]{#endsyntax#}</li>
                <li>Supports len property: {#syntax#}slice.len{#endsyntax#}</li>
            </ul>
            </li>
        </ul>
        <p>Use {#syntax#}&x{#endsyntax#} to obtain a single-item pointer:</p>
        {#code_begin|test#}
const assert = @import("std").debug.assert;

test "address of syntax" {
    // Get the address of a variable:
    const x: i32 = 1234;
    const x_ptr = &x;

    // Deference a pointer:
    assert(x_ptr.* == 1234);

    // When you get the address of a const variable, you get a const pointer to a single item.
    assert(@typeOf(x_ptr) == *const i32);

    // If you want to mutate the value, you'd need an address of a mutable variable:
    var y: i32 = 5678;
    const y_ptr = &y;
    assert(@typeOf(y_ptr) == *i32);
    y_ptr.* += 1;
    assert(y_ptr.* == 5679);
}

test "pointer array access" {
    // Taking an address of an individual element gives a
    // pointer to a single item. This kind of pointer
    // does not support pointer arithmetic.
    var array = []u8{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
    const ptr = &array[2];
    assert(@typeOf(ptr) == *u8);

    assert(array[2] == 3);
    ptr.* += 1;
    assert(array[2] == 4);
}
      {#code_end#}
      <p>
        In Zig, we prefer slices over pointers to null-terminated arrays.
        You can turn an array or pointer into a slice using slice syntax.
      </p>
      <p>
        Slices have bounds checking and are therefore protected
        against this kind of undefined behavior. This is one reason
        we prefer slices to pointers.
      </p>
      {#code_begin|test#}
const assert = @import("std").debug.assert;

test "pointer slicing" {
    var array = []u8{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
    const slice = array[2..4];
    assert(slice.len == 2);

    assert(array[3] == 4);
    slice[1] += 1;
    assert(array[3] == 5);
}
      {#code_end#}
      <p>Pointers work at compile-time too, as long as the code does not depend on 
      an undefined memory layout:</p>
      {#code_begin|test#}
const assert = @import("std").debug.assert;

test "comptime pointers" {
    comptime {
        var x: i32 = 1;
        const ptr = &x;
        ptr.* += 1;
        x += 1;
        assert(ptr.* == 3);
    }
}
      {#code_end#}
      <p>To convert an integer address into a pointer, use {#syntax#}@intToPtr{#endsyntax#}.
      To convert a pointer to an integer, use {#syntax#}@ptrToInt{#endsyntax#}:</p>
      {#code_begin|test#}
const assert = @import("std").debug.assert;

test "@ptrToInt and @intToPtr" {
    const ptr = @intToPtr(*i32, 0xdeadbeef);
    const addr = @ptrToInt(ptr);
    assert(@typeOf(addr) == usize);
    assert(addr == 0xdeadbeef);
}
      {#code_end#}
      <p>Zig is able to preserve memory addresses in comptime code, as long as
      the pointer is never dereferenced:</p>
      {#code_begin|test#}
const assert = @import("std").debug.assert;

test "comptime @intToPtr" {
    comptime {
        // Zig is able to do this at compile-time, as long as
        // ptr is never dereferenced.
        const ptr = @intToPtr(*i32, 0xdeadbeef);
        const addr = @ptrToInt(ptr);
        assert(@typeOf(addr) == usize);
        assert(addr == 0xdeadbeef);
    }
}
      {#code_end#}
      {#see_also|Optional Pointers#}
      {#header_open|volatile#}
      <p>Loads and stores are assumed to not have side effects. If a given load or store
      should have side effects, such as Memory Mapped Input/Output (MMIO), use {#syntax#}volatile{#endsyntax#}.
      In the following code, loads and stores with {#syntax#}mmio_ptr{#endsyntax#} are guaranteed to all happen
      and in the same order as in source code:</p>
      {#code_begin|test#}
const assert = @import("std").debug.assert;

test "volatile" {
    const mmio_ptr = @intToPtr(*volatile u8, 0x12345678);
    assert(@typeOf(mmio_ptr) == *volatile u8);
}
      {#code_end#}
      <p>
      Note that {#syntax#}volatile{#endsyntax#} is unrelated to concurrency and {#link|Atomics#}.
      If you see code that is using {#syntax#}volatile{#endsyntax#} for something other than Memory Mapped
      Input/Output, it is probably a bug.
      </p>
      {#header_close#}
      <p>
      To convert one pointer type to another, use {#link|@ptrCast#}. This is an unsafe
      operation that Zig cannot protect you against. Use {#syntax#}@ptrCast{#endsyntax#} only when other
      conversions are not possible.
      </p>
      {#code_begin|test#}
const assert = @import("std").debug.assert;

test "pointer casting" {
    const bytes align(@alignOf(u32)) = []u8{ 0x12, 0x12, 0x12, 0x12 };
    const u32_ptr = @ptrCast(*const u32, &bytes);
    assert(u32_ptr.* == 0x12121212);

    // Even this example is contrived - there are better ways to do the above than
    // pointer casting. For example, using a slice narrowing cast:
    const u32_value = @bytesToSlice(u32, bytes[0..])[0];
    assert(u32_value == 0x12121212);

    // And even another way, the most straightforward way to do it:
    assert(@bitCast(u32, bytes) == 0x12121212);
}

test "pointer child type" {
    // pointer types have a `child` field which tells you the type they point to.
    assert((*u32).Child == u32);
}
      {#code_end#}
      {#header_open|Alignment#}
      <p>
      Each type has an <strong>alignment</strong> - a number of bytes such that,
      when a value of the type is loaded from or stored to memory,
      the memory address must be evenly divisible by this number. You can use
      {#link|@alignOf#} to find out this value for any type.
      </p>
      <p>
      Alignment depends on the CPU architecture, but is always a power of two, and
      less than {#syntax#}1 << 29{#endsyntax#}.
      </p>
      <p>
      In Zig, a pointer type has an alignment value. If the value is equal to the
      alignment of the underlying type, it can be omitted from the type:
      </p>
      {#code_begin|test#}
const assert = @import("std").debug.assert;
const builtin = @import("builtin");

test "variable alignment" {
    var x: i32 = 1234;
    const align_of_i32 = @alignOf(@typeOf(x));
    assert(@typeOf(&x) == *i32);
    assert(*i32 == *align(align_of_i32) i32);
    if (builtin.arch == builtin.Arch.x86_64) {
        assert((*i32).alignment == 4);
    }
}
      {#code_end#}
      <p>In the same way that a {#syntax#}*i32{#endsyntax#} can be {#link|implicitly cast|Implicit Casts#} to a
          {#syntax#}*const i32{#endsyntax#}, a pointer with a larger alignment can be implicitly
      cast to a pointer with a smaller alignment, but not vice versa.
      </p>
      <p>
      You can specify alignment on variables and functions. If you do this, then
      pointers to them get the specified alignment:
      </p>
      {#code_begin|test#}
const assert = @import("std").debug.assert;

var foo: u8 align(4) = 100;

test "global variable alignment" {
    assert(@typeOf(&foo).alignment == 4);
    assert(@typeOf(&foo) == *align(4) u8);
    const slice = (*[1]u8)(&foo)[0..];
    assert(@typeOf(slice) == []align(4) u8);
}

fn derp() align(@sizeOf(usize) * 2) i32 { return 1234; }
fn noop1() align(1) void {}
fn noop4() align(4) void {}

test "function alignment" {
    assert(derp() == 1234);
    assert(@typeOf(noop1) == fn() align(1) void);
    assert(@typeOf(noop4) == fn() align(4) void);
    noop1();
    noop4();
}
      {#code_end#}
      <p>
      If you have a pointer or a slice that has a small alignment, but you know that it actually
      has a bigger alignment, use {#link|@alignCast#} to change the
      pointer into a more aligned pointer. This is a no-op at runtime, but inserts a
      {#link|safety check|Incorrect Pointer Alignment#}:
      </p>
      {#code_begin|test_safety|incorrect alignment#}
const assert = @import("std").debug.assert;

test "pointer alignment safety" {
    var array align(4) = []u32{ 0x11111111, 0x11111111 };
    const bytes = @sliceToBytes(array[0..]);
    assert(foo(bytes) == 0x11111111);
}
fn foo(bytes: []u8) u32 {
    const slice4 = bytes[1..5];
    const int_slice = @bytesToSlice(u32, @alignCast(4, slice4));
    return int_slice[0];
}
      {#code_end#}
      {#header_close#}
      {#header_close#}
      {#header_open|Slices#}
      {#code_begin|test_safety|index out of bounds#}
const assert = @import("std").debug.assert;

test "basic slices" {
    var array = []i32{ 1, 2, 3, 4 };
    // A slice is a pointer and a length. The difference between an array and
    // a slice is that the array's length is part of the type and known at
    // compile-time, whereas the slice's length is known at runtime.
    // Both can be accessed with the `len` field.
    const slice = array[0..array.len];
    assert(&slice[0] == &array[0]);
    assert(slice.len == array.len);

    // Using the address-of operator on a slice gives a pointer to a single
    // item, while using the `ptr` field gives an unknown length pointer.
    assert(@typeOf(slice.ptr) == [*]i32);
    assert(@typeOf(&slice[0]) == *i32);
    assert(@ptrToInt(slice.ptr) == @ptrToInt(&slice[0]));

    // Slices have array bounds checking. If you try to access something out
    // of bounds, you'll get a safety check failure:
    slice[10] += 1;

    // Note that `slice.ptr` does not invoke safety checking, while `&slice[0]`
    // asserts that the slice has len >= 1.
}
      {#code_end#}
      <p>This is one reason we prefer slices to pointers.</p>
      {#code_begin|test|slices#}
const assert = @import("std").debug.assert;
const mem = @import("std").mem;
const fmt = @import("std").fmt;

test "using slices for strings" {
    // Zig has no concept of strings. String literals are arrays of u8, and
    // in general the string type is []u8 (slice of u8).
    // Here we implicitly cast [5]u8 to []const u8
    const hello: []const u8 = "hello";
    const world: []const u8 = "";

    var all_together: [100]u8 = undefined;
    // You can use slice syntax on an array to convert an array into a slice.
    const all_together_slice = all_together[0..];
    // String concatenation example.
    const hello_world = try fmt.bufPrint(all_together_slice, "{} {}", hello, world);

    // Generally, you can use UTF-8 and not worry about whether something is a
    // string. If you don't need to deal with individual characters, no need
    // to decode.
    assert(mem.eql(u8, hello_world, "hello "));
}

test "slice pointer" {
    var array: [10]u8 = undefined;
    const ptr = &array;

    // You can use slicing syntax to convert a pointer into a slice:
    const slice = ptr[0..5];
    slice[2] = 3;
    assert(slice[2] == 3);
    // The slice is mutable because we sliced a mutable pointer.
    assert(@typeOf(slice) == []u8);

    // You can also slice a slice:
    const slice2 = slice[2..3];
    assert(slice2.len == 1);
    assert(slice2[0] == 3);
}

test "slice widening" {
    // Zig supports slice widening and slice narrowing. Cast a slice of u8
    // to a slice of anything else, and Zig will perform the length conversion.
    const array align(@alignOf(u32)) = []u8{ 0x12, 0x12, 0x12, 0x12, 0x13, 0x13, 0x13, 0x13 };
    const slice = @bytesToSlice(u32, array[0..]);
    assert(slice.len == 2);
    assert(slice[0] == 0x12121212);
    assert(slice[1] == 0x13131313);
}
      {#code_end#}
      {#see_also|Pointers|for|Arrays#}
      {#header_close#}
      {#header_open|struct#}
      {#code_begin|test|structs#}
// Declare a struct.
// Zig gives no guarantees about the order of fields and whether or
// not there will be padding.
const Point = struct {
    x: f32,
    y: f32,
};

// Maybe we want to pass it to OpenGL so we want to be particular about
// how the bytes are arranged.
const Point2 = packed struct {
    x: f32,
    y: f32,
};


// Declare an instance of a struct.
const p = Point {
    .x = 0.12,
    .y = 0.34,
};

// Maybe we're not ready to fill out some of the fields.
var p2 = Point {
    .x = 0.12,
    .y = undefined,
};

// Structs can have methods
// Struct methods are not special, they are only namespaced
// functions that you can call with dot syntax.
const Vec3 = struct {
    x: f32,
    y: f32,
    z: f32,

    pub fn init(x: f32, y: f32, z: f32) Vec3 {
        return Vec3 {
            .x = x,
            .y = y,
            .z = z,
        };
    }

    pub fn dot(self: Vec3, other: Vec3) f32 {
        return self.x * other.x + self.y * other.y + self.z * other.z;
    }
};

const assert = @import("std").debug.assert;
test "dot product" {
    const v1 = Vec3.init(1.0, 0.0, 0.0);
    const v2 = Vec3.init(0.0, 1.0, 0.0);
    assert(v1.dot(v2) == 0.0);

    // Other than being available to call with dot syntax, struct methods are
    // not special. You can reference them as any other declaration inside
    // the struct:
    assert(Vec3.dot(v1, v2) == 0.0);
}

// Structs can have global declarations.
// Structs can have 0 fields.
const Empty = struct {
    pub const PI = 3.14;
};
test "struct namespaced variable" {
    assert(Empty.PI == 3.14);
    assert(@sizeOf(Empty) == 0);

    // you can still instantiate an empty struct
    const does_nothing = Empty {};
}

// struct field order is determined by the compiler for optimal performance.
// however, you can still calculate a struct base pointer given a field pointer:
fn setYBasedOnX(x: *f32, y: f32) void {
    const point = @fieldParentPtr(Point, "x", x);
    point.y = y;
}
test "field parent pointer" {
    var point = Point {
        .x = 0.1234,
        .y = 0.5678,
    };
    setYBasedOnX(&point.x, 0.9);
    assert(point.y == 0.9);
}

// You can return a struct from a function. This is how we do generics
// in Zig:
fn LinkedList(comptime T: type) type {
    return struct {
        pub const Node = struct {
            prev: ?*Node,
            next: ?*Node,
            data: T,
        };

        first: ?*Node,
        last:  ?*Node,
        len:   usize,
    };
}

test "linked list" {
    // Functions called at compile-time are memoized. This means you can
    // do this:
    assert(LinkedList(i32) == LinkedList(i32));

    var list = LinkedList(i32) {
        .first = null,
        .last = null,
        .len = 0,
    };
    assert(list.len == 0);

    // Since types are first class values you can instantiate the type
    // by assigning it to a variable:
    const ListOfInts = LinkedList(i32);
    assert(ListOfInts == LinkedList(i32));

    var node = ListOfInts.Node {
        .prev = null,
        .next = null,
        .data = 1234,
    };
    var list2 = LinkedList(i32) {
        .first = &node,
        .last = &node,
        .len = 1,
    };
    assert(list2.first.?.data == 1234);
}
      {#code_end#}
      {#header_open|packed struct#}
      <p>{#syntax#}packed{#endsyntax#} structs have guaranteed in-memory layout.</p>
      <p>TODO bit fields</p>
      <p>TODO alignment</p>
      <p>TODO endianness</p>
      <p>TODO @bitOffsetOf and @byteOffsetOf</p>
      <p>TODO mention how volatile loads and stores of bit packed fields could be more efficient when
      done by hand instead of with packed struct</p>
      {#header_close#}
      {#header_open|struct Naming#}
      <p>Since all structs are anonymous, Zig infers the type name based on a few rules.</p>
      <ul>
          <li>If the struct is in the initialization expression of a variable, it gets named after
          that variable.</li>
          <li>If the struct is in the {#syntax#}return{#endsyntax#} expression, it gets named after
          the function it is returning from, with the parameter values serialized.</li>
          <li>Otherwise, the struct gets a name such as <code>(anonymous struct at file.zig:7:38)</code>.</li>
      </ul>
      {#code_begin|exe|struct_name#}
const std = @import("std");

pub fn main() void {
    const Foo = struct {};
    std.debug.warn("variable: {}\n", @typeName(Foo));
    std.debug.warn("anonymous: {}\n", @typeName(struct {}));
    std.debug.warn("function: {}\n", @typeName(List(i32)));
}

fn List(comptime T: type) type {
    return struct {
        x: T,
    };
}
      {#code_end#}
      {#header_close#}
      {#see_also|comptime|@fieldParentPtr#}
      {#header_close#}
      {#header_open|enum#}
      {#code_begin|test|enums#}
const assert = @import("std").debug.assert;
const mem = @import("std").mem;

// Declare an enum.
const Type = enum {
    Ok,
    NotOk,
};

// Declare a specific instance of the enum variant.
const c = Type.Ok;

// If you want access to the ordinal value of an enum, you
// can specify the tag type.
const Value = enum(u2) {
    Zero,
    One,
    Two,
};

// Now you can cast between u2 and Value.
// The ordinal value starts from 0, counting up for each member.
test "enum ordinal value" {
    assert(@enumToInt(Value.Zero) == 0);
    assert(@enumToInt(Value.One) == 1);
    assert(@enumToInt(Value.Two) == 2);
}

// You can override the ordinal value for an enum.
const Value2 = enum(u32) {
    Hundred = 100,
    Thousand = 1000,
    Million = 1000000,
};
test "set enum ordinal value" {
    assert(@enumToInt(Value2.Hundred) == 100);
    assert(@enumToInt(Value2.Thousand) == 1000);
    assert(@enumToInt(Value2.Million) == 1000000);
}

// Enums can have methods, the same as structs and unions.
// Enum methods are not special, they are only namespaced
// functions that you can call with dot syntax.
const Suit = enum {
    Clubs,
    Spades,
    Diamonds,
    Hearts,

    pub fn isClubs(self: Suit) bool {
        return self == Suit.Clubs;
    }
};
test "enum method" {
    const p = Suit.Spades;
    assert(!p.isClubs());
}

// An enum variant of different types can be switched upon.
const Foo = enum {
    String,
    Number,
    None,
};
test "enum variant switch" {
    const p = Foo.Number;
    const what_is_it = switch (p) {
        Foo.String => "this is a string",
        Foo.Number => "this is a number",
        Foo.None => "this is a none",
    };
    assert(mem.eql(u8, what_is_it, "this is a number"));
}

// @TagType can be used to access the integer tag type of an enum.
const Small = enum {
    One,
    Two,
    Three,
    Four,
};
test "@TagType" {
    assert(@TagType(Small) == u2);
}

// @memberCount tells how many fields an enum has:
test "@memberCount" {
    assert(@memberCount(Small) == 4);
}

// @memberName tells the name of a field in an enum:
test "@memberName" {
    assert(mem.eql(u8, @memberName(Small, 1), "Two"));
}

// @tagName gives a []const u8 representation of an enum value:
test "@tagName" {
    assert(mem.eql(u8, @tagName(Small.Three), "Three"));
}
      {#code_end#}
      {#header_open|extern enum#}
      <p>
      By default, enums are not guaranteed to be compatible with the C ABI:
      </p>
      {#code_begin|obj_err|parameter of type 'Foo' not allowed in function with calling convention 'ccc'#}
const Foo = enum { A, B, C };
export fn entry(foo: Foo) void { }
      {#code_end#}
      <p>
      For a C-ABI-compatible enum, use {#syntax#}extern enum{#endsyntax#}:
      </p>
      {#code_begin|obj#}
const Foo = extern enum { A, B, C };
export fn entry(foo: Foo) void { }
      {#code_end#}
      {#header_close#}
      {#header_open|packed enum#}
      <p>By default, the size of enums is not guaranteed.</p>
      <p>{#syntax#}packed enum{#endsyntax#} causes the size of the enum to be the same as the size of the integer tag type
      of the enum:</p>
      {#code_begin|test#}
const std = @import("std");

test "packed enum" {
    const Number = packed enum(u8) {
        One,
        Two,
        Three,
    };
    std.debug.assert(@sizeOf(Number) == @sizeOf(u8));
}
      {#code_end#}
      {#header_close#}
      {#see_also|@memberName|@memberCount|@tagName|@sizeOf#}
      {#header_close#}
      {#header_open|union#}
      {#code_begin|test|union#}
const assert = @import("std").debug.assert;
const mem = @import("std").mem;

// A union has only 1 active field at a time.
const Payload = union {
    Int: i64,
    Float: f64,
    Bool: bool,
};
test "simple union" {
    var payload = Payload {.Int = 1234};
    // payload.Float = 12.34; // ERROR! field not active
    assert(payload.Int == 1234);
    // You can activate another field by assigning the entire union.
    payload = Payload {.Float = 12.34};
    assert(payload.Float == 12.34);
}

// Unions can be given an enum tag type:
const ComplexTypeTag = enum { Ok, NotOk }; 
const ComplexType = union(ComplexTypeTag) {
    Ok: u8,
    NotOk: void,
};

// Declare a specific instance of the union variant.
test "declare union value" {
    const c = ComplexType { .Ok = 0 };
    assert(ComplexTypeTag(c) == ComplexTypeTag.Ok);
}

// @TagType can be used to access the enum tag type of a union.
test "@TagType" {
    assert(@TagType(ComplexType) == ComplexTypeTag);
}

// Unions can be made to infer the enum tag type.
const Foo = union(enum) {
    String: []const u8,
    Number: u64,

    // void can be omitted when inferring enum tag type.
    None,
};
test "union variant switch" {
    const p = Foo { .Number = 54 };
    const what_is_it = switch (p) {
        // Capture by reference
        Foo.String => |*x| blk: {
            break :blk "this is a string";
        },

        // Capture by value
        Foo.Number => |x| blk: {
            assert(x == 54);
            break :blk "this is a number";
        },

        Foo.None => blk: {
            break :blk "this is a none";
        },
    };
    assert(mem.eql(u8, what_is_it, "this is a number"));
}

// Unions can have methods just like structs and enums:

const Variant = union(enum) {
    Int: i32,
    Bool: bool,

    fn truthy(self: Variant) bool {
        return switch (self) {
            Variant.Int => |x_int| x_int != 0,
            Variant.Bool => |x_bool| x_bool,
        };
    }
};

test "union method" {
    var v1 = Variant { .Int = 1 };
    var v2 = Variant { .Bool = false };

    assert(v1.truthy());
    assert(!v2.truthy());
}


const Small = union {
    A: i32,
    B: bool,
    C: u8,
};

// @memberCount tells how many fields a union has:
test "@memberCount" {
    assert(@memberCount(Small) == 3);
}

// @memberName tells the name of a field in an enum:
test "@memberName" {
    assert(mem.eql(u8, @memberName(Small, 1), "B"));
}

// @tagName gives a []const u8 representation of an enum value,
// but only if the union has an enum tag type.
const Small2 = union(enum) {
    A: i32,
    B: bool,
    C: u8,
};
test "@tagName" {
    assert(mem.eql(u8, @tagName(Small2.C), "C"));
}
      {#code_end#}
      <p>
      Unions with an enum tag are generated as a struct with a tag field and union field. Zig
      sorts the order of the tag and union field by the largest alignment.
      </p>
      {#header_close#}
      {#header_open|blocks#}
      <p>
      Blocks are used to limit the scope of variable declarations:
      </p>
      {#code_begin|test_err|undeclared identifier#}
test "access variable after block scope" {
    {
        var x: i32 = 1;
    }
    x += 1;
}
      {#code_end#}
      <p>Blocks are expressions. When labeled, {#syntax#}break{#endsyntax#} can be used
      to return a value from the block:
      </p>
      {#code_begin|test#}
const std = @import("std");
const assert = std.debug.assert;

test "labeled break from labeled block expression" {
    var y: i32 = 123;

    const x = blk: {
        y += 1;
        break :blk y;
    };
    assert(x == 124);
    assert(y == 124);
}
      {#code_end#}
      <p>Here, {#syntax#}blk{#endsyntax#} can be any name.</p>
      {#see_also|Labeled while|Labeled for#}
      {#header_close#}
      {#header_open|switch#}
      {#code_begin|test|switch#}
const assert = @import("std").debug.assert;
const builtin = @import("builtin");

test "switch simple" {
    const a: u64 = 10;
    const zz: u64 = 103;

    // All branches of a switch expression must be able to be coerced to a
    // common type.
    //
    // Branches cannot fallthrough. If fallthrough behavior is desired, combine
    // the cases and use an if.
    const b = switch (a) {
        // Multiple cases can be combined via a ','
        1, 2, 3 => 0,

        // Ranges can be specified using the ... syntax. These are inclusive
        // both ends.
        5 ... 100 => 1,

        // Branches can be arbitrarily complex.
        101 => blk: {
            const c: u64 = 5;
            break :blk c * 2 + 1;
        },

        // Switching on arbitrary expressions is allowed as long as the
        // expression is known at compile-time.
        zz => zz,
        comptime blk: {
            const d: u32 = 5;
            const e: u32 = 100;
            break :blk d + e;
        } => 107,

        // The else branch catches everything not already captured.
        // Else branches are mandatory unless the entire range of values
        // is handled.
        else => 9,
    };

    assert(b == 1);
}

test "switch enum" {
    const Item = union(enum) {
        A: u32,
        C: struct { x: u8, y: u8 },
        D,
    };

    var a = Item { .A = 3 };

    // Switching on more complex enums is allowed.
    const b = switch (a) {
        // A capture group is allowed on a match, and will return the enum
        // value matched.
        Item.A => |item| item,

        // A reference to the matched value can be obtained using `*` syntax.
        Item.C => |*item| blk: {
            item.*.x += 1;
            break :blk 6;
        },

        // No else is required if the types cases was exhaustively handled
        Item.D => 8,
    };

    assert(b == 3);
}

// Switch expressions can be used outside a function:
const os_msg = switch (builtin.os) {
    builtin.Os.linux => "we found a linux user",
    else => "not a linux user",
};

// Inside a function, switch statements implicitly are compile-time
// evaluated if the target expression is compile-time known.
test "switch inside function" {
    switch (builtin.os) {
        builtin.Os.fuchsia => {
            // On an OS other than fuchsia, block is not even analyzed,
            // so this compile error is not triggered.
            // On fuchsia this compile error would be triggered.
            @compileError("fuchsia not supported");
        },
        else => {},
    }
}
      {#code_end#}
      {#see_also|comptime|enum|@compileError|Compile Variables#}
      {#header_close#}
      {#header_open|while#}
      <p>
      A while loop is used to repeatedly execute an expression until
      some condition is no longer true.
      </p>
      {#code_begin|test|while#}
const assert = @import("std").debug.assert;

test "while basic" {
    var i: usize = 0;
    while (i < 10) {
        i += 1;
    }
    assert(i == 10);
}
      {#code_end#}
      <p>
      Use {#syntax#}break{#endsyntax#} to exit a while loop early.
      </p>
      {#code_begin|test|while#}
const assert = @import("std").debug.assert;

test "while break" {
    var i: usize = 0;
    while (true) {
        if (i == 10)
            break;
        i += 1;
    }
    assert(i == 10);
}
      {#code_end#}
      <p>
      Use {#syntax#}continue{#endsyntax#} to jump back to the beginning of the loop.
      </p>
      {#code_begin|test|while#}
const assert = @import("std").debug.assert;

test "while continue" {
    var i: usize = 0;
    while (true) {
        i += 1;
        if (i < 10)
            continue;
        break;
    }
    assert(i == 10);
}
      {#code_end#}
      <p>
      While loops support a continue expression which is executed when the loop
      is continued. The {#syntax#}continue{#endsyntax#} keyword respects this expression.
      </p>
      {#code_begin|test|while#}
const assert = @import("std").debug.assert;

test "while loop continue expression" {
    var i: usize = 0;
    while (i < 10) : (i += 1) {}
    assert(i == 10);
}

test "while loop continue expression, more complicated" {
    var i: usize = 1;
    var j: usize = 1;
    while (i * j < 2000) : ({ i *= 2; j *= 3; }) {
        const my_ij = i * j;
        assert(my_ij < 2000);
    }
}
      {#code_end#}
      <p>
      While loops are expressions. The result of the expression is the
      result of the {#syntax#}else{#endsyntax#} clause of a while loop, which is executed when
      the condition of the while loop is tested as false.
      </p>
      <p>
      {#syntax#}break{#endsyntax#}, like {#syntax#}return{#endsyntax#}, accepts a value
              parameter. This is the result of the {#syntax#}while{#endsyntax#} expression.
                  When you {#syntax#}break{#endsyntax#} from a while loop, the {#syntax#}else{#endsyntax#} branch is not
      evaluated.
      </p>
      {#code_begin|test|while#}
const assert = @import("std").debug.assert;

test "while else" {
    assert(rangeHasNumber(0, 10, 5));
    assert(!rangeHasNumber(0, 10, 15));
}

fn rangeHasNumber(begin: usize, end: usize, number: usize) bool {
    var i = begin;
    return while (i < end) : (i += 1) {
        if (i == number) {
            break true;
        }
    } else false;
}
      {#code_end#}
      {#header_open|Labeled while#}
      <p>When a {#syntax#}while{#endsyntax#} loop is labeled, it can be referenced from a {#syntax#}break{#endsyntax#}
              or {#syntax#}continue{#endsyntax#} from within a nested loop:</p>
      {#code_begin|test#}
test "nested break" {
    outer: while (true) {
        while (true) {
            break :outer;
        }
    }
}

test "nested continue" {
    var i: usize = 0;
    outer: while (i < 10) : (i += 1) {
        while (true) {
            continue :outer;
        }
    }
}
      {#code_end#}
      {#header_close#}
      {#header_open|while with Optionals#}
      <p>
      Just like {#link|if#} expressions, while loops can take an optional as the
      condition and capture the payload. When {#link|null#} is encountered the loop
      exits.
      </p>
      <p>
      When the {#syntax#}|x|{#endsyntax#} syntax is present on a {#syntax#}while{#endsyntax#} expression,
      the while condition must have an {#link|Optional Type#}.
      </p>
      <p>
      The {#syntax#}else{#endsyntax#} branch is allowed on optional iteration. In this case, it will
      be executed on the first null value encountered.
      </p>
      {#code_begin|test|while#}
const assert = @import("std").debug.assert;

test "while null capture" {
    var sum1: u32 = 0;
    numbers_left = 3;
    while (eventuallyNullSequence()) |value| {
        sum1 += value;
    }
    assert(sum1 == 3);

    var sum2: u32 = 0;
    numbers_left = 3;
    while (eventuallyNullSequence()) |value| {
        sum2 += value;
    } else {
        assert(sum1 == 3);
    }
}

var numbers_left: u32 = undefined;
fn eventuallyNullSequence() ?u32 {
    return if (numbers_left == 0) null else blk: {
        numbers_left -= 1;
        break :blk numbers_left;
    };
}

      {#code_end#}
      {#header_close#}

      {#header_open|while with Error Unions#}
      <p>
      Just like {#link|if#} expressions, while loops can take an error union as
      the condition and capture the payload or the error code. When the
      condition results in an error code the else branch is evaluated and
      the loop is finished.
      </p>
      <p>
      When the {#syntax#}else |x|{#endsyntax#} syntax is present on a {#syntax#}while{#endsyntax#} expression,
      the while condition must have an {#link|Error Union Type#}.
      </p>
      {#code_begin|test|while#}
const assert = @import("std").debug.assert;

test "while error union capture" {
    var sum1: u32 = 0;
    numbers_left = 3;
    while (eventuallyErrorSequence()) |value| {
        sum1 += value;
    } else |err| {
        assert(err == error.ReachedZero);
    }
}

var numbers_left: u32 = undefined;

fn eventuallyErrorSequence() anyerror!u32 {
    return if (numbers_left == 0) error.ReachedZero else blk: {
        numbers_left -= 1;
        break :blk numbers_left;
    };
}
      {#code_end#}
      {#header_close#}

      {#header_open|inline while#}
      <p>
      While loops can be inlined. This causes the loop to be unrolled, which
      allows the code to do some things which only work at compile time,
      such as use types as first class values.
      </p>
      {#code_begin|test#}
const assert = @import("std").debug.assert;

test "inline while loop" {
    comptime var i = 0;
    var sum: usize = 0;
    inline while (i < 3) : (i += 1) {
        const T = switch (i) {
            0 => f32,
            1 => i8,
            2 => bool,
            else => unreachable,
        };
        sum += typeNameLength(T);
    }
    assert(sum == 9);
}

fn typeNameLength(comptime T: type) usize {
    return @typeName(T).len;
}
      {#code_end#}
      <p>
      It is recommended to use {#syntax#}inline{#endsyntax#} loops only for one of these reasons:
      </p>
      <ul>
        <li>You need the loop to execute at {#link|comptime#} for the semantics to work.</li>
        <li>
        You have a benchmark to prove that forcibly unrolling the loop in this way is measurably faster.
        </li>
      </ul>
      {#header_close#}
      {#see_also|if|Optionals|Errors|comptime|unreachable#}
      {#header_close#}
      {#header_open|for#}
      {#code_begin|test|for#}
const assert = @import("std").debug.assert;

test "for basics" {
    const items = []i32 { 4, 5, 3, 4, 0 };
    var sum: i32 = 0;

    // For loops iterate over slices and arrays.
    for (items) |value| {
        // Break and continue are supported.
        if (value == 0) {
            continue;
        }
        sum += value;
    }
    assert(sum == 16);

    // To iterate over a portion of a slice, reslice.
    for (items[0..1]) |value| {
        sum += value;
    }
    assert(sum == 20);

    // To access the index of iteration, specify a second capture value.
    // This is zero-indexed.
    var sum2: i32 = 0;
    for (items) |value, i| {
        assert(@typeOf(i) == usize);
        sum2 += @intCast(i32, i);
    }
    assert(sum2 == 10);
}

test "for reference" {
    var items = []i32 { 3, 4, 2 };

    // Iterate over the slice by reference by
    // specifying that the capture value is a pointer.
    for (items) |*value| {
        value.* += 1;
    }

    assert(items[0] == 4);
    assert(items[1] == 5);
    assert(items[2] == 3);
}

test "for else" {
    // For allows an else attached to it, the same as a while loop.
    var items = []?i32 { 3, 4, null, 5 };

    // For loops can also be used as expressions.
    var sum: i32 = 0;
    const result = for (items) |value| {
        if (value == null) {
            break 9;
        } else {
            sum += value.?;
        }
    } else blk: {
        assert(sum == 7);
        break :blk sum;
    };
}
      {#code_end#}
      {#header_open|Labeled for#}
      <p>When a {#syntax#}for{#endsyntax#} loop is labeled, it can be referenced from a {#syntax#}break{#endsyntax#}
              or {#syntax#}continue{#endsyntax#} from within a nested loop:</p>
      {#code_begin|test#}
const std = @import("std");
const assert = std.debug.assert;

test "nested break" {
    var count: usize = 0;
    outer: for ([]i32{ 1, 2, 3, 4, 5 }) |_| {
        for ([]i32{ 1, 2, 3, 4, 5 }) |_| {
            count += 1;
            break :outer;
        }
    }
    assert(count == 1);
}

test "nested continue" {
    var count: usize = 0;
    outer: for ([]i32{ 1, 2, 3, 4, 5, 6, 7, 8 }) |_| {
        for ([]i32{ 1, 2, 3, 4, 5 }) |_| {
            count += 1;
            continue :outer;
        }
    }

    assert(count == 8);
}
      {#code_end#}
      {#header_close#}
      {#header_open|inline for#}
      <p>
      For loops can be inlined. This causes the loop to be unrolled, which
      allows the code to do some things which only work at compile time,
      such as use types as first class values.
      The capture value and iterator value of inlined for loops are
      compile-time known.
      </p>
      {#code_begin|test#}
const assert = @import("std").debug.assert;

test "inline for loop" {
    const nums = []i32{2, 4, 6};
    var sum: usize = 0;
    inline for (nums) |i| {
        const T = switch (i) {
            2 => f32,
            4 => i8,
            6 => bool,
            else => unreachable,
        };
        sum += typeNameLength(T);
    }
    assert(sum == 9);
}

fn typeNameLength(comptime T: type) usize {
    return @typeName(T).len;
}
      {#code_end#}
      <p>
      It is recommended to use {#syntax#}inline{#endsyntax#} loops only for one of these reasons:
      </p>
      <ul>
        <li>You need the loop to execute at {#link|comptime#} for the semantics to work.</li>
        <li>
        You have a benchmark to prove that forcibly unrolling the loop in this way is measurably faster.
        </li>
      </ul>
      {#header_close#}
      {#see_also|while|comptime|Arrays|Slices#}
      {#header_close#}
      {#header_open|if#}
      {#code_begin|test|if#}
// If expressions have three uses, corresponding to the three types:
// * bool
// * ?T
// * anyerror!T

const assert = @import("std").debug.assert;

test "if boolean" {
    // If expressions test boolean conditions.
    const a: u32 = 5;
    const b: u32 = 4;
    if (a != b) {
        assert(true);
    } else if (a == 9) {
        unreachable;
    } else {
        unreachable;
    }

    // If expressions are used instead of a ternary expression.
    const result = if (a != b) 47 else 3089;
    assert(result == 47);
}

test "if optional" {
    // If expressions test for null.

    const a: ?u32 = 0;
    if (a) |value| {
        assert(value == 0);
    } else {
        unreachable;
    }

    const b: ?u32 = null;
    if (b) |value| {
        unreachable;
    } else {
        assert(true);
    }

    // The else is not required.
    if (a) |value| {
        assert(value == 0);
    }

    // To test against null only, use the binary equality operator.
    if (b == null) {
        assert(true);
    }

    // Access the value by reference using a pointer capture.
    var c: ?u32 = 3;
    if (c) |*value| {
        value.* = 2;
    }

    if (c) |value| {
        assert(value == 2);
    } else {
        unreachable;
    }
}

test "if error union" {
    // If expressions test for errors.
    // Note the |err| capture on the else.

    const a: anyerror!u32 = 0;
    if (a) |value| {
        assert(value == 0);
    } else |err| {
        unreachable;
    }

    const b: anyerror!u32 = error.BadValue;
    if (b) |value| {
        unreachable;
    } else |err| {
        assert(err == error.BadValue);
    }

    // The else and |err| capture is strictly required.
    if (a) |value| {
        assert(value == 0);
    } else |_| {}

    // To check only the error value, use an empty block expression.
    if (b) |_| {} else |err| {
        assert(err == error.BadValue);
    }

    // Access the value by reference using a pointer capture.
    var c: anyerror!u32 = 3;
    if (c) |*value| {
        value.* = 9;
    } else |err| {
        unreachable;
    }

    if (c) |value| {
        assert(value == 9);
    } else |err| {
        unreachable;
    }
}
      {#code_end#}
      {#see_also|Optionals|Errors#}
      {#header_close#}
      {#header_open|defer#}
      {#code_begin|test|defer#}
const std = @import("std");
const assert = std.debug.assert;
const warn = std.debug.warn;

// defer will execute an expression at the end of the current scope.
fn deferExample() usize {
    var a: usize = 1;

    {
        defer a = 2;
        a = 1;
    }
    assert(a == 2);

    a = 5;
    return a;
}

test "defer basics" {
    assert(deferExample() == 5);
}

// If multiple defer statements are specified, they will be executed in
// the reverse order they were run.
fn deferUnwindExample() void {
    warn("\n");

    defer {
        warn("1 ");
    }
    defer {
        warn("2 ");
    }
    if (false) {
        // defers are not run if they are never executed.
        defer {
            warn("3 ");
        }
    }
}

test "defer unwinding" {
    deferUnwindExample();
}

// The errdefer keyword is similar to defer, but will only execute if the
// scope returns with an error.
//
// This is especially useful in allowing a function to clean up properly
// on error, and replaces goto error handling tactics as seen in c.
fn deferErrorExample(is_error: bool) !void {
    warn("\nstart of function\n");

    // This will always be executed on exit
    defer {
        warn("end of function\n");
    }

    errdefer {
        warn("encountered an error!\n");
    }

    if (is_error) {
        return error.DeferError;
    }
}

test "errdefer unwinding" {
    _ = deferErrorExample(false);
    _ = deferErrorExample(true);
}
      {#code_end#}
      {#see_also|Errors#}
      {#header_close#}
      {#header_open|unreachable#}
      <p>
      In {#syntax#}Debug{#endsyntax#} and {#syntax#}ReleaseSafe{#endsyntax#} mode, and when using <code>zig test</code>,
      {#syntax#}unreachable{#endsyntax#} emits a call to {#syntax#}panic{#endsyntax#} with the message <code>reached unreachable code</code>.
      </p>
      <p>
      In {#syntax#}ReleaseFast{#endsyntax#} mode, the optimizer uses the assumption that {#syntax#}unreachable{#endsyntax#} code
      will never be hit to perform optimizations. However, <code>zig test</code> even in {#syntax#}ReleaseFast{#endsyntax#} mode
                  still emits {#syntax#}unreachable{#endsyntax#} as calls to {#syntax#}panic{#endsyntax#}.
      </p>
      {#header_open|Basics#}
      {#code_begin|test#}
// unreachable is used to assert that control flow will never happen upon a
// particular location:
test "basic math" {
    const x = 1;
    const y = 2;
    if (x + y != 3) {
        unreachable;
    }
}
      {#code_end#}
      <p>In fact, this is how assert is implemented:</p>
      {#code_begin|test_err#}
fn assert(ok: bool) void {
    if (!ok) unreachable; // assertion failure
}

// This test will fail because we hit unreachable.
test "this will fail" {
    assert(false);
}
      {#code_end#}
      {#header_close#}
      {#header_open|At Compile-Time#}
      {#code_begin|test_err|unreachable code#}
const assert = @import("std").debug.assert;

test "type of unreachable" {
    comptime {
        // The type of unreachable is noreturn.

        // However this assertion will still fail because
        // evaluating unreachable at compile-time is a compile error.

        assert(@typeOf(unreachable) == noreturn);
    }
}
      {#code_end#}
      {#see_also|Zig Test|Build Mode|comptime#}
      {#header_close#}
      {#header_close#}
      {#header_open|noreturn#}
      <p>
      {#syntax#}noreturn{#endsyntax#} is the type of:
      </p>
      <ul>
          <li>{#syntax#}break{#endsyntax#}</li>
          <li>{#syntax#}continue{#endsyntax#}</li>
          <li>{#syntax#}return{#endsyntax#}</li>
          <li>{#syntax#}unreachable{#endsyntax#}</li>
          <li>{#syntax#}while (true) {}{#endsyntax#}</li>
      </ul>
      <p>When resolving types together, such as {#syntax#}if{#endsyntax#} clauses or {#syntax#}switch{#endsyntax#} prongs,
              the {#syntax#}noreturn{#endsyntax#} type is compatible with every other type. Consider:
      </p>
      {#code_begin|test#}
fn foo(condition: bool, b: u32) void {
    const a = if (condition) b else return;
    @panic("do something with a");
}
test "noreturn" {
    foo(false, 1);
}
      {#code_end#}
      <p>Another use case for {#syntax#}noreturn{#endsyntax#} is the {#syntax#}exit{#endsyntax#} function:</p>
      {#code_begin|test#}
      {#target_windows#}
pub extern "kernel32" stdcallcc fn ExitProcess(exit_code: c_uint) noreturn;

test "foo" {
    const value = bar() catch ExitProcess(1);
    assert(value == 1234);
}

fn bar() anyerror!u32 {
    return 1234;
}

const assert = @import("std").debug.assert;
      {#code_end#}
      {#header_close#}
      {#header_open|Functions#}
      {#code_begin|test|functions#}
const assert = @import("std").debug.assert;

// Functions are declared like this
fn add(a: i8, b: i8) i8 {
    if (a == 0) {
        // You can still return manually if needed.
        return b;
    }

    return a + b;
}

// The export specifier makes a function externally visible in the generated
// object file, and makes it use the C ABI.
export fn sub(a: i8, b: i8) i8 { return a - b; }

// The extern specifier is used to declare a function that will be resolved
// at link time, when linking statically, or at runtime, when linking
// dynamically.
// The stdcallcc specifier changes the calling convention of the function.
extern "kernel32" stdcallcc fn ExitProcess(exit_code: u32) noreturn;
extern "c" fn atan2(a: f64, b: f64) f64;

// The @setCold builtin tells the optimizer that a function is rarely called.
fn abort() noreturn {
    @setCold(true);
    while (true) {}
}

// nakedcc makes a function not have any function prologue or epilogue.
// This can be useful when integrating with assembly.
nakedcc fn _start() noreturn {
    abort();
}

// The pub specifier allows the function to be visible when importing.
// Another file can use @import and call sub2
pub fn sub2(a: i8, b: i8) i8 { return a - b; }

// Functions can be used as values and are equivalent to pointers.
const call2_op = fn (a: i8, b: i8) i8;
fn do_op(fn_call: call2_op, op1: i8, op2: i8) i8 {
    return fn_call(op1, op2);
}

test "function" {
    assert(do_op(add, 5, 6) == 11);
    assert(do_op(sub2, 5, 6) == -1);
}
      {#code_end#}
      <p>Function values are like pointers:</p>
      {#code_begin|obj#}
const assert = @import("std").debug.assert;

comptime {
    assert(@typeOf(foo) == fn()void);
    assert(@sizeOf(fn()void) == @sizeOf(?fn()void));
}

fn foo() void { }
      {#code_end#}
      {#header_open|Pass-by-value Parameters#}
      <p>
      In Zig, structs, unions, and enums with payloads can be passed directly to a function:
      </p>
      {#code_begin|test#}
const Point = struct {
    x: i32,
    y: i32,
};

fn foo(point: Point) i32 {
    return point.x + point.y;
}

const assert = @import("std").debug.assert;

test "pass aggregate type by non-copy value to function" {
    assert(foo(Point{ .x = 1, .y = 2 }) == 3);
}
      {#code_end#}
      <p>
      In this case, the value may be passed by reference, or by value, whichever way
      Zig decides will be faster.
      </p>
      <p>
      For extern functions, Zig follows the C ABI for passing structs and unions by value.
      </p>
      {#header_close#}
      {#header_open|Function Reflection#}
      {#code_begin|test#}
const assert = @import("std").debug.assert;

test "fn reflection" {
    assert(@typeOf(assert).ReturnType == void);
    assert(@typeOf(assert).is_var_args == false);
}
      {#code_end#}
      {#header_close#}
      {#header_close#}
      {#header_open|Errors#}
      {#header_open|Error Set Type#}
      <p>
      An error set is like an {#link|enum#}.
      However, each error name across the entire compilation gets assigned an unsigned integer
      greater than 0. You are allowed to declare the same error name more than once, and if you do, it
      gets assigned the same integer value.
      </p>
      <p>
      The number of unique error values across the entire compilation should determine the size of the error set type.
      However right now it is hard coded to be a {#syntax#}u16{#endsyntax#}. See <a href="https://github.com/ziglang/zig/issues/786">#768</a>.
      </p>
      <p>
      You can {#link|implicitly cast|Implicit Casts#} an error from a subset to its superset:
      </p>
      {#code_begin|test#}
const std = @import("std");

const FileOpenError = error {
    AccessDenied,
    OutOfMemory,
    FileNotFound,
};

const AllocationError = error {
    OutOfMemory,
};

test "implicit cast subset to superset" {
    const err = foo(AllocationError.OutOfMemory);
    std.debug.assert(err == FileOpenError.OutOfMemory);
}

fn foo(err: AllocationError) FileOpenError {
    return err;
}
      {#code_end#}
      <p>
      But you cannot implicitly cast an error from a superset to a subset:
      </p>
      {#code_begin|test_err|not a member of destination error set#}
const FileOpenError = error {
    AccessDenied,
    OutOfMemory,
    FileNotFound,
};

const AllocationError = error {
    OutOfMemory,
};

test "implicit cast superset to subset" {
    foo(FileOpenError.OutOfMemory) catch {};
}

fn foo(err: FileOpenError) AllocationError {
    return err;
}
      {#code_end#}
      <p>
      There is a shortcut for declaring an error set with only 1 value, and then getting that value:
      </p>
      {#code_begin|syntax#}
const err = error.FileNotFound;
      {#code_end#}
      <p>This is equivalent to:</p>
      {#code_begin|syntax#}
const err = (error {FileNotFound}).FileNotFound;
      {#code_end#}
      <p>
      This becomes useful when using {#link|Inferred Error Sets#}.
      </p>
      {#header_open|The Global Error Set#}
      <p>{#syntax#}error{#endsyntax#} refers to the global error set.
      This is the error set that contains all errors in the entire compilation unit.
      It is a superset of all other error sets and a subset of none of them.
      </p>
      <p>
      You can implicitly cast any error set to the global one, and you can explicitly
      cast an error of global error set to a non-global one. This inserts a language-level
      assert to make sure the error value is in fact in the destination error set.
      </p>
      <p>
      The global error set should generally be avoided because it prevents the
      compiler from knowing what errors are possible at compile-time. Knowing
      the error set at compile-time is better for generated documentation and
      helpful error messages, such as forgetting a possible error value in a {#link|switch#}.
      </p>
      {#header_close#}
      {#header_close#}
      {#header_open|Error Union Type#}
      <p>
      An error set type and normal type can be combined with the {#syntax#}!{#endsyntax#}
      binary operator to form an error union type. You are likely to use an
      error union type more often than an error set type by itself.
      </p>
      <p>
      Here is a function to parse a string into a 64-bit integer:
      </p>
      {#code_begin|test#}
const std = @import("std");
const maxInt = std.math.maxInt;

pub fn parseU64(buf: []const u8, radix: u8) !u64 {
    var x: u64 = 0;

    for (buf) |c| {
        const digit = charToDigit(c);

        if (digit >= radix) {
            return error.InvalidChar;
        }

        // x *= radix
        if (@mulWithOverflow(u64, x, radix, &x)) {
            return error.Overflow;
        }

        // x += digit
        if (@addWithOverflow(u64, x, digit, &x)) {
            return error.Overflow;
        }
    }

    return x;
}

fn charToDigit(c: u8) u8 {
    return switch (c) {
        '0' ... '9' => c - '0',
        'A' ... 'Z' => c - 'A' + 10,
        'a' ... 'z' => c - 'a' + 10,
        else => maxInt(u8),
    };
}

test "parse u64" {
    const result = try parseU64("1234", 10);
    std.debug.assert(result == 1234);
}
      {#code_end#}
      <p>
      Notice the return type is {#syntax#}!u64{#endsyntax#}. This means that the function
      either returns an unsigned 64 bit integer, or an error. We left off the error set
      to the left of the {#syntax#}!{#endsyntax#}, so the error set is inferred.
      </p>
      <p>
      Within the function definition, you can see some return statements that return
      an error, and at the bottom a return statement that returns a {#syntax#}u64{#endsyntax#}.
          Both types {#link|implicitly cast|Implicit Casts#} to {#syntax#}anyerror!u64{#endsyntax#}.
      </p>
      <p>
      What it looks like to use this function varies depending on what you're
      trying to do. One of the following:
      </p>
      <ul>
        <li>You want to provide a default value if it returned an error.</li>
        <li>If it returned an error then you want to return the same error.</li>
        <li>You know with complete certainty it will not return an error, so want to unconditionally unwrap it.</li>
        <li>You want to take a different action for each possible error.</li>
      </ul>
      {#header_open|catch#}
      <p>If you want to provide a default value, you can use the {#syntax#}catch{#endsyntax#} binary operator:</p>
      {#code_begin|syntax#}
fn doAThing(str: []u8) void {
    const number = parseU64(str, 10) catch 13;
    // ...
}
      {#code_end#}
      <p>
      In this code, {#syntax#}number{#endsyntax#} will be equal to the successfully parsed string, or
          a default value of 13. The type of the right hand side of the binary {#syntax#}catch{#endsyntax#} operator must
              match the unwrapped error union type, or be of type {#syntax#}noreturn{#endsyntax#}.
      </p>
      {#header_close#}
      {#header_open|try#}
      <p>Let's say you wanted to return the error if you got one, otherwise continue with the
      function logic:</p>
      {#code_begin|syntax#}
fn doAThing(str: []u8) !void {
    const number = parseU64(str, 10) catch |err| return err;
    // ...
}
      {#code_end#}
      <p>
      There is a shortcut for this. The {#syntax#}try{#endsyntax#} expression:
      </p>
      {#code_begin|syntax#}
fn doAThing(str: []u8) !void {
    const number = try parseU64(str, 10);
    // ...
}
      {#code_end#}
      <p>
      {#syntax#}try{#endsyntax#} evaluates an error union expression. If it is an error, it returns
      from the current function with the same error. Otherwise, the expression results in
      the unwrapped value.
      </p>
      {#header_close#}
      <p>
        Maybe you know with complete certainty that an expression will never be an error.
        In this case you can do this:
      </p>
      {#code_begin|syntax#}const number = parseU64("1234", 10) catch unreachable;{#code_end#}
      <p>
      Here we know for sure that "1234" will parse successfully. So we put the
      {#syntax#}unreachable{#endsyntax#} value on the right hand side. {#syntax#}unreachable{#endsyntax#} generates
      a panic in Debug and ReleaseSafe modes and undefined behavior in ReleaseFast mode. So, while we're debugging the
      application, if there <em>was</em> a surprise error here, the application would crash
      appropriately.
      </p>
      <p>
      Finally, you may want to take a different action for every situation. For that, we combine
      the {#link|if#} and {#link|switch#} expression:
      </p>
      {#code_begin|syntax#}
fn doAThing(str: []u8) void {
    if (parseU64(str, 10)) |number| {
        doSomethingWithNumber(number);
    } else |err| switch (err) {
        error.Overflow => {
            // handle overflow...
        },
        // we promise that InvalidChar won't happen (or crash in debug mode if it does)
        error.InvalidChar => unreachable,
    }
}
      {#code_end#}
      {#header_open|errdefer#}
      <p>
      The other component to error handling is defer statements.
      In addition to an unconditional {#link|defer#}, Zig has {#syntax#}errdefer{#endsyntax#},
      which evaluates the deferred expression on block exit path if and only if
      the function returned with an error from the block.
      </p>
      <p>
      Example:
      </p>
      {#code_begin|syntax#}
fn createFoo(param: i32) !Foo {
    const foo = try tryToAllocateFoo();
    // now we have allocated foo. we need to free it if the function fails.
    // but we want to return it if the function succeeds.
    errdefer deallocateFoo(foo);

    const tmp_buf = allocateTmpBuffer() orelse return error.OutOfMemory;
    // tmp_buf is truly a temporary resource, and we for sure want to clean it up
    // before this block leaves scope
    defer deallocateTmpBuffer(tmp_buf);

    if (param > 1337) return error.InvalidParam;

    // here the errdefer will not run since we're returning success from the function.
    // but the defer will run!
    return foo;
}
      {#code_end#}
      <p>
      The neat thing about this is that you get robust error handling without
      the verbosity and cognitive overhead of trying to make sure every exit path
      is covered. The deallocation code is always directly following the allocation code.
      </p>
      {#header_close#}
      <p>
      A couple of other tidbits about error handling:
      </p>
      <ul>
        <li>These primitives give enough expressiveness that it's completely practical
            to have failing to check for an error be a compile error. If you really want
            to ignore the error, you can add {#syntax#}catch unreachable{#endsyntax#} and
            get the added benefit of crashing in Debug and ReleaseSafe modes if your assumption was wrong.
        </li>
        <li>
          Since Zig understands error types, it can pre-weight branches in favor of
          errors not occurring. Just a small optimization benefit that is not available
          in other languages.
        </li>
      </ul>
      {#see_also|defer|if|switch#}

      <p>An error union is created with the {#syntax#}!{#endsyntax#} binary operator.
      You can use compile-time reflection to access the child type of an error union:</p>
      {#code_begin|test#}
const assert = @import("std").debug.assert;

test "error union" {
    var foo: anyerror!i32 = undefined;

    // Implicitly cast from child type of an error union:
    foo = 1234;

    // Implicitly cast from an error set:
    foo = error.SomeError;

    // Use compile-time reflection to access the payload type of an error union:
    comptime assert(@typeOf(foo).Payload == i32);

    // Use compile-time reflection to access the error set type of an error union:
    comptime assert(@typeOf(foo).ErrorSet == anyerror);
}
      {#code_end#}
      {#header_open|Merging Error Sets#}
      <p>
      Use the {#syntax#}||{#endsyntax#} operator to merge two error sets together. The resulting
      error set contains the errors of both error sets. Doc comments from the left-hand
      side override doc comments from the right-hand side. In this example, the doc
      comments for {#syntax#}C.PathNotFound{#endsyntax#} is <code>A doc comment</code>.
      </p>
      <p>
      This is especially useful for functions which return different error sets depending
      on {#link|comptime#} branches. For example, the Zig standard library uses
      {#syntax#}LinuxFileOpenError || WindowsFileOpenError{#endsyntax#} for the error set of opening
      files.
      </p>
      {#code_begin|test#}
const A = error{
    NotDir,

    /// A doc comment
    PathNotFound,
};
const B = error{
    OutOfMemory,

    /// B doc comment
    PathNotFound,
};

const C = A || B;

fn foo() C!void {
    return error.NotDir;
}

test "merge error sets" {
    if (foo()) {
        @panic("unexpected");
    } else |err| switch (err) {
        error.OutOfMemory => @panic("unexpected"),
        error.PathNotFound => @panic("unexpected"),
        error.NotDir => {},
    }
}
      {#code_end#}
      {#header_close#}
      {#header_open|Inferred Error Sets#}
      <p>
      Because many functions in Zig return a possible error, Zig supports inferring the error set.
      To infer the error set for a function, use this syntax:
      </p>
{#code_begin|test#}
// With an inferred error set
pub fn add_inferred(comptime T: type, a: T, b: T) !T {
    var answer: T = undefined;
    return if (@addWithOverflow(T, a, b, &answer)) error.Overflow else answer;
}

// With an explicit error set
pub fn add_explicit(comptime T: type, a: T, b: T) Error!T {
    var answer: T = undefined;
    return if (@addWithOverflow(T, a, b, &answer)) error.Overflow else answer;
}

const Error = error {
    Overflow,
};

const std = @import("std");

test "inferred error set" {
    if (add_inferred(u8, 255, 1)) |_| unreachable else |err| switch (err) {
        error.Overflow => {}, // ok
    }
}
{#code_end#}
      <p>
      When a function has an inferred error set, that function becomes generic and thus it becomes
      trickier to do certain things with it, such as obtain a function pointer, or have an error
      set that is consistent across different build targets. Additionally, inferred error sets
      are incompatible with recursion.
      </p>
      <p>
      In these situations, it is recommended to use an explicit error set. You can generally start
      with an empty error set and let compile errors guide you toward completing the set.
      </p>
      <p>
      These limitations may be overcome in a future version of Zig.
      </p>
      {#header_close#}
      {#header_close#}
      {#header_open|Error Return Traces#}
      <p>
      Error Return Traces show all the points in the code that an error was returned to the calling function. This makes it practical to use {#link|try#} everywhere and then still be able to know what happened if an error ends up bubbling all the way out of your application.
      </p>
      {#code_begin|exe_err#}
pub fn main() !void {
    try foo(12);
}

fn foo(x: i32) !void {
    if (x >= 5) {
        try bar();
    } else {
        try bang2();
    }
}

fn bar() !void {
    if (baz()) {
        try quux();
    } else |err| switch (err) {
        error.FileNotFound => try hello(),
        else => try another(),
    }
}

fn baz() !void {
    try bang1();
}

fn quux() !void {
    try bang2();
}

fn hello() !void {
    try bang2();
}

fn another() !void {
    try bang1();
}

fn bang1() !void {
    return error.FileNotFound;
}

fn bang2() !void {
    return error.PermissionDenied;
}
      {#code_end#}
      <p>
      Look closely at this example. This is no stack trace.
      </p>
      <p>
      You can see that the final error bubbled up was {#syntax#}PermissionDenied{#endsyntax#},
          but the original error that started this whole thing was {#syntax#}FileNotFound{#endsyntax#}. In the {#syntax#}bar{#endsyntax#} function, the code handles the original error code,
      and then returns another one, from the switch statement. Error Return Traces make this clear, whereas a stack trace would look like this:
      </p>
      {#code_begin|exe_err#}
pub fn main() void {
    foo(12);
}

fn foo(x: i32) void {
    if (x >= 5) {
        bar();
    } else {
        bang2();
    }
}

fn bar() void {
    if (baz()) {
        quux();
    } else {
        hello();
    }
}

fn baz() bool {
    return bang1();
}

fn quux() void {
    bang2();
}

fn hello() void {
    bang2();
}

fn bang1() bool {
    return false;
}

fn bang2() void {
    @panic("PermissionDenied");
}
      {#code_end#}
      <p>
      Here, the stack trace does not explain how the control
      flow in {#syntax#}bar{#endsyntax#} got to the {#syntax#}hello(){#endsyntax#} call.
      One would have to open a debugger or further instrument the application
      in order to find out. The error return trace, on the other hand, 
      shows exactly how the error bubbled up.
      </p>
      <p>
      This debugging feature makes it easier to iterate quickly on code that
      robustly handles all error conditions. This means that Zig developers
      will naturally find themselves writing correct, robust code in order
      to increase their development pace.
      </p>
      <p>
      Error Return Traces are enabled by default in {#link|Debug#} and {#link|ReleaseSafe#} builds and disabled by default in {#link|ReleaseFast#} and {#link|ReleaseSmall#} builds.
      </p>
      <p>
      There are a few ways to activate this error return tracing feature:
      </p>
      <ul>
        <li>Return an error from main</li>
        <li>An error makes its way to {#syntax#}catch unreachable{#endsyntax#} and you have not overridden the default panic handler</li>
        <li>Use {#link|errorReturnTrace#} to access the current return trace. You can use {#syntax#}std.debug.dumpStackTrace{#endsyntax#} to print it. This function returns comptime-known {#link|null#} when building without error return tracing support.</li>
      </ul>
      {#header_open|Implementation Details#}
      <p>
      To analyze performance cost, there are two cases:
      </p>
      <ul>
        <li>when no errors are returned</li>
        <li>when returning errors</li>
      </ul>
      <p>
      For the case when no errors are returned, the cost is a single memory write operation, only in the first non-failable function in the call graph that calls a failable function, i.e. when a function returning {#syntax#}void{#endsyntax#} calls a function returning {#syntax#}error{#endsyntax#}.
      This is to initialize this struct in the stack memory:
      </p>
      {#code_begin|syntax#}
pub const StackTrace = struct {
    index: usize,
    instruction_addresses: [N]usize,
};
      {#code_end#}
      <p>
      Here, N is the maximum function call depth as determined by call graph analysis. Recursion is ignored and counts for 2.
      </p>
      <p>
      A pointer to {#syntax#}StackTrace{#endsyntax#} is passed as a secret parameter to every function that can return an error, but it's always the first parameter, so it can likely sit in a register and stay there.
      </p>
      <p>
      That's it for the path when no errors occur. It's practically free in terms of performance.
      </p>
      <p>
      When generating the code for a function that returns an error, just before the {#syntax#}return{#endsyntax#} statement (only for the {#syntax#}return{#endsyntax#} statements that return errors), Zig generates a call to this function:
      </p>
      {#code_begin|syntax#}
// marked as "no-inline" in LLVM IR
fn __zig_return_error(stack_trace: *StackTrace) void {
    stack_trace.instruction_addresses[stack_trace.index] = @returnAddress();
    stack_trace.index = (stack_trace.index + 1) % N;
}
      {#code_end#}
      <p>
      The cost is 2 math operations plus some memory reads and writes. The memory accessed is constrained and should remain cached for the duration of the error return bubbling.
      </p>
      <p>
      As for code size cost, 1 function call before a return statement is no big deal. Even so,
      I have <a href="https://github.com/ziglang/zig/issues/690">a plan</a> to make the call to
      {#syntax#}__zig_return_error{#endsyntax#} a tail call, which brings the code size cost down to actually zero. What is a return statement in code without error return tracing can become a jump instruction in code with error return tracing.
      </p>
      {#header_close#}
      {#header_close#}
      {#header_close#}
      {#header_open|Optionals#}
      <p>
      One area that Zig provides safety without compromising efficiency or
      readability is with the optional type.
      </p>
      <p>
      The question mark symbolizes the optional type. You can convert a type to an optional
      type by putting a question mark in front of it, like this:
      </p>
      {#code_begin|syntax#}
// normal integer
const normal_int: i32 = 1234;

// optional integer
const optional_int: ?i32 = 5678;
      {#code_end#}
      <p>
      Now the variable {#syntax#}optional_int{#endsyntax#} could be an {#syntax#}i32{#endsyntax#}, or {#syntax#}null{#endsyntax#}.
      </p>
      <p>
      Instead of integers, let's talk about pointers. Null references are the source of many runtime
      exceptions, and even stand accused of being
      <a href="https://www.lucidchart.com/techblog/2015/08/31/the-worst-mistake-of-computer-science/">the worst mistake of computer science</a>.
      </p>
      <p>Zig does not have them.</p>
      <p>
      Instead, you can use an optional pointer. This secretly compiles down to a normal pointer,
      since we know we can use 0 as the null value for the optional type. But the compiler
      can check your work and make sure you don't assign null to something that can't be null.
      </p>
      <p>
      Typically the downside of not having null is that it makes the code more verbose to
      write. But, let's compare some equivalent C code and Zig code.
      </p>
      <p>
      Task: call malloc, if the result is null, return null.
      </p>
      <p>C code</p>
      <pre><code class="cpp">// malloc prototype included for reference
void *malloc(size_t size);

struct Foo *do_a_thing(void) {
    char *ptr = malloc(1234);
    if (!ptr) return NULL;
    // ...
}</code></pre>
      <p>Zig code</p>
      {#code_begin|syntax#}
// malloc prototype included for reference
extern fn malloc(size: size_t) ?*u8;

fn doAThing() ?*Foo {
    const ptr = malloc(1234) orelse return null;
    // ...
}
      {#code_end#}
      <p>
        Here, Zig is at least as convenient, if not more, than C. And, the type of "ptr"
        is {#syntax#}*u8{#endsyntax#} <em>not</em> {#syntax#}?*u8{#endsyntax#}. The {#syntax#}orelse{#endsyntax#} keyword
                    unwrapped the optional type and therefore {#syntax#}ptr{#endsyntax#} is guaranteed to be non-null everywhere
        it is used in the function.
      </p>
      <p>
        The other form of checking against NULL you might see looks like this:
      </p>
      <pre><code class="cpp">void do_a_thing(struct Foo *foo) {
    // do some stuff

    if (foo) {
        do_something_with_foo(foo);
    }

    // do some stuff
}</code></pre>
      <p>
        In Zig you can accomplish the same thing:
      </p>
      {#code_begin|syntax#}
fn doAThing(optional_foo: ?*Foo) void {
    // do some stuff

    if (optional_foo) |foo| {
      doSomethingWithFoo(foo);
    }

    // do some stuff
}
      {#code_end#}
      <p>
      Once again, the notable thing here is that inside the if block,
      {#syntax#}foo{#endsyntax#} is no longer an optional pointer, it is a pointer, which
      cannot be null.
      </p>
      <p>
      One benefit to this is that functions which take pointers as arguments can
      be annotated with the "nonnull" attribute - <code>__attribute__((nonnull))</code> in
      <a href="https://gcc.gnu.org/onlinedocs/gcc-4.0.0/gcc/Function-Attributes.html">GCC</a>.
      The optimizer can sometimes make better decisions knowing that pointer arguments
      cannot be null.
      </p>
      {#header_open|Optional Type#}
      <p>An optional is created by putting {#syntax#}?{#endsyntax#} in front of a type. You can use compile-time
      reflection to access the child type of an optional:</p>
      {#code_begin|test#}
const assert = @import("std").debug.assert;

test "optional type" {
    // Declare an optional and implicitly cast from null:
    var foo: ?i32 = null;

    // Implicitly cast from child type of an optional
    foo = 1234;

    // Use compile-time reflection to access the child type of the optional:
    comptime assert(@typeOf(foo).Child == i32);
}
      {#code_end#}
      {#header_close#}
      {#header_open|null#}
      <p>
      Just like {#link|undefined#}, {#syntax#}null{#endsyntax#} has its own type, and the only way to use it is to
      cast it to a different type:
      </p>
      {#code_begin|syntax#}
const optional_value: ?i32 = null; 
      {#code_end#}
      {#header_close#}
      {#header_open|Optional Pointers#}
      <p>An optional pointer is guaranteed to be the same size as a pointer. The {#syntax#}null{#endsyntax#} of
      the optional is guaranteed to be address 0.</p>
      {#code_begin|test#}
const assert = @import("std").debug.assert;

test "optional pointers" {
    // Pointers cannot be null. If you want a null pointer, use the optional
    // prefix `?` to make the pointer type optional.
    var ptr: ?*i32 = null;

    var x: i32 = 1;
    ptr = &x;

    assert(ptr.?.* == 1);

    // Optional pointers are the same size as normal pointers, because pointer
    // value 0 is used as the null value.
    assert(@sizeOf(?*i32) == @sizeOf(*i32));
}
      {#code_end#}
      {#header_close#}
      {#header_close#}
      {#header_open|Casting#}
      <p>
      A <strong>type cast</strong> converts a value of one type to another.
      Zig has {#link|Implicit Casts#} for conversions that are known to be completely safe and unambiguous,
      and {#link|Explicit Casts#} for conversions that one would not want to happen on accident.
      There is also a third kind of type conversion called {#link|Peer Type Resolution#} for
      the case when a result type must be decided given multiple operand types.
      </p>
      {#header_open|Implicit Casts#}
      <p>
      An implicit cast occurs when one type is expected, but different type is provided:
      </p>
      {#code_begin|test#}
test "implicit cast - variable declaration" {
    var a: u8 = 1;
    var b: u16 = a;
}

test "implicit cast - function call" {
    var a: u8 = 1;
    foo(a);
}

fn foo(b: u16) void {}

test "implicit cast - invoke a type as a function" {
    var a: u8 = 1;
    var b = u16(a);
}
      {#code_end#}
      <p>
      Implicit casts are only allowed when it is completely unambiguous how to get from one type to another,
      and the transformation is guaranteed to be safe.
      </p>
      {#header_open|Implicit Cast: Stricter Qualification#}
      <p>
      Values which have the same representation at runtime can be cast to increase the strictness
      of the qualifiers, no matter how nested the qualifiers are:
      </p>
      <ul>
          <li>{#syntax#}const{#endsyntax#} - non-const to const is allowed</li>
          <li>{#syntax#}volatile{#endsyntax#} - non-volatile to volatile is allowed</li>
          <li>{#syntax#}align{#endsyntax#} - bigger to smaller alignment is allowed </li>
          <li>{#link|error sets|Error Set Type#} to supersets is allowed</li>
      </ul>
      <p>
      These casts are no-ops at runtime since the value representation does not change.
      </p>
      {#code_begin|test#}
test "implicit cast - const qualification" {
    var a: i32 = 1;
    var b: *i32 = &a;
    foo(b);
}

fn foo(a: *const i32) void {}
      {#code_end#}
      <p>
      In addition, pointers implicitly cast to const optional pointers:
      </p>
      {#code_begin|test#}
const std = @import("std");
const assert = std.debug.assert;
const mem = std.mem;

test "cast *[1][*]const u8 to [*]const ?[*]const u8" {
    const window_name = [1][*]const u8{c"window name"};
    const x: [*]const ?[*]const u8 = &window_name;
    assert(mem.eql(u8, std.cstr.toSliceConst(x[0].?), "window name"));
}
      {#code_end#}
      {#header_close#}
      {#header_open|Implicit Cast: Integer and Float Widening#}
      <p>
      {#link|Integers#} implicitly cast to integer types which can represent every value of the old type, and likewise
      {#link|Floats#} implicitly cast to float types which can represent every value of the old type.
      </p>
      {#code_begin|test#}
const std = @import("std");
const assert = std.debug.assert;
const mem = std.mem;

test "integer widening" {
    var a: u8 = 250;
    var b: u16 = a;
    var c: u32 = b;
    var d: u64 = c;
    var e: u64 = d;
    var f: u128 = e;
    assert(f == a);
}

test "implicit unsigned integer to signed integer" {
    var a: u8 = 250;
    var b: i16 = a;
    assert(b == 250);
}

test "float widening" {
    var a: f16 = 12.34;
    var b: f32 = a;
    var c: f64 = b;
    var d: f128 = c;
    assert(d == a);
}
      {#code_end#}
      {#header_close#}
      {#header_open|Implicit Cast: Arrays#}
      <p>TODO: [N]T to []const T</p>
      <p>TODO: *const [N]T to []const T</p>
      <p>TODO: [N]T to *const []const T</p>
      <p>TODO: [N]T to ?[]const T</p>
      <p>TODO: *[N]T to []T</p>
      <p>TODO: *[N]T to [*]T</p>
      <p>TODO: *[N]T to ?[*]T</p>
      <p>TODO: *T to *[1]T</p>
      <p>TODO: [N]T to E![]const T</p>
      {#header_close#}
      {#header_open|Implicit Cast: Optionals#}
      <p>TODO: T to ?T</p>
      <p>TODO: T to E!?T</p>
      <p>TODO: null to ?T</p>
      {#header_close#}
      {#header_open|Implicit Cast: T to E!T#}
      <p>TODO</p>
      {#header_close#}
      {#header_open|Implicit Cast: E to E!T#}
      <p>TODO</p>
      {#header_close#}
      {#header_open|Implicit Cast: compile-time known numbers#}
      <p>TODO</p>
      {#header_close#}
      {#header_open|Implicit Cast: union to enum#}
      <p>TODO</p>
      {#header_close#}
      {#header_open|Implicit Cast: enum to union#}
      <p>TODO</p>
      {#header_close#}
      {#header_open|Implicit Cast: T to *T when @sizeOf(T) == 0#}
      <p>TODO</p>
      {#header_close#}
      {#header_open|Implicit Cast: undefined#}
      <p>TODO</p>
      {#header_close#}
      {#header_close#}

      {#header_open|Explicit Casts#}
      <p>
      Explicit casts are performed via {#link|Builtin Functions#}.
      Some explicit casts are safe; some are not.
      Some explicit casts perform language-level assertions; some do not.
      Some explicit casts are no-ops at runtime; some are not.
      </p>
      <ul>
          <li>{#link|@bitCast#} - change type but maintain bit representation</li>
          <li>{#link|@alignCast#} - make a pointer have more alignment</li>
          <li>{#link|@boolToInt#} - convert true to 1 and false to 0</li>
          <li>{#link|@bytesToSlice#} - convert a slice of bytes to a slice of another type</li>
          <li>{#link|@enumToInt#} - obtain the integer tag value of an enum or tagged union</li>
          <li>{#link|@errSetCast#} - convert to a smaller error set</li>
          <li>{#link|@errorToInt#} - obtain the integer value of an error code</li>
          <li>{#link|@floatCast#} - convert a larger float to a smaller float</li>
          <li>{#link|@floatToInt#} - obtain the integer part of a float value</li>
          <li>{#link|@intCast#} - convert between integer types</li>
          <li>{#link|@intToEnum#} - obtain an enum value based on its integer tag value</li>
          <li>{#link|@intToError#} - obtain an error code based on its integer value</li>
          <li>{#link|@intToFloat#} - convert an integer to a float value</li>
          <li>{#link|@intToPtr#} - convert an address to a pointer</li>
          <li>{#link|@ptrCast#} - convert between pointer types</li>
          <li>{#link|@ptrToInt#} - obtain the address of a pointer</li>
          <li>{#link|@sliceToBytes#} - convert a slice of anything to a slice of bytes</li>
          <li>{#link|@truncate#} - convert between integer types, chopping off bits</li>
      </ul>
      {#header_close#}

      {#header_open|Peer Type Resolution#}
      <p>Peer Type Resolution occurs in these places:</p>
      <ul>
        <li>{#link|switch#} expressions</li>
        <li>{#link|if#} expressions</li>
        <li>{#link|while#} expressions</li>
        <li>{#link|for#} expressions</li>
        <li>Multiple break statements in a block</li>
        <li>Some {#link|binary operations|Table of Operators#}</li>
      </ul>
      <p>
      This kind of type resolution chooses a type that all peer types can implicitly cast into. Here are
      some examples:
      </p>
      {#code_begin|test#}
const std = @import("std");
const assert = std.debug.assert;
const mem = std.mem;

test "peer resolve int widening" {
    var a: i8 = 12;
    var b: i16 = 34;
    var c = a + b;
    assert(c == 46);
    assert(@typeOf(c) == i16);
}

test "peer resolve arrays of different size to const slice" {
    assert(mem.eql(u8, boolToStr(true), "true"));
    assert(mem.eql(u8, boolToStr(false), "false"));
    comptime assert(mem.eql(u8, boolToStr(true), "true"));
    comptime assert(mem.eql(u8, boolToStr(false), "false"));
}
fn boolToStr(b: bool) []const u8 {
    return if (b) "true" else "false";
}

test "peer resolve array and const slice" {
    testPeerResolveArrayConstSlice(true);
    comptime testPeerResolveArrayConstSlice(true);
}
fn testPeerResolveArrayConstSlice(b: bool) void {
    const value1 = if (b) "aoeu" else ([]const u8)("zz");
    const value2 = if (b) ([]const u8)("zz") else "aoeu";
    assert(mem.eql(u8, value1, "aoeu"));
    assert(mem.eql(u8, value2, "zz"));
}

test "peer type resolution: ?T and T" {
    assert(peerTypeTAndOptionalT(true, false).? == 0);
    assert(peerTypeTAndOptionalT(false, false).? == 3);
    comptime {
        assert(peerTypeTAndOptionalT(true, false).? == 0);
        assert(peerTypeTAndOptionalT(false, false).? == 3);
    }
}
fn peerTypeTAndOptionalT(c: bool, b: bool) ?usize {
    if (c) {
        return if (b) null else usize(0);
    }

    return usize(3);
}

test "peer type resolution: [0]u8 and []const u8" {
    assert(peerTypeEmptyArrayAndSlice(true, "hi").len == 0);
    assert(peerTypeEmptyArrayAndSlice(false, "hi").len == 1);
    comptime {
        assert(peerTypeEmptyArrayAndSlice(true, "hi").len == 0);
        assert(peerTypeEmptyArrayAndSlice(false, "hi").len == 1);
    }
}
fn peerTypeEmptyArrayAndSlice(a: bool, slice: []const u8) []const u8 {
    if (a) {
        return []const u8{};
    }

    return slice[0..1];
}
test "peer type resolution: [0]u8, []const u8, and anyerror![]u8" {
    {
        var data = "hi";
        const slice = data[0..];
        assert((try peerTypeEmptyArrayAndSliceAndError(true, slice)).len == 0);
        assert((try peerTypeEmptyArrayAndSliceAndError(false, slice)).len == 1);
    }
    comptime {
        var data = "hi";
        const slice = data[0..];
        assert((try peerTypeEmptyArrayAndSliceAndError(true, slice)).len == 0);
        assert((try peerTypeEmptyArrayAndSliceAndError(false, slice)).len == 1);
    }
}
fn peerTypeEmptyArrayAndSliceAndError(a: bool, slice: []u8) anyerror![]u8 {
    if (a) {
        return []u8{};
    }

    return slice[0..1];
}
      {#code_end#}
      {#header_close#}
      {#header_close#}

      {#header_open|void#}
      <p>
      {#syntax#}void{#endsyntax#} represents a type that has no value. Code that makes use of void values is
      not included in the final generated code:
      </p>
      {#code_begin|syntax#}
export fn entry() void {
    var x: void = {};
    var y: void = {};
    x = y;
}
      {#code_end#}
      <p>When this turns into LLVM IR, there is no code generated in the body of {#syntax#}entry{#endsyntax#},
      even in debug mode. For example, on x86_64:</p>
      <pre><code>0000000000000010 &lt;entry&gt;:
  10:	55                   	push   %rbp
  11:	48 89 e5             	mov    %rsp,%rbp
  14:	5d                   	pop    %rbp
  15:	c3                   	retq   </code></pre>
      <p>These assembly instructions do not have any code associated with the void values -
      they only perform the function call prologue and epilog.</p>
      <p>
      {#syntax#}void{#endsyntax#} can be useful for instantiating generic types. For example, given a
          {#syntax#}Map(Key, Value){#endsyntax#}, one can pass {#syntax#}void{#endsyntax#} for the {#syntax#}Value{#endsyntax#}
                      type to make it into a {#syntax#}Set{#endsyntax#}:
      </p>
      {#code_begin|test#}
const std = @import("std");
const assert = std.debug.assert;

test "turn HashMap into a set with void" {
    var map = std.HashMap(i32, void, hash_i32, eql_i32).init(std.debug.global_allocator);
    defer map.deinit();

    _ = try map.put(1, {});
    _ = try map.put(2, {});

    assert(map.contains(2));
    assert(!map.contains(3));

    _ = map.remove(2);
    assert(!map.contains(2));
}

fn hash_i32(x: i32) u32 {
    return @bitCast(u32, x);
}

fn eql_i32(a: i32, b: i32) bool {
    return a == b;
}
      {#code_end#}
      <p>Note that this is different than using a dummy value for the hash map value.
      By using {#syntax#}void{#endsyntax#} as the type of the value, the hash map entry type has no value field, and
      thus the hash map takes up less space. Further, all the code that deals with storing and loading the
      value is deleted, as seen above.
      </p>
      <p>
      {#syntax#}void{#endsyntax#} is distinct from {#syntax#}c_void{#endsyntax#}, which is defined like this:
              {#syntax#}pub const c_void = @OpaqueType();{#endsyntax#}.
                  {#syntax#}void{#endsyntax#} has a known size of 0 bytes, and {#syntax#}c_void{#endsyntax#} has an unknown, but non-zero, size.
      </p>
      <p>
      Expressions of type {#syntax#}void{#endsyntax#} are the only ones whose value can be ignored. For example:
      </p>
      {#code_begin|test_err|expression value is ignored#}
test "ignoring expression value" {
    foo();
}

fn foo() i32 {
    return 1234;
}
      {#code_end#}
      <p>However, if the expression has type {#syntax#}void{#endsyntax#}:</p>
      {#code_begin|test#}
test "ignoring expression value" {
    foo();
}

fn foo() void {}
      {#code_end#}
      {#header_close#}

      {#header_open|comptime#}
      <p>
      Zig places importance on the concept of whether an expression is known at compile-time.
      There are a few different places this concept is used, and these building blocks are used
      to keep the language small, readable, and powerful.
      </p>
      {#header_open|Introducing the Compile-Time Concept#}
      {#header_open|Compile-Time Parameters#}
      <p>
      Compile-time parameters is how Zig implements generics. It is compile-time duck typing.
      </p>
      {#code_begin|syntax#}
fn max(comptime T: type, a: T, b: T) T {
    return if (a > b) a else b;
}
fn gimmeTheBiggerFloat(a: f32, b: f32) f32 {
    return max(f32, a, b);
}
fn gimmeTheBiggerInteger(a: u64, b: u64) u64 {
    return max(u64, a, b);
}
      {#code_end#}
      <p>
      In Zig, types are first-class citizens. They can be assigned to variables, passed as parameters to functions,
      and returned from functions. However, they can only be used in expressions which are known at <em>compile-time</em>,
      which is why the parameter {#syntax#}T{#endsyntax#} in the above snippet must be marked with {#syntax#}comptime{#endsyntax#}.
      </p>
      <p>
      A {#syntax#}comptime{#endsyntax#} parameter means that:
      </p>
      <ul>
        <li>At the callsite, the value must be known at compile-time, or it is a compile error.</li>
        <li>In the function definition, the value is known at compile-time.</li>
      </ul>
      <p>
      </p>
      <p>
      For example, if we were to introduce another function to the above snippet:
      </p>
      {#code_begin|test_err|unable to evaluate constant expression#}
fn max(comptime T: type, a: T, b: T) T {
    return if (a > b) a else b;
}
test "try to pass a runtime type" {
    foo(false);
}
fn foo(condition: bool) void {
    const result = max(
        if (condition) f32 else u64,
        1234,
        5678);
}
      {#code_end#}
      <p>
      This is an error because the programmer attempted to pass a value only known at run-time
      to a function which expects a value known at compile-time.
      </p>
      <p>
      Another way to get an error is if we pass a type that violates the type checker when the
      function is analyzed. This is what it means to have <em>compile-time duck typing</em>.
      </p>
      <p>
      For example:
      </p>
      {#code_begin|test_err|operator not allowed for type 'bool'#}
fn max(comptime T: type, a: T, b: T) T {
    return if (a > b) a else b;
}
test "try to compare bools" {
    _ = max(bool, true, false);
}
      {#code_end#}
      <p>
      On the flip side, inside the function definition with the {#syntax#}comptime{#endsyntax#} parameter, the
      value is known at compile-time. This means that we actually could make this work for the bool type
      if we wanted to:
      </p>
      {#code_begin|test#}
fn max(comptime T: type, a: T, b: T) T {
    if (T == bool) {
        return a or b;
    } else if (a > b) {
        return a;
    } else {
        return b;
    }
}
test "try to compare bools" {
    @import("std").debug.assert(max(bool, false, true) == true);
}
      {#code_end#}
      <p>
      This works because Zig implicitly inlines {#syntax#}if{#endsyntax#} expressions when the condition
      is known at compile-time, and the compiler guarantees that it will skip analysis of
      the branch not taken.
      </p>
      <p>
      This means that the actual function generated for {#syntax#}max{#endsyntax#} in this situation looks like
      this:
      </p>
      {#code_begin|syntax#}
fn max(a: bool, b: bool) bool {
    return a or b;
}
      {#code_end#}
      <p>
      All the code that dealt with compile-time known values is eliminated and we are left with only
      the necessary run-time code to accomplish the task.
      </p>
      <p>
      This works the same way for {#syntax#}switch{#endsyntax#} expressions - they are implicitly inlined
      when the target expression is compile-time known.
      </p>
      {#header_close#}
      {#header_open|Compile-Time Variables#}
      <p>
      In Zig, the programmer can label variables as {#syntax#}comptime{#endsyntax#}. This guarantees to the compiler
      that every load and store of the variable is performed at compile-time. Any violation of this results in a
      compile error.
      </p>
      <p>
      This combined with the fact that we can {#syntax#}inline{#endsyntax#} loops allows us to write
      a function which is partially evaluated at compile-time and partially at run-time.
      </p>
      <p>
      For example:
      </p>
      {#code_begin|test|comptime_vars#}
const assert = @import("std").debug.assert;

const CmdFn = struct {
    name: []const u8,
    func: fn(i32) i32,
};

const cmd_fns = []CmdFn{
    CmdFn {.name = "one", .func = one},
    CmdFn {.name = "two", .func = two},
    CmdFn {.name = "three", .func = three},
};
fn one(value: i32) i32 { return value + 1; }
fn two(value: i32) i32 { return value + 2; }
fn three(value: i32) i32 { return value + 3; }

fn performFn(comptime prefix_char: u8, start_value: i32) i32 {
    var result: i32 = start_value;
    comptime var i = 0;
    inline while (i < cmd_fns.len) : (i += 1) {
        if (cmd_fns[i].name[0] == prefix_char) {
            result = cmd_fns[i].func(result);
        }
    }
    return result;
}

test "perform fn" {
    assert(performFn('t', 1) == 6);
    assert(performFn('o', 0) == 1);
    assert(performFn('w', 99) == 99);
}
      {#code_end#}
      <p>
      This example is a bit contrived, because the compile-time evaluation component is unnecessary;
      this code would work fine if it was all done at run-time. But it does end up generating
      different code. In this example, the function {#syntax#}performFn{#endsyntax#} is generated three different times,
          for the different values of {#syntax#}prefix_char{#endsyntax#} provided:
      </p>
      {#code_begin|syntax#}
// From the line:
// assert(performFn('t', 1) == 6);
fn performFn(start_value: i32) i32 {
    var result: i32 = start_value;
    result = two(result);
    result = three(result);
    return result;
}
      {#code_end#}
      {#code_begin|syntax#}
// From the line:
// assert(performFn('o', 0) == 1);
fn performFn(start_value: i32) i32 {
    var result: i32 = start_value;
    result = one(result);
    return result;
}
      {#code_end#}
      {#code_begin|syntax#}
// From the line:
// assert(performFn('w', 99) == 99);
fn performFn(start_value: i32) i32 {
    var result: i32 = start_value;
    return result;
}
      {#code_end#}
      <p>
      Note that this happens even in a debug build; in a release build these generated functions still
      pass through rigorous LLVM optimizations. The important thing to note, however, is not that this
      is a way to write more optimized code, but that it is a way to make sure that what <em>should</em> happen
      at compile-time, <em>does</em> happen at compile-time. This catches more errors and as demonstrated
      later in this article, allows expressiveness that in other languages requires using macros,
      generated code, or a preprocessor to accomplish.
      </p>
      {#header_close#}
      {#header_open|Compile-Time Expressions#}
      <p>
      In Zig, it matters whether a given expression is known at compile-time or run-time. A programmer can
      use a {#syntax#}comptime{#endsyntax#} expression to guarantee that the expression will be evaluated at compile-time.
      If this cannot be accomplished, the compiler will emit an error. For example:
      </p>
      {#code_begin|test_err|unable to evaluate constant expression#}
extern fn exit() noreturn;

test "foo" {
    comptime {
        exit();
    }
}
      {#code_end#}
      <p>
      It doesn't make sense that a program could call {#syntax#}exit(){#endsyntax#} (or any other external function)
          at compile-time, so this is a compile error. However, a {#syntax#}comptime{#endsyntax#} expression does much
      more than sometimes cause a compile error.
      </p>
      <p>
      Within a {#syntax#}comptime{#endsyntax#} expression:
      </p>
      <ul>
          <li>All variables are {#syntax#}comptime{#endsyntax#} variables.</li>
          <li>All {#syntax#}if{#endsyntax#}, {#syntax#}while{#endsyntax#}, {#syntax#}for{#endsyntax#}, and {#syntax#}switch{#endsyntax#}
          expressions are evaluated at compile-time, or emit a compile error if this is not possible.</li>
        <li>All function calls cause the compiler to interpret the function at compile-time, emitting a
          compile error if the function tries to do something that has global run-time side effects.</li>
      </ul>
      <p>
      This means that a programmer can create a function which is called both at compile-time and run-time, with
      no modification to the function required.
      </p>
      <p>
      Let's look at an example:
      </p>
      {#code_begin|test#}
const assert = @import("std").debug.assert;

fn fibonacci(index: u32) u32 {
    if (index < 2) return index;
    return fibonacci(index - 1) + fibonacci(index - 2);
}

test "fibonacci" {
    // test fibonacci at run-time
    assert(fibonacci(7) == 13);

    // test fibonacci at compile-time
    comptime {
        assert(fibonacci(7) == 13);
    }
}
      {#code_end#}
      <p>
      Imagine if we had forgotten the base case of the recursive function and tried to run the tests:
      </p>
      {#code_begin|test_err|operation caused overflow#}
const assert = @import("std").debug.assert;

fn fibonacci(index: u32) u32 {
    //if (index < 2) return index;
    return fibonacci(index - 1) + fibonacci(index - 2);
}

test "fibonacci" {
    comptime {
        assert(fibonacci(7) == 13);
    }
}
      {#code_end#}
      <p>
      The compiler produces an error which is a stack trace from trying to evaluate the
      function at compile-time.
      </p>
      <p>
      Luckily, we used an unsigned integer, and so when we tried to subtract 1 from 0, it triggered
      undefined behavior, which is always a compile error if the compiler knows it happened.
      But what would have happened if we used a signed integer?
      </p>
      {#code_begin|test_err|evaluation exceeded 1000 backwards branches#}
const assert = @import("std").debug.assert;

fn fibonacci(index: i32) i32 {
    //if (index < 2) return index;
    return fibonacci(index - 1) + fibonacci(index - 2);
}

test "fibonacci" {
    comptime {
        assert(fibonacci(7) == 13);
    }
}
      {#code_end#}
      <p>
      The compiler noticed that evaluating this function at compile-time took a long time,
      and thus emitted a compile error and gave up. If the programmer wants to increase
      the budget for compile-time computation, they can use a built-in function called
      {#link|@setEvalBranchQuota#} to change the default number 1000 to something else.
      </p>
      <p>
      What if we fix the base case, but put the wrong value in the {#syntax#}assert{#endsyntax#} line?
      </p>
      {#code_begin|test_err|encountered @panic at compile-time#}
const assert = @import("std").debug.assert;

fn fibonacci(index: i32) i32 {
    if (index < 2) return index;
    return fibonacci(index - 1) + fibonacci(index - 2);
}

test "fibonacci" {
    comptime {
        assert(fibonacci(7) == 99999);
    }
}
      {#code_end#}
      <p>
      What happened is Zig started interpreting the {#syntax#}assert{#endsyntax#} function with the
          parameter {#syntax#}ok{#endsyntax#} set to {#syntax#}false{#endsyntax#}. When the interpreter hit
                  {#syntax#}unreachable{#endsyntax#} it emitted a compile error, because reaching unreachable
      code is undefined behavior, and undefined behavior causes a compile error if it is detected
      at compile-time.
      </p>

      <p>
      In the global scope (outside of any function), all expressions are implicitly
      {#syntax#}comptime{#endsyntax#} expressions. This means that we can use functions to
      initialize complex static data. For example:
      </p>
      {#code_begin|test#}
const first_25_primes = firstNPrimes(25);
const sum_of_first_25_primes = sum(first_25_primes);

fn firstNPrimes(comptime n: usize) [n]i32 {
    var prime_list: [n]i32 = undefined;
    var next_index: usize = 0;
    var test_number: i32 = 2;
    while (next_index < prime_list.len) : (test_number += 1) {
        var test_prime_index: usize = 0;
        var is_prime = true;
        while (test_prime_index < next_index) : (test_prime_index += 1) {
            if (test_number % prime_list[test_prime_index] == 0) {
                is_prime = false;
                break;
            }
        }
        if (is_prime) {
            prime_list[next_index] = test_number;
            next_index += 1;
        }
    }
    return prime_list;
}

fn sum(numbers: []const i32) i32 {
    var result: i32 = 0;
    for (numbers) |x| {
        result += x;
    }
    return result;
}

test "variable values" {
    @import("std").debug.assert(sum_of_first_25_primes == 1060);
}
      {#code_end#}
      <p>
      When we compile this program, Zig generates the constants
      with the answer pre-computed. Here are the lines from the generated LLVM IR:
      </p>
      <pre><code class="llvm">@0 = internal unnamed_addr constant [25 x i32] [i32 2, i32 3, i32 5, i32 7, i32 11, i32 13, i32 17, i32 19, i32 23, i32 29, i32 31, i32 37, i32 41, i32 43, i32 47, i32 53, i32 59, i32 61, i32 67, i32 71, i32 73, i32 79, i32 83, i32 89, i32 97]
@1 = internal unnamed_addr constant i32 1060</code></pre>
      <p>
      Note that we did not have to do anything special with the syntax of these functions. For example,
      we could call the {#syntax#}sum{#endsyntax#} function as is with a slice of numbers whose length and values were
      only known at run-time.
      </p>
      {#header_close#}
      {#header_close#}
      {#header_open|Generic Data Structures#}
      <p>
      Zig uses these capabilities to implement generic data structures without introducing any
      special-case syntax. If you followed along so far, you may already know how to create a
      generic data structure.
      </p>
      <p>
      Here is an example of a generic {#syntax#}List{#endsyntax#} data structure, that we will instantiate with
          the type {#syntax#}i32{#endsyntax#}. In Zig we refer to the type as {#syntax#}List(i32){#endsyntax#}.
      </p>
      {#code_begin|syntax#}
fn List(comptime T: type) type {
    return struct {
        items: []T,
        len: usize,
    };
}
      {#code_end#}
      <p>
      That's it. It's a function that returns an anonymous {#syntax#}struct{#endsyntax#}. For the purposes of error messages
          and debugging, Zig infers the name {#syntax#}"List(i32)"{#endsyntax#} from the function name and parameters invoked when creating
      the anonymous struct.
      </p>
      <p>
      To keep the language small and uniform, all aggregate types in Zig are anonymous. To give a type
      a name, we assign it to a constant:
      </p>
      {#code_begin|syntax#}
const Node = struct {
    next: *Node,
    name: []u8,
};
      {#code_end#}
      <p>
      This works because all top level declarations are order-independent, and as long as there isn't
      an actual infinite regression, values can refer to themselves, directly or indirectly. In this case,
      {#syntax#}Node{#endsyntax#} refers to itself as a pointer, which is not actually an infinite regression, so
      it works fine.
      </p>
      {#header_close#}
      {#header_open|Case Study: printf in Zig#}
      <p>
      Putting all of this together, let's see how {#syntax#}printf{#endsyntax#} works in Zig.
      </p>
      {#code_begin|exe|printf#}
const warn = @import("std").debug.warn;

const a_number: i32 = 1234;
const a_string = "foobar";

pub fn main() void {
    warn("here is a string: '{}' here is a number: {}\n", a_string, a_number);
}
      {#code_end#}

      <p>
      Let's crack open the implementation of this and see how it works:
      </p>

      {#code_begin|syntax#}
/// Calls print and then flushes the buffer.
pub fn printf(self: *OutStream, comptime format: []const u8, args: ...) anyerror!void {
    const State = enum {
        Start,
        OpenBrace,
        CloseBrace,
    };

    comptime var start_index: usize = 0;
    comptime var state = State.Start;
    comptime var next_arg: usize = 0;

    inline for (format) |c, i| {
        switch (state) {
            State.Start => switch (c) {
                '{' => {
                    if (start_index < i) try self.write(format[start_index..i]);
                    state = State.OpenBrace;
                },
                '}' => {
                    if (start_index < i) try self.write(format[start_index..i]);
                    state = State.CloseBrace;
                },
                else => {},
            },
            State.OpenBrace => switch (c) {
                '{' => {
                    state = State.Start;
                    start_index = i;
                },
                '}' => {
                    try self.printValue(args[next_arg]);
                    next_arg += 1;
                    state = State.Start;
                    start_index = i + 1;
                },
                else => @compileError("Unknown format character: " ++ c),
            },
            State.CloseBrace => switch (c) {
                '}' => {
                    state = State.Start;
                    start_index = i;
                },
                else => @compileError("Single '}' encountered in format string"),
            },
        }
    }
    comptime {
        if (args.len != next_arg) {
            @compileError("Unused arguments");
        }
        if (state != State.Start) {
            @compileError("Incomplete format string: " ++ format);
        }
    }
    if (start_index < format.len) {
        try self.write(format[start_index..format.len]);
    }
    try self.flush();
}
      {#code_end#}
      <p>
      This is a proof of concept implementation; the actual function in the standard library has more
      formatting capabilities.
      </p>
      <p>
      Note that this is not hard-coded into the Zig compiler; this is userland code in the standard library.
      </p>
      <p>
      When this function is analyzed from our example code above, Zig partially evaluates the function
      and emits a function that actually looks like this:
      </p>
      {#code_begin|syntax#}
pub fn printf(self: *OutStream, arg0: i32, arg1: []const u8) !void {
    try self.write("here is a string: '");
    try self.printValue(arg0);
    try self.write("' here is a number: ");
    try self.printValue(arg1);
    try self.write("\n");
    try self.flush();
}
      {#code_end#}
      <p>
      {#syntax#}printValue{#endsyntax#} is a function that takes a parameter of any type, and does different things depending
      on the type:
      </p>
      {#code_begin|syntax#}
pub fn printValue(self: *OutStream, value: var) !void {
    const T = @typeOf(value);
    if (@isInteger(T)) {
        return self.printInt(T, value);
    } else if (@isFloat(T)) {
        return self.printFloat(T, value);
    } else {
        @compileError("Unable to print type '" ++ @typeName(T) ++ "'");
    }
}
      {#code_end#}
      <p>
      And now, what happens if we give too many arguments to {#syntax#}printf{#endsyntax#}?
      </p>
      {#code_begin|test_err|Unused arguments#}
const warn = @import("std").debug.warn;

const a_number: i32 = 1234;
const a_string = "foobar";

test "printf too many arguments" {
    warn("here is a string: '{}' here is a number: {}\n",
        a_string, a_number, a_number);
}
      {#code_end#}
      <p>
      Zig gives programmers the tools needed to protect themselves against their own mistakes.
      </p>
      <p>
      Zig doesn't care whether the format argument is a string literal,
      only that it is a compile-time known value that is implicitly castable to a {#syntax#}[]const u8{#endsyntax#}:
      </p>
      {#code_begin|exe|printf#}
const warn = @import("std").debug.warn;

const a_number: i32 = 1234;
const a_string = "foobar";
const fmt = "here is a string: '{}' here is a number: {}\n";

pub fn main() void {
    warn(fmt, a_string, a_number);
}
      {#code_end#}
      <p>
      This works fine.
      </p>
      <p>
      Zig does not special case string formatting in the compiler and instead exposes enough power to accomplish this
      task in userland. It does so without introducing another language on top of Zig, such as
      a macro language or a preprocessor language. It's Zig all the way down.
      </p>
      {#header_close#}
      {#see_also|inline while|inline for#}
      {#header_close#}
      {#header_open|Assembly#}
      <p>TODO: example of inline assembly</p>
      <p>TODO: example of module level assembly</p>
      <p>TODO: example of using inline assembly return value</p>
      <p>TODO: example of using inline assembly assigning values to variables</p>
      {#header_close#}
      {#header_open|Atomics#}
      <p>TODO: @fence()</p>
      <p>TODO: @atomic rmw</p>
      <p>TODO: builtin atomic memory ordering enum</p>
      {#header_close#}
      {#header_open|Coroutines#}
      <p>
      A coroutine is a generalization of a function.
      </p>
      <p>
      When you call a function, it creates a stack frame,
      and then the function runs until it reaches a return
      statement, and then the stack frame is destroyed.
      At the callsite, the next line of code does not run
      until the function returns.
      </p>
      <p>
      A coroutine is like a function, but it can be suspended
      and resumed any number of times, and then it must be
      explicitly destroyed. When a coroutine suspends, it
      returns to the resumer.
      </p>
      {#header_open|Minimal Coroutine Example#}
      <p>
      Declare a coroutine with the {#syntax#}async{#endsyntax#} keyword.
      The expression in angle brackets must evaluate to a struct
      which has these fields:
      </p>
      <ul>
          <li>{#syntax#}allocFn: fn (self: *Allocator, byte_count: usize, alignment: u29) Error![]u8{#endsyntax#} - where {#syntax#}Error{#endsyntax#} can be any error set.</li>
          <li>{#syntax#}freeFn: fn (self: *Allocator, old_mem: []u8) void{#endsyntax#}</li>
      </ul>
      <p>
      You may notice that this corresponds to the {#syntax#}std.mem.Allocator{#endsyntax#} interface.
      This makes it convenient to integrate with existing allocators. Note, however,
      that the language feature does not depend on the standard library, and any struct which
      has these fields is allowed.
      </p>
      <p>
      Omitting the angle bracket expression when defining an async function makes
      the function generic. Zig will infer the allocator type when the async function is called.
      </p>
      <p>
      Call a coroutine with the {#syntax#}async{#endsyntax#} keyword. Here, the expression in angle brackets
      is a pointer to the allocator struct that the coroutine expects.
      </p>
      <p>
      The result of an async function call is a {#syntax#}promise->T{#endsyntax#} type, where {#syntax#}T{#endsyntax#}
      is the return type of the async function. Once a promise has been created, it must be
      consumed, either with {#syntax#}cancel{#endsyntax#} or {#syntax#}await{#endsyntax#}:
      </p>
      <p>
      Async functions start executing when created, so in the following example, the entire
      async function completes before it is canceled:
      </p>
      {#code_begin|test#}
const std = @import("std");
const assert = std.debug.assert;

var x: i32 = 1;

test "create a coroutine and cancel it" {
    const p = try async<std.debug.global_allocator> simpleAsyncFn();
    comptime assert(@typeOf(p) == promise->void);
    cancel p;
    assert(x == 2);
}
async<*std.mem.Allocator> fn simpleAsyncFn() void {
    x += 1;
}
      {#code_end#}
      {#header_close#}
      {#header_open|Suspend and Resume#}
      <p>
      At any point, an async function may suspend itself. This causes control flow to
      return to the caller or resumer. The following code demonstrates where control flow
      goes:
      </p>
      {#code_begin|test#}
const std = @import("std");
const assert = std.debug.assert;

test "coroutine suspend, resume, cancel" {
    seq('a');
    const p = try async<std.debug.global_allocator> testAsyncSeq();
    seq('c');
    resume p;
    seq('f');
    cancel p;
    seq('g');

    assert(std.mem.eql(u8, points, "abcdefg"));
}
async fn testAsyncSeq() void {
    defer seq('e');

    seq('b');
    suspend;
    seq('d');
}
var points = []u8{0} ** "abcdefg".len;
var index: usize = 0;

fn seq(c: u8) void {
    points[index] = c;
    index += 1;
}
      {#code_end#}
      <p>
      When an async function suspends itself, it must be sure that it will be
      resumed or canceled somehow, for example by registering its promise handle
      in an event loop. Use a suspend capture block to gain access to the
      promise:
      </p>
      {#code_begin|test#}
const std = @import("std");
const assert = std.debug.assert;

test "coroutine suspend with block" {
    const p = try async<std.debug.global_allocator> testSuspendBlock();
    std.debug.assert(!result);
    resume a_promise;
    std.debug.assert(result);
    cancel p;
}

var a_promise: promise = undefined;
var result = false;
async fn testSuspendBlock() void {
    suspend {
        comptime assert(@typeOf(@handle()) == promise->void);
        a_promise = @handle();
    }
    result = true;
}
      {#code_end#}
      <p>
      Every suspend point in an async function represents a point at which the coroutine
      could be destroyed. If that happens, {#syntax#}defer{#endsyntax#} expressions that are in
          scope are run, as well as {#syntax#}errdefer{#endsyntax#} expressions.
      </p>
      <p>
      {#link|Await#} counts as a suspend point.
      </p>
      {#header_open|Resuming from Suspend Blocks#}
      <p>
      Upon entering a {#syntax#}suspend{#endsyntax#} block, the coroutine is already considered
      suspended, and can be resumed. For example, if you started another kernel thread,
      and had that thread call {#syntax#}resume{#endsyntax#} on the promise handle provided by the
          {#syntax#}suspend{#endsyntax#} block, the new thread would begin executing after the suspend
      block, while the old thread continued executing the suspend block.
      </p>
      <p>
      However, the coroutine can be directly resumed from the suspend block, in which case it
      never returns to its resumer and continues executing.
      </p>
      {#code_begin|test#}
const std = @import("std");
const assert = std.debug.assert;

test "resume from suspend" {
    var buf: [500]u8 = undefined;
    var a = &std.heap.FixedBufferAllocator.init(buf[0..]).allocator;
    var my_result: i32 = 1;
    const p = try async<a> testResumeFromSuspend(&my_result);
    cancel p;
    std.debug.assert(my_result == 2);
}
async fn testResumeFromSuspend(my_result: *i32) void {
    suspend {
        resume @handle();
    }
    my_result.* += 1;
    suspend;
    my_result.* += 1;
}
      {#code_end#}
      <p>
      This is guaranteed to be a tail call, and therefore will not cause a new stack frame.
      </p>
      {#header_close#}
      {#header_close#}
      {#header_open|Await#}
      <p>
      The {#syntax#}await{#endsyntax#} keyword is used to coordinate with an async function's
          {#syntax#}return{#endsyntax#} statement.
      </p>
      <p>
      {#syntax#}await{#endsyntax#} is valid only in an {#syntax#}async{#endsyntax#} function, and it takes
      as an operand a promise handle.
      If the async function associated with the promise handle has already returned, 
      then {#syntax#}await{#endsyntax#} destroys the target async function, and gives the return value.
          Otherwise, {#syntax#}await{#endsyntax#} suspends the current async function, registering its
      promise handle with the target coroutine. It becomes the target coroutine's responsibility
      to have ensured that it will be resumed or destroyed. When the target coroutine reaches
      its return statement, it gives the return value to the awaiter, destroys itself, and then
      resumes the awaiter.
      </p>
      <p>
      A promise handle must be consumed exactly once after it is created, either by {#syntax#}cancel{#endsyntax#} or {#syntax#}await{#endsyntax#}.
      </p>
      <p>
      {#syntax#}await{#endsyntax#} counts as a suspend point, and therefore at every {#syntax#}await{#endsyntax#},
              a coroutine can be potentially destroyed, which would run {#syntax#}defer{#endsyntax#} and {#syntax#}errdefer{#endsyntax#} expressions.
      </p>
      {#code_begin|test#}
const std = @import("std");
const assert = std.debug.assert;

var a_promise: promise = undefined;
var final_result: i32 = 0;

test "coroutine await" {
    seq('a');
    const p = async<std.debug.global_allocator> amain() catch unreachable;
    seq('f');
    resume a_promise;
    seq('i');
    assert(final_result == 1234);
    assert(std.mem.eql(u8, seq_points, "abcdefghi"));
}
async fn amain() void {
    seq('b');
    const p = async another() catch unreachable;
    seq('e');
    final_result = await p;
    seq('h');
}
async fn another() i32 {
    seq('c');
    suspend {
        seq('d');
        a_promise = @handle();
    }
    seq('g');
    return 1234;
}

var seq_points = []u8{0} ** "abcdefghi".len;
var seq_index: usize = 0;

fn seq(c: u8) void {
    seq_points[seq_index] = c;
    seq_index += 1;
}
      {#code_end#}
      <p>
      In general, {#syntax#}suspend{#endsyntax#} is lower level than {#syntax#}await{#endsyntax#}. Most application
              code will use only {#syntax#}async{#endsyntax#} and {#syntax#}await{#endsyntax#}, but event loop
                      implementations will make use of {#syntax#}suspend{#endsyntax#} internally.
      </p>
      {#header_close#}
      {#header_open|Open Issues#}
      <p>
      There are a few issues with coroutines that are considered unresolved. Best be aware of them,
      as the situation is likely to change before 1.0.0:
      </p>
      <ul>
          <li>Async functions have optimizations disabled - even in release modes - due to an
              <a href="https://github.com/ziglang/zig/issues/802">LLVM bug</a>.
          </li>
          <li>
              There are some situations where we can know statically that there will not be
              memory allocation failure, but Zig still forces us to handle it.
              TODO file an issue for this and link it here.
          </li>
          <li>
              Zig does not take advantage of LLVM's allocation elision optimization for
              coroutines. It crashed LLVM when I tried to do it the first time. This is
              related to the other 2 bullet points here. See
              <a href="https://github.com/ziglang/zig/issues/802">#802</a>.
          </li>
      </ul>
      {#header_close#}
      
      {#header_close#}
      {#header_open|Builtin Functions#}
      <p>
      Builtin functions are provided by the compiler and are prefixed with <code>@</code>.
      The {#syntax#}comptime{#endsyntax#} keyword on a parameter means that the parameter must be known
      at compile time.
      </p>
      {#header_open|@addWithOverflow#}
      <pre>{#syntax#}@addWithOverflow(comptime T: type, a: T, b: T, result: *T) bool{#endsyntax#}</pre>
      <p>
      Performs {#syntax#}result.* = a + b{#endsyntax#}. If overflow or underflow occurs,
          stores the overflowed bits in {#syntax#}result{#endsyntax#} and returns {#syntax#}true{#endsyntax#}.
                  If no overflow or underflow occurs, returns {#syntax#}false{#endsyntax#}.
      </p>
      {#header_close#}
      {#header_open|@ArgType#}
      <pre>{#syntax#}@ArgType(comptime T: type, comptime n: usize) type{#endsyntax#}</pre>
      <p>
      This builtin function takes a function type and returns the type of the parameter at index {#syntax#}n{#endsyntax#}.
      </p>
      <p>
      {#syntax#}T{#endsyntax#} must be a function type.
      </p>
      <p>
      Note: This function is deprecated. Use {#link|@typeInfo#} instead.
      </p>
      {#header_close#}
      {#header_open|@atomicLoad#}
      <pre>{#syntax#}@atomicLoad(comptime T: type, ptr: *const T, comptime ordering: builtin.AtomicOrder) T{#endsyntax#}</pre>
      <p>
      This builtin function atomically dereferences a pointer and returns the value.
      </p>
      <p>
      {#syntax#}T{#endsyntax#} must be a pointer type, a {#syntax#}bool{#endsyntax#},
      or an integer whose bit count meets these requirements:
      </p>
      <ul>
          <li>At least 8</li>
          <li>At most the same as usize</li>
          <li>Power of 2</li>
      </ul>
      <p>
      TODO right now bool is not accepted. Also I think we could make non powers of 2 work fine, maybe
      we can remove this restriction
      </p>
      {#header_close#}
      {#header_open|@atomicRmw#}
      <pre>{#syntax#}@atomicRmw(comptime T: type, ptr: *T, comptime op: builtin.AtomicRmwOp, operand: T, comptime ordering: builtin.AtomicOrder) T{#endsyntax#}</pre>
      <p>
      This builtin function atomically modifies memory and then returns the previous value.
      </p>
      <p>
      {#syntax#}T{#endsyntax#} must be a pointer type, a {#syntax#}bool{#endsyntax#},
      or an integer whose bit count meets these requirements:
      </p>
      <ul>
          <li>At least 8</li>
          <li>At most the same as usize</li>
          <li>Power of 2</li>
      </ul>
      <p>
      TODO right now bool is not accepted. Also I think we could make non powers of 2 work fine, maybe
      we can remove this restriction
      </p>
      {#header_close#}
      {#header_open|@bitCast#}
      <pre>{#syntax#}@bitCast(comptime DestType: type, value: var) DestType{#endsyntax#}</pre>
      <p>
      Converts a value of one type to another type.
      </p>
      <p>
      Asserts that {#syntax#}@sizeOf(@typeOf(value)) == @sizeOf(DestType){#endsyntax#}.
      </p>
      <p>
      Asserts that {#syntax#}@typeId(DestType) != @import("builtin").TypeId.Pointer{#endsyntax#}. Use {#syntax#}@ptrCast{#endsyntax#} or {#syntax#}@intToPtr{#endsyntax#} if you need this.
      </p>
      <p>
      Can be used for these things for example:
      </p>
      <ul>
          <li>Convert {#syntax#}f32{#endsyntax#} to {#syntax#}u32{#endsyntax#} bits</li>
          <li>Convert {#syntax#}i32{#endsyntax#} to {#syntax#}u32{#endsyntax#} preserving twos complement</li>
      </ul>
      <p>
      Works at compile-time if {#syntax#}value{#endsyntax#} is known at compile time. It's a compile error to bitcast a struct to a scalar type of the same size since structs have undefined layout. However if the struct is packed then it works.
      </p>
      {#header_close#}
      {#header_open|@bitOffsetOf#}
      <pre>{#syntax#}@bitOffsetOf(comptime T: type, comptime field_name: [] const u8) comptime_int{#endsyntax#}</pre>
      <p>
      Returns the bit offset of a field relative to its containing struct.
      </p>
      <p>
      For non {#link|packed structs|packed struct#}, this will always be divisible by {#syntax#}8{#endsyntax#}.
      For packed structs, non-byte-aligned fields will share a byte offset, but they will have different
      bit offsets.
      </p>
      {#see_also|@byteOffsetOf#}
      {#header_close#}
      {#header_open|@breakpoint#}
      <pre>{#syntax#}@breakpoint(){#endsyntax#}</pre>
      <p>
      This function inserts a platform-specific debug trap instruction which causes
      debuggers to break there.
      </p>
      <p>
      This function is only valid within function scope.
      </p>

      {#header_close#}
      {#header_open|@byteOffsetOf#}
      <pre>{#syntax#}@byteOffsetOf(comptime T: type, comptime field_name: [] const u8) comptime_int{#endsyntax#}</pre>
      <p>
      Returns the byte offset of a field relative to its containing struct.
      </p>
      {#see_also|@bitOffsetOf#}
      {#header_close#}
      {#header_open|@alignCast#}
      <pre>{#syntax#}@alignCast(comptime alignment: u29, ptr: var) var{#endsyntax#}</pre>
      <p>
      {#syntax#}ptr{#endsyntax#} can be {#syntax#}*T{#endsyntax#}, {#syntax#}fn(){#endsyntax#}, {#syntax#}?*T{#endsyntax#},
                      {#syntax#}?fn(){#endsyntax#}, or {#syntax#}[]T{#endsyntax#}. It returns the same type as {#syntax#}ptr{#endsyntax#}
      except with the alignment adjusted to the new value.
      </p>
      <p>A {#link|pointer alignment safety check|Incorrect Pointer Alignment#} is added
      to the generated code to make sure the pointer is aligned as promised.</p>

      {#header_close#}
      {#header_open|@alignOf#}
      <pre>{#syntax#}@alignOf(comptime T: type) comptime_int{#endsyntax#}</pre>
      <p>
      This function returns the number of bytes that this type should be aligned to
      for the current target to match the C ABI. When the child type of a pointer has
      this alignment, the alignment can be omitted from the type.
      </p>
      <pre>{#syntax#}const assert = @import("std").debug.assert;
comptime {
    assert(*u32 == *align(@alignOf(u32)) u32);
}{#endsyntax#}</pre>
      <p>
      The result is a target-specific compile time constant. It is guaranteed to be
      less than or equal to {#link|@sizeOf(T)|@sizeOf#}.
      </p>
      {#see_also|Alignment#}
      {#header_close#}

      {#header_open|@boolToInt#}
      <pre>{#syntax#}@boolToInt(value: bool) u1{#endsyntax#}</pre>
      <p>
      Converts {#syntax#}true{#endsyntax#} to {#syntax#}u1(1){#endsyntax#} and {#syntax#}false{#endsyntax#} to
                  {#syntax#}u1(0){#endsyntax#}.
      </p>
      <p>
      If the value is known at compile-time, the return type is {#syntax#}comptime_int{#endsyntax#}
          instead of {#syntax#}u1{#endsyntax#}.
      </p>
      {#header_close#}

      {#header_open|@bytesToSlice#}
      <pre>{#syntax#}@bytesToSlice(comptime Element: type, bytes: []u8) []Element{#endsyntax#}</pre>
      <p>
      Converts a slice of bytes or array of bytes into a slice of {#syntax#}Element{#endsyntax#}.
      The resulting slice has the same {#link|pointer|Pointers#} properties as the parameter.
      </p>
      <p>
      Attempting to convert a number of bytes with a length that does not evenly divide into a slice of
      elements results in safety-protected {#link|Undefined Behavior#}.
      </p>
      {#header_close#}

      {#header_open|@cDefine#}
      <pre>{#syntax#}@cDefine(comptime name: []u8, value){#endsyntax#}</pre>
      <p>
      This function can only occur inside {#syntax#}@cImport{#endsyntax#}.
      </p>
      <p>
      This appends <code>#define $name $value</code> to the {#syntax#}@cImport{#endsyntax#}
      temporary buffer.
      </p>
      <p>
      To define without a value, like this:
      </p>
      <pre><code class="c">#define _GNU_SOURCE</code></pre>
      <p>
      Use the void value, like this:
      </p>
      <pre>{#syntax#}@cDefine("_GNU_SOURCE", {}){#endsyntax#}</pre>
      {#see_also|Import from C Header File|@cInclude|@cImport|@cUndef|void#}
      {#header_close#}
      {#header_open|@cImport#}
      <pre>{#syntax#}@cImport(expression) (namespace){#endsyntax#}</pre>
      <p>
      This function parses C code and imports the functions, types, variables, and
      compatible macro definitions into the result namespace.
      </p>
      <p>
      {#syntax#}expression{#endsyntax#} is interpreted at compile time. The builtin functions
          {#syntax#}@cInclude{#endsyntax#}, {#syntax#}@cDefine{#endsyntax#}, and {#syntax#}@cUndef{#endsyntax#} work
      within this expression, appending to a temporary buffer which is then parsed as C code.
      </p>
      <p>
      Usually you should only have one {#syntax#}@cImport{#endsyntax#} in your entire application, because it saves the compiler
      from invoking clang multiple times, and prevents inline functions from being duplicated.
      </p>
      <p>
      Reasons for having multiple {#syntax#}@cImport{#endsyntax#} expressions would be:
      </p>
      <ul>
          <li>To avoid a symbol collision, for example if foo.h and bar.h both <code>#define CONNECTION_COUNT</code></li>
        <li>To analyze the C code with different preprocessor defines</li>
      </ul>
      {#see_also|Import from C Header File|@cInclude|@cDefine|@cUndef#}
      {#header_close#}
      {#header_open|@cInclude#}
      <pre>{#syntax#}@cInclude(comptime path: []u8){#endsyntax#}</pre>
      <p>
      This function can only occur inside {#syntax#}@cImport{#endsyntax#}.
      </p>
      <p>
      This appends <code>#include <$path>\n</code> to the {#syntax#}c_import{#endsyntax#}
      temporary buffer.
      </p>
      {#see_also|Import from C Header File|@cImport|@cDefine|@cUndef#}
      {#header_close#}
      {#header_open|@cUndef#}
      <pre>{#syntax#}@cUndef(comptime name: []u8){#endsyntax#}</pre>
      <p>
      This function can only occur inside {#syntax#}@cImport{#endsyntax#}.
      </p>
      <p>
      This appends <code>#undef $name</code> to the {#syntax#}@cImport{#endsyntax#}
      temporary buffer.
      </p>
      {#see_also|Import from C Header File|@cImport|@cDefine|@cInclude#}
      {#header_close#}
      {#header_open|@clz#}
      <pre>{#syntax#}@clz(x: T) U{#endsyntax#}</pre>
      <p>
      This function counts the number of leading zeroes in {#syntax#}x{#endsyntax#} which is an integer
          type {#syntax#}T{#endsyntax#}.
      </p>
      <p>
      The return type {#syntax#}U{#endsyntax#} is an unsigned integer with the minimum number
          of bits that can represent the value {#syntax#}T.bit_count{#endsyntax#}.
      </p>
      <p>
      If {#syntax#}x{#endsyntax#} is zero, {#syntax#}@clz{#endsyntax#} returns {#syntax#}T.bit_count{#endsyntax#}.
      </p>
      {#see_also|@ctz|@popCount#}
      {#header_close#}
      {#header_open|@cmpxchgStrong#}
      <pre>{#syntax#}@cmpxchgStrong(comptime T: type, ptr: *T, expected_value: T, new_value: T, success_order: AtomicOrder, fail_order: AtomicOrder) ?T{#endsyntax#}</pre>
      <p>
      This function performs a strong atomic compare exchange operation. It's the equivalent of this code,
      except atomic:
      </p>
      {#code_begin|syntax#}
fn cmpxchgStrongButNotAtomic(comptime T: type, ptr: *T, expected_value: T, new_value: T) ?T {
    const old_value = ptr.*;
    if (old_value == expected_value) {
        ptr.* = new_value;
        return null;
    } else {
        return old_value;
    }
}
      {#code_end#}
      <p>
      If you are using cmpxchg in a loop, {#link|@cmpxchgWeak#} is the better choice, because it can be implemented
      more efficiently in machine instructions.
      </p>
      <p>
      {#syntax#}AtomicOrder{#endsyntax#} can be found with {#syntax#}@import("builtin").AtomicOrder{#endsyntax#}.
      </p>
      <p>{#syntax#}@typeOf(ptr).alignment{#endsyntax#} must be {#syntax#}>= @sizeOf(T).{#endsyntax#}</p>
      {#see_also|Compile Variables|cmpxchgWeak#}
      {#header_close#}
      {#header_open|@cmpxchgWeak#}
      <pre>{#syntax#}@cmpxchgWeak(comptime T: type, ptr: *T, expected_value: T, new_value: T, success_order: AtomicOrder, fail_order: AtomicOrder) ?T{#endsyntax#}</pre>
      <p>
      This function performs a weak atomic compare exchange operation. It's the equivalent of this code,
      except atomic:
      </p>
      {#code_begin|syntax#}
fn cmpxchgWeakButNotAtomic(comptime T: type, ptr: *T, expected_value: T, new_value: T) ?T {
    const old_value = ptr.*;
    if (old_value == expected_value and usuallyTrueButSometimesFalse()) {
        ptr.* = new_value;
        return null;
    } else {
        return old_value;
    }
}
      {#code_end#}
      <p>
      If you are using cmpxchg in a loop, the sporadic failure will be no problem, and {#syntax#}cmpxchgWeak{#endsyntax#}
      is the better choice, because it can be implemented more efficiently in machine instructions.
      However if you need a stronger guarantee, use {#link|@cmpxchgStrong#}.
      </p>
      <p>
      {#syntax#}AtomicOrder{#endsyntax#} can be found with {#syntax#}@import("builtin").AtomicOrder{#endsyntax#}.
      </p>
      <p>{#syntax#}@typeOf(ptr).alignment{#endsyntax#} must be {#syntax#}>= @sizeOf(T).{#endsyntax#}</p>
      {#see_also|Compile Variables|cmpxchgStrong#}
      {#header_close#}
      {#header_open|@compileError#}
      <pre>{#syntax#}@compileError(comptime msg: []u8){#endsyntax#}</pre>
      <p>
      This function, when semantically analyzed, causes a compile error with the
      message {#syntax#}msg{#endsyntax#}.
      </p>
      <p>
      There are several ways that code avoids being semantically checked, such as
      using {#syntax#}if{#endsyntax#} or {#syntax#}switch{#endsyntax#} with compile time constants,
              and {#syntax#}comptime{#endsyntax#} functions.
      </p>
      {#header_close#}
      {#header_open|@compileLog#}
      <pre>{#syntax#}@compileLog(args: ...){#endsyntax#}</pre>
      <p>
      This function prints the arguments passed to it at compile-time.
      </p>
      <p>
      To prevent accidentally leaving compile log statements in a codebase,
      a compilation error is added to the build, pointing to the compile
      log statement. This error prevents code from being generated, but
      does not otherwise interfere with analysis.
      </p>
      <p>
      This function can be used to do "printf debugging" on
      compile-time executing code.
      </p>
      {#code_begin|test_err|found compile log statement#}
const warn = @import("std").debug.warn;

const num1 = blk: {
    var val1: i32 = 99;
    @compileLog("comptime val1 = ", val1); 
    val1 = val1 + 1;
    break :blk val1;
};

test "main" {
    @compileLog("comptime in main"); 

    warn("Runtime in main, num1 = {}.\n", num1);
}
      {#code_end#}
      </p>
      <p>
      will ouput:
      </p>
      <p>
      If all {#syntax#}@compileLog{#endsyntax#} calls are removed or 
      not encountered by analysis, the
      program compiles successfully and the generated executable prints:
      </p>  
      {#code_begin|test#}
const warn = @import("std").debug.warn;

const num1 = blk: {
    var val1: i32 = 99;
    val1 = val1 + 1;
    break :blk val1;
};

test "main" {
    warn("Runtime in main, num1 = {}.\n", num1);
}
      {#code_end#}
      {#header_close#}
      {#header_open|@ctz#}
      <pre>{#syntax#}@ctz(x: T) U{#endsyntax#}</pre>
      <p>
      This function counts the number of trailing zeroes in {#syntax#}x{#endsyntax#} which is an integer
          type {#syntax#}T{#endsyntax#}.
      </p>
      <p>
      The return type {#syntax#}U{#endsyntax#} is an unsigned integer with the minimum number
          of bits that can represent the value {#syntax#}T.bit_count{#endsyntax#}.
      </p>
      <p>
      If {#syntax#}x{#endsyntax#} is zero, {#syntax#}@ctz{#endsyntax#} returns {#syntax#}T.bit_count{#endsyntax#}.
      </p>
      {#see_also|@clz|@popCount#}
      {#header_close#}
      {#header_open|@divExact#}
      <pre>{#syntax#}@divExact(numerator: T, denominator: T) T{#endsyntax#}</pre>
      <p>
      Exact division. Caller guarantees {#syntax#}denominator != 0{#endsyntax#} and
          {#syntax#}@divTrunc(numerator, denominator) * denominator == numerator{#endsyntax#}.
      </p>
      <ul>
          <li>{#syntax#}@divExact(6, 3) == 2{#endsyntax#}</li>
          <li>{#syntax#}@divExact(a, b) * b == a{#endsyntax#}</li>
      </ul>
      <p>For a function that returns a possible error code, use {#syntax#}@import("std").math.divExact{#endsyntax#}.</p>
      {#see_also|@divTrunc|@divFloor#}
      {#header_close#}
      {#header_open|@divFloor#}
      <pre>{#syntax#}@divFloor(numerator: T, denominator: T) T{#endsyntax#}</pre>
      <p>
      Floored division. Rounds toward negative infinity. For unsigned integers it is
      the same as {#syntax#}numerator / denominator{#endsyntax#}. Caller guarantees {#syntax#}denominator != 0{#endsyntax#} and
              {#syntax#}!(@typeId(T) == builtin.TypeId.Int and T.is_signed and numerator == std.math.minInt(T) and denominator == -1){#endsyntax#}.
      </p>
      <ul>
          <li>{#syntax#}@divFloor(-5, 3) == -2{#endsyntax#}</li>
          <li>{#syntax#}@divFloor(a, b) + @mod(a, b) == a{#endsyntax#}</li>
      </ul>
      <p>For a function that returns a possible error code, use {#syntax#}@import("std").math.divFloor{#endsyntax#}.</p>
      {#see_also|@divTrunc|@divExact#}
      {#header_close#}
      {#header_open|@divTrunc#}
      <pre>{#syntax#}@divTrunc(numerator: T, denominator: T) T{#endsyntax#}</pre>
      <p>
      Truncated division. Rounds toward zero. For unsigned integers it is
      the same as {#syntax#}numerator / denominator{#endsyntax#}. Caller guarantees {#syntax#}denominator != 0{#endsyntax#} and
              {#syntax#}!(@typeId(T) == builtin.TypeId.Int and T.is_signed and numerator == std.math.minInt(T) and denominator == -1){#endsyntax#}.
      </p>
      <ul>
          <li>{#syntax#}@divTrunc(-5, 3) == -1{#endsyntax#}</li>
          <li>{#syntax#}@divTrunc(a, b) + @rem(a, b) == a{#endsyntax#}</li>
      </ul>
      <p>For a function that returns a possible error code, use {#syntax#}@import("std").math.divTrunc{#endsyntax#}.</p>
      {#see_also|@divFloor|@divExact#}
      {#header_close#}
      {#header_open|@embedFile#}
      <pre>{#syntax#}@embedFile(comptime path: []const u8) [X]u8{#endsyntax#}</pre>
      <p>
      This function returns a compile time constant fixed-size array with length
      equal to the byte count of the file given by {#syntax#}path{#endsyntax#}. The contents of the array
      are the contents of the file.
      </p>
      <p>
      {#syntax#}path{#endsyntax#} is absolute or relative to the current file, just like {#syntax#}@import{#endsyntax#}.
      </p>
      {#see_also|@import#}
      {#header_close#}

      {#header_open|@enumToInt#}
      <pre>{#syntax#}@enumToInt(enum_value: var) var{#endsyntax#}</pre>
      <p>
      Converts an enumeration value into its integer tag type.
      </p>
      <p>
      If the enum has only 1 possible value, the resut is a {#syntax#}comptime_int{#endsyntax#}
      known at {#link|comptime#}.
      </p>
      {#see_also|@intToEnum#}
      {#header_close#}

      {#header_open|@errSetCast#}
      <pre>{#syntax#}@errSetCast(comptime T: DestType, value: var) DestType{#endsyntax#}</pre>
      <p>
      Converts an error value from one error set to another error set. Attempting to convert an error
      which is not in the destination error set results in safety-protected {#link|Undefined Behavior#}.
      </p>
      {#header_close#}

      {#header_open|@errorName#}
      <pre>{#syntax#}@errorName(err: error) []u8{#endsyntax#}</pre>
      <p>
      This function returns the string representation of an error. If an error
      declaration is:
      </p>
      <pre>{#syntax#}error OutOfMem{#endsyntax#}</pre>
      <p>
      Then the string representation is {#syntax#}"OutOfMem"{#endsyntax#}.
      </p>
      <p>
      If there are no calls to {#syntax#}@errorName{#endsyntax#} in an entire application,
          or all calls have a compile-time known value for {#syntax#}err{#endsyntax#}, then no
      error name table will be generated.
      </p>
      {#header_close#}

      {#header_open|@errorReturnTrace#}
      <pre>{#syntax#}@errorReturnTrace() ?*builtin.StackTrace{#endsyntax#}</pre>
      <p>
      If the binary is built with error return tracing, and this function is invoked in a
      function that calls a function with an error or error union return type, returns a
      stack trace object. Otherwise returns `null`.
      </p>
      {#header_close#}

      {#header_open|@errorToInt#}
      <pre>{#syntax#}@errorToInt(err: var) @IntType(false, @sizeOf(error) * 8){#endsyntax#}</pre>
      <p>
      Supports the following types:
      </p>
      <ul>
          <li>error unions</li>
          <li>{#syntax#}E!void{#endsyntax#}</li>
      </ul>
      <p>
      Converts an error to the integer representation of an error.
      </p>
      <p>
      It is generally recommended to avoid this
      cast, as the integer representation of an error is not stable across source code changes.
      </p>
      {#see_also|@intToError#}
      {#header_close#}

      {#header_open|@export#}
      <pre>{#syntax#}@export(comptime name: []const u8, target: var, linkage: builtin.GlobalLinkage) []const u8{#endsyntax#}</pre>
      <p>
      Creates a symbol in the output object file.
      </p>
      {#header_close#}

      {#header_open|@fence#}
      <pre>{#syntax#}@fence(order: AtomicOrder){#endsyntax#}</pre>
      <p>
      The {#syntax#}fence{#endsyntax#} function is used to introduce happens-before edges between operations.
      </p>
      <p>
      {#syntax#}AtomicOrder{#endsyntax#} can be found with {#syntax#}@import("builtin").AtomicOrder{#endsyntax#}.
      </p>
      {#see_also|Compile Variables#}
      {#header_close#}

      {#header_open|@field#}
      <pre>{#syntax#}@field(lhs: var, comptime field_name: []const u8) (field){#endsyntax#}</pre>
      <p>Preforms field access equivalent to {#syntax#}lhs.field_name{#endsyntax#}, except instead
      of the field {#syntax#}"field_name"{#endsyntax#}, it accesses the field named by the string
      value of {#syntax#}field_name{#endsyntax#}.
      </p>
      {#header_close#}

      {#header_open|@fieldParentPtr#}
      <pre>{#syntax#}@fieldParentPtr(comptime ParentType: type, comptime field_name: []const u8,
    field_ptr: *T) *ParentType{#endsyntax#}</pre>
      <p>
      Given a pointer to a field, returns the base pointer of a struct.
      </p>
      {#header_close#}

      {#header_open|@floatCast#}
      <pre>{#syntax#}@floatCast(comptime DestType: type, value: var) DestType{#endsyntax#}</pre>
      <p>
      Convert from one float type to another. This cast is safe, but may cause the
      numeric value to lose precision.
      </p>
      {#header_close#}

      {#header_open|@floatToInt#}
      <pre>{#syntax#}@floatToInt(comptime DestType: type, float: var) DestType{#endsyntax#}</pre>
      <p>
      Converts the integer part of a floating point number to the destination type.
      </p>
      <p>
      If the integer part of the floating point number cannot fit in the destination type,
      it invokes safety-checked {#link|Undefined Behavior#}.
      </p>
      {#see_also|@intToFloat#}
      {#header_close#}

      {#header_open|@frameAddress#}
      <pre>{#syntax#}@frameAddress(){#endsyntax#}</pre>
      <p>
      This function returns the base pointer of the current stack frame.
      </p>
      <p>
      The implications of this are target specific and not consistent across all
      platforms. The frame address may not be available in release mode due to
      aggressive optimizations.
      </p>
      <p>
      This function is only valid within function scope.
      </p>
      {#header_close#}
      {#header_open|@handle#}
      <pre>{#syntax#}@handle(){#endsyntax#}</pre>
      <p>
      This function returns a {#syntax#}promise->T{#endsyntax#} type, where {#syntax#}T{#endsyntax#}
      is the return type of the async function in scope.
      </p>
      <p>
      This function is only valid within an async function scope.
      </p>
      {#header_close#}
      {#header_open|@import#}
      <pre>{#syntax#}@import(comptime path: []u8) (namespace){#endsyntax#}</pre>
      <p>
      This function finds a zig file corresponding to {#syntax#}path{#endsyntax#} and imports all the
      public top level declarations into the resulting namespace.
      </p>
      <p>
      {#syntax#}path{#endsyntax#} can be a relative or absolute path, or it can be the name of a package.
          If it is a relative path, it is relative to the file that contains the {#syntax#}@import{#endsyntax#}
      function call.
      </p>
      <p>
      The following packages are always available:
      </p>
      <ul>
          <li>{#syntax#}@import("std"){#endsyntax#} - Zig Standard Library</li>
          <li>{#syntax#}@import("builtin"){#endsyntax#} - Compiler-provided types and variables</li>
      </ul>
      {#see_also|Compile Variables|@embedFile#}
      {#header_close#}
      {#header_open|@inlineCall#}
      <pre>{#syntax#}@inlineCall(function: X, args: ...) Y{#endsyntax#}</pre>
      <p>
      This calls a function, in the same way that invoking an expression with parentheses does:
      </p>
      {#code_begin|test#}
const assert = @import("std").debug.assert;

test "inline function call" {
    assert(@inlineCall(add, 3, 9) == 12);
}

fn add(a: i32, b: i32) i32 { return a + b; }
      {#code_end#}
      <p>
      Unlike a normal function call, however, {#syntax#}@inlineCall{#endsyntax#} guarantees that the call
      will be inlined. If the call cannot be inlined, a compile error is emitted.
      </p>
      {#see_also|@noInlineCall#}
      {#header_close#}

      {#header_open|@intCast#}
      <pre>{#syntax#}@intCast(comptime DestType: type, int: var) DestType{#endsyntax#}</pre>
      <p>
      Converts an integer to another integer while keeping the same numerical value.
      Attempting to convert a number which is out of range of the destination type results in
      safety-protected {#link|Undefined Behavior#}.
      </p>
      {#header_close#}

      {#header_open|@intToEnum#}
      <pre>{#syntax#}@intToEnum(comptime DestType: type, int_value: @TagType(DestType)) DestType{#endsyntax#}</pre>
      <p>
      Converts an integer into an {#link|enum#} value.
      </p>
      <p>
      Attempting to convert an integer which represents no value in the chosen enum type invokes
      safety-checked {#link|Undefined Behavior#}.
      </p>
      {#see_also|@enumToInt#}
      {#header_close#}

      {#header_open|@intToError#}
      <pre>{#syntax#}@intToError(value: @IntType(false, @sizeOf(anyerror) * 8)) anyerror{#endsyntax#}</pre>
      <p>
      Converts from the integer representation of an error into the global error set type.
      </p>
      <p>
      It is generally recommended to avoid this
      cast, as the integer representation of an error is not stable across source code changes.
      </p>
      <p>
      Attempting to convert an integer that does not correspond to any error results in
      safety-protected {#link|Undefined Behavior#}.
      </p>
      {#see_also|@errorToInt#}
      {#header_close#}

      {#header_open|@intToFloat#}
      <pre>{#syntax#}@intToFloat(comptime DestType: type, int: var) DestType{#endsyntax#}</pre>
      <p>
      Converts an integer to the closest floating point representation. To convert the other way, use {#link|@floatToInt#}. This cast is always safe.
      </p>
      {#header_close#}

      {#header_open|@intToPtr#}
      <pre>{#syntax#}@intToPtr(comptime DestType: type, int: usize) DestType{#endsyntax#}</pre>
      <p>
      Converts an integer to a pointer. To convert the other way, use {#link|@ptrToInt#}.
      </p>
      {#header_close#}

      {#header_open|@IntType#}
      <pre>{#syntax#}@IntType(comptime is_signed: bool, comptime bit_count: u16) type{#endsyntax#}</pre>
      <p>
      This function returns an integer type with the given signness and bit count. The maximum
      bit count for an integer type is {#syntax#}65535{#endsyntax#}.
      </p>
      {#header_close#}
      {#header_open|@memberCount#}
      <pre>{#syntax#}@memberCount(comptime T: type) comptime_int{#endsyntax#}</pre>
      <p>
      This function returns the number of members in a struct, enum, or union type.
      </p>
      <p>
      The result is a compile time constant.
      </p>
      <p>
      It does not include functions, variables, or constants.
      </p>
      {#header_close#}
      {#header_open|@memberName#}
      <pre>{#syntax#}@memberName(comptime T: type, comptime index: usize) [N]u8{#endsyntax#}</pre>
      <p>Returns the field name of a struct, union, or enum.</p>
      <p>
      The result is a compile time constant.
      </p>
      <p>
      It does not include functions, variables, or constants.
      </p>
      {#header_close#}
      {#header_open|@memberType#}
      <pre>{#syntax#}@memberType(comptime T: type, comptime index: usize) type{#endsyntax#}</pre>
      <p>Returns the field type of a struct or union.</p>
      {#header_close#}
      {#header_open|@memcpy#}
      <pre>{#syntax#}@memcpy(noalias dest: [*]u8, noalias source: [*]const u8, byte_count: usize){#endsyntax#}</pre>
      <p>
      This function copies bytes from one region of memory to another. {#syntax#}dest{#endsyntax#} and
          {#syntax#}source{#endsyntax#} are both pointers and must not overlap.
      </p>
      <p>
      This function is a low level intrinsic with no safety mechanisms. Most code
      should not use this function, instead using something like this:
      </p>
      <pre>{#syntax#}for (source[0...byte_count]) |b, i| dest[i] = b;{#endsyntax#}</pre>
      <p>
      The optimizer is intelligent enough to turn the above snippet into a memcpy.
      </p>
      <p>There is also a standard library function for this:</p>
      <pre>{#syntax#}const mem = @import("std").mem;
mem.copy(u8, dest[0...byte_count], source[0...byte_count]);{#endsyntax#}</pre>
      {#header_close#}
      {#header_open|@memset#}
      <pre>{#syntax#}@memset(dest: [*]u8, c: u8, byte_count: usize){#endsyntax#}</pre>
      <p>
      This function sets a region of memory to {#syntax#}c{#endsyntax#}. {#syntax#}dest{#endsyntax#} is a pointer.
      </p>
      <p>
      This function is a low level intrinsic with no safety mechanisms. Most
      code should not use this function, instead using something like this:
      </p>
      <pre>{#syntax#}for (dest[0...byte_count]) |*b| b.* = c;{#endsyntax#}</pre>
      <p>
      The optimizer is intelligent enough to turn the above snippet into a memset.
      </p>
      <p>There is also a standard library function for this:</p>
      <pre>{#syntax#}const mem = @import("std").mem;
mem.set(u8, dest, c);{#endsyntax#}</pre>
      {#header_close#}
      {#header_open|@mod#}
      <pre>{#syntax#}@mod(numerator: T, denominator: T) T{#endsyntax#}</pre>
      <p>
      Modulus division. For unsigned integers this is the same as
      {#syntax#}numerator % denominator{#endsyntax#}. Caller guarantees {#syntax#}denominator > 0{#endsyntax#}.
      </p>
      <ul>
          <li>{#syntax#}@mod(-5, 3) == 1{#endsyntax#}</li>
          <li>{#syntax#}@divFloor(a, b) + @mod(a, b) == a{#endsyntax#}</li>
      </ul>
      <p>For a function that returns an error code, see {#syntax#}@import("std").math.mod{#endsyntax#}.</p>
      {#see_also|@rem#}
      {#header_close#}
      {#header_open|@mulWithOverflow#}
      <pre>{#syntax#}@mulWithOverflow(comptime T: type, a: T, b: T, result: *T) bool{#endsyntax#}</pre>
      <p>
      Performs {#syntax#}result.* = a * b{#endsyntax#}. If overflow or underflow occurs,
          stores the overflowed bits in {#syntax#}result{#endsyntax#} and returns {#syntax#}true{#endsyntax#}.
                  If no overflow or underflow occurs, returns {#syntax#}false{#endsyntax#}.
      </p>
      {#header_close#}
      {#header_open|@newStackCall#}
      <pre>{#syntax#}@newStackCall(new_stack: []u8, function: var, args: ...) var{#endsyntax#}</pre>
      <p>
      This calls a function, in the same way that invoking an expression with parentheses does. However,
      instead of using the same stack as the caller, the function uses the stack provided in the {#syntax#}new_stack{#endsyntax#}
      parameter.
      </p>
      {#code_begin|test#}
const std = @import("std");
const assert = std.debug.assert;

var new_stack_bytes: [1024]u8 = undefined;

test "calling a function with a new stack" {
    const arg = 1234;

    const a = @newStackCall(new_stack_bytes[0..512], targetFunction, arg);
    const b = @newStackCall(new_stack_bytes[512..], targetFunction, arg);
    _ = targetFunction(arg);

    assert(arg == 1234);
    assert(a < b);
}

fn targetFunction(x: i32) usize {
    assert(x == 1234);

    var local_variable: i32 = 42;
    const ptr = &local_variable;
    ptr.* += 1;

    assert(local_variable == 43);
    return @ptrToInt(ptr);
}
      {#code_end#}
      {#header_close#}
      {#header_open|@noInlineCall#}
      <pre>{#syntax#}@noInlineCall(function: var, args: ...) var{#endsyntax#}</pre>
      <p>
      This calls a function, in the same way that invoking an expression with parentheses does:
      </p>
      {#code_begin|test#}
const assert = @import("std").debug.assert;

test "noinline function call" {
    assert(@noInlineCall(add, 3, 9) == 12);
}

fn add(a: i32, b: i32) i32 {
    return a + b;
}
      {#code_end#}
      <p>
      Unlike a normal function call, however, {#syntax#}@noInlineCall{#endsyntax#} guarantees that the call
      will not be inlined. If the call must be inlined, a compile error is emitted.
      </p>
      {#see_also|@inlineCall#}
      {#header_close#}
      {#header_open|@OpaqueType#}
      <pre>{#syntax#}@OpaqueType() type{#endsyntax#}</pre>
      <p>
      Creates a new type with an unknown (but non-zero) size and alignment.
      </p>
      <p>
      This is typically used for type safety when interacting with C code that does not expose struct details.
      Example:
      </p>
      {#code_begin|test_err|expected type '*Derp', found '*Wat'#}
const Derp = @OpaqueType();
const Wat = @OpaqueType();

extern fn bar(d: *Derp) void;
export fn foo(w: *Wat) void {
    bar(w);
}

test "call foo" {
    foo(undefined);
}
      {#code_end#}
      {#header_close#}
      {#header_open|@panic#}
      <pre>{#syntax#}@panic(message: []const u8) noreturn{#endsyntax#}</pre>
      <p>
      Invokes the panic handler function. By default the panic handler function
      calls the public {#syntax#}panic{#endsyntax#} function exposed in the root source file, or
          if there is not one specified, invokes the one provided in {#syntax#}std/special/panic.zig{#endsyntax#}.
      </p>
      <p>Generally it is better to use {#syntax#}@import("std").debug.panic{#endsyntax#}.
          However, {#syntax#}@panic{#endsyntax#} can be useful for 2 scenarios:
      </p>
      <ul>
        <li>From library code, calling the programmer's panic function if they exposed one in the root source file.</li>
        <li>When mixing C and Zig code, calling the canonical panic implementation across multiple .o files.</li>
      </ul>
      {#see_also|Root Source File#}
      {#header_close#}
      {#header_open|@popCount#}
      <pre>{#syntax#}@popCount(integer: var) var{#endsyntax#}</pre>
      <p>Counts the number of bits set in an integer.</p>
      <p>
      If {#syntax#}integer{#endsyntax#} is known at {#link|comptime#}, the return type is {#syntax#}comptime_int{#endsyntax#}.
      Otherwise, the return type is an unsigned integer with the minimum number
      of bits that can represent the bit count of the integer type.
      </p>
      {#see_also|@ctz|@clz#}
      {#header_close#}
      {#header_open|@ptrCast#}
      <pre>{#syntax#}@ptrCast(comptime DestType: type, value: var) DestType{#endsyntax#}</pre>
      <p>
      Converts a pointer of one type to a pointer of another type.
      </p>
      {#header_close#}
      {#header_open|@ptrToInt#}
      <pre>{#syntax#}@ptrToInt(value: var) usize{#endsyntax#}</pre>
      <p>
      Converts {#syntax#}value{#endsyntax#} to a {#syntax#}usize{#endsyntax#} which is the address of the pointer. {#syntax#}value{#endsyntax#} can be one of these types:
      </p>
      <ul>
          <li>{#syntax#}*T{#endsyntax#}</li>
          <li>{#syntax#}?*T{#endsyntax#}</li>
          <li>{#syntax#}fn(){#endsyntax#}</li>
          <li>{#syntax#}?fn(){#endsyntax#}</li>
      </ul>
      <p>To convert the other way, use {#link|@intToPtr#}</p>

      {#header_close#}
      {#header_open|@rem#}
      <pre>{#syntax#}@rem(numerator: T, denominator: T) T{#endsyntax#}</pre>
      <p>
      Remainder division. For unsigned integers this is the same as
      {#syntax#}numerator % denominator{#endsyntax#}. Caller guarantees {#syntax#}denominator > 0{#endsyntax#}.
      </p>
      <ul>
          <li>{#syntax#}@rem(-5, 3) == -2{#endsyntax#}</li>
          <li>{#syntax#}@divTrunc(a, b) + @rem(a, b) == a{#endsyntax#}</li>
      </ul>
      <p>For a function that returns an error code, see {#syntax#}@import("std").math.rem{#endsyntax#}.</p>
      {#see_also|@mod#}
      {#header_close#}
      {#header_open|@returnAddress#}
      <pre>{#syntax#}@returnAddress(){#endsyntax#}</pre>
      <p>
      This function returns a pointer to the return address of the current stack
      frame.
      </p>
      <p>
      The implications of this are target specific and not consistent across
      all platforms.
      </p>
      <p>
      This function is only valid within function scope.
      </p>
      {#header_close#}
      {#header_open|@setAlignStack#}
      <pre>{#syntax#}@setAlignStack(comptime alignment: u29){#endsyntax#}</pre>
      <p>
      Ensures that a function will have a stack alignment of at least {#syntax#}alignment{#endsyntax#} bytes.
      </p>
      {#header_close#}
      {#header_open|@setCold#}
      <pre>{#syntax#}@setCold(is_cold: bool){#endsyntax#}</pre>
      <p>
      Tells the optimizer that a function is rarely called.
      </p>
      {#header_close#}
      {#header_open|@setRuntimeSafety#}
      <pre>{#syntax#}@setRuntimeSafety(safety_on: bool){#endsyntax#}</pre>
      <p>
      Sets whether runtime safety checks are on for the scope that contains the function call.
      </p>

      {#header_close#}
      {#header_open|@setEvalBranchQuota#}
      <pre>{#syntax#}@setEvalBranchQuota(new_quota: usize){#endsyntax#}</pre>
      <p>
      Changes the maximum number of backwards branches that compile-time code
      execution can use before giving up and making a compile error.
      </p>
      <p>
      If the {#syntax#}new_quota{#endsyntax#} is smaller than the default quota ({#syntax#}1000{#endsyntax#}) or
      a previously explicitly set quota, it is ignored.
      </p>
      <p>
      Example:
      </p>
      {#code_begin|test_err|evaluation exceeded 1000 backwards branches#}
test "foo" {
    comptime {
        var i = 0;
        while (i < 1001) : (i += 1) {}
    }
}
      {#code_end#}
      <p>Now we use {#syntax#}@setEvalBranchQuota{#endsyntax#}:</p>
      {#code_begin|test#}
test "foo" {
    comptime {
        @setEvalBranchQuota(1001);
        var i = 0;
        while (i < 1001) : (i += 1) {}
    }
}
      {#code_end#}

      {#see_also|comptime#}
      {#header_close#}
      {#header_open|@setFloatMode#}
      <pre>{#syntax#}@setFloatMode(mode: @import("builtin").FloatMode){#endsyntax#}</pre>
      <p>
      Sets the floating point mode of the current scope. Possible values are:
      </p>
      {#code_begin|syntax#}
pub const FloatMode = enum {
    Strict,
    Optimized,
};
      {#code_end#}
      <ul>
        <li>
            {#syntax#}Strict{#endsyntax#} (default) - Floating point operations follow strict IEEE compliance.
        </li>
        <li>
            {#syntax#}Optimized{#endsyntax#} - Floating point operations may do all of the following:
          <ul>
            <li>Assume the arguments and result are not NaN. Optimizations are required to retain defined behavior over NaNs, but the value of the result is undefined.</li>
            <li>Assume the arguments and result are not +/-Inf. Optimizations are required to retain defined behavior over +/-Inf, but the value of the result is undefined.</li>
            <li>Treat the sign of a zero argument or result as insignificant.</li>
            <li>Use the reciprocal of an argument rather than perform division.</li>
            <li>Perform floating-point contraction (e.g. fusing a multiply followed by an addition into a fused multiply-and-add).</li>
            <li>Perform algebraically equivalent transformations that may change results in floating point (e.g. reassociate).</li>
          </ul>
          This is equivalent to <code>-ffast-math</code> in GCC.
        </li>
      </ul>
      <p>
      The floating point mode is inherited by child scopes, and can be overridden in any scope.
      You can set the floating point mode in a struct or module scope by using a comptime block.
      </p>
      {#see_also|Floating Point Operations#}
      {#header_close#}
      {#header_open|@setGlobalLinkage#}
      <pre>{#syntax#}@setGlobalLinkage(global_variable_name, comptime linkage: GlobalLinkage){#endsyntax#}</pre>
      <p>
      {#syntax#}GlobalLinkage{#endsyntax#} can be found with {#syntax#}@import("builtin").GlobalLinkage{#endsyntax#}.
      </p>
      {#see_also|Compile Variables#}
      {#header_close#}
      {#header_open|@shlExact#}
      <pre>{#syntax#}@shlExact(value: T, shift_amt: Log2T) T{#endsyntax#}</pre>
      <p>
      Performs the left shift operation ({#syntax#}<<{#endsyntax#}). Caller guarantees
      that the shift will not shift any 1 bits out.
      </p>
      <p>
      The type of {#syntax#}shift_amt{#endsyntax#} is an unsigned integer with {#syntax#}log2(T.bit_count){#endsyntax#} bits.
              This is because {#syntax#}shift_amt >= T.bit_count{#endsyntax#} is undefined behavior.
      </p>
      {#see_also|@shrExact|@shlWithOverflow#}
      {#header_close#}
      {#header_open|@shlWithOverflow#}
      <pre>{#syntax#}@shlWithOverflow(comptime T: type, a: T, shift_amt: Log2T, result: *T) bool{#endsyntax#}</pre>
      <p>
      Performs {#syntax#}result.* = a << b{#endsyntax#}. If overflow or underflow occurs,
                 stores the overflowed bits in {#syntax#}result{#endsyntax#} and returns {#syntax#}true{#endsyntax#}.
                         If no overflow or underflow occurs, returns {#syntax#}false{#endsyntax#}.
      </p>
      <p>
      The type of {#syntax#}shift_amt{#endsyntax#} is an unsigned integer with {#syntax#}log2(T.bit_count){#endsyntax#} bits.
              This is because {#syntax#}shift_amt >= T.bit_count{#endsyntax#} is undefined behavior.
      </p>
      {#see_also|@shlExact|@shrExact#}
      {#header_close#}
      {#header_open|@shrExact#}
      <pre>{#syntax#}@shrExact(value: T, shift_amt: Log2T) T{#endsyntax#}</pre>
      <p>
      Performs the right shift operation ({#syntax#}>>{#endsyntax#}). Caller guarantees
      that the shift will not shift any 1 bits out.
      </p>
      <p>
      The type of {#syntax#}shift_amt{#endsyntax#} is an unsigned integer with {#syntax#}log2(T.bit_count){#endsyntax#} bits.
              This is because {#syntax#}shift_amt >= T.bit_count{#endsyntax#} is undefined behavior.
      </p>
      {#see_also|@shlExact|@shlWithOverflow#}
      {#header_close#}

      {#header_open|@sizeOf#}
      <pre>{#syntax#}@sizeOf(comptime T: type) comptime_int{#endsyntax#}</pre>
      <p>
      This function returns the number of bytes it takes to store {#syntax#}T{#endsyntax#} in memory.
      </p>
      <p>
      The result is a target-specific compile time constant.
      </p>
      {#header_close#}

      {#header_open|@sliceToBytes#}
      <pre>{#syntax#}@sliceToBytes(value: var) []u8{#endsyntax#}</pre>
      <p>
      Converts a slice or array to a slice of {#syntax#}u8{#endsyntax#}. The resulting slice has the same
      {#link|pointer|Pointers#} properties as the parameter.
      </p>
      {#header_close#}

      {#header_open|@sqrt#}
      <pre>{#syntax#}@sqrt(comptime T: type, value: T) T{#endsyntax#}</pre>
      <p>
      Performs the square root of a floating point number. Uses a dedicated hardware instruction
      when available. Currently only supports f32 and f64 at runtime. f128 at runtime is TODO.
      </p>
      <p>
      This is a low-level intrinsic. Most code can use {#syntax#}std.math.sqrt{#endsyntax#} instead.
      </p>
      {#header_close#}
      {#header_open|@subWithOverflow#}
      <pre>{#syntax#}@subWithOverflow(comptime T: type, a: T, b: T, result: *T) bool{#endsyntax#}</pre>
      <p>
      Performs {#syntax#}result.* = a - b{#endsyntax#}. If overflow or underflow occurs,
          stores the overflowed bits in {#syntax#}result{#endsyntax#} and returns {#syntax#}true{#endsyntax#}.
                  If no overflow or underflow occurs, returns {#syntax#}false{#endsyntax#}.
      </p>
      {#header_close#}
      {#header_open|@tagName#}
      <pre>{#syntax#}@tagName(value: var) []const u8{#endsyntax#}</pre>
      <p>
      Converts an enum value or union value to a slice of bytes representing the name.
      </p>
      {#header_close#}
      {#header_open|@TagType#}
      <pre>{#syntax#}@TagType(T: type) type{#endsyntax#}</pre>
      <p>
      For an enum, returns the integer type that is used to store the enumeration value.
      </p>
      <p>
      For a union, returns the enum type that is used to store the tag value.
      </p>
      {#header_close#}
      {#header_open|@This#}
      <pre>{#syntax#}@This() type{#endsyntax#}</pre>
      <p>
      Returns the innermost struct or union that this function call is inside.
      This can be useful for an anonymous struct that needs to refer to itself:
      </p>
      {#code_begin|test#}
const std = @import("std");
const assert = std.debug.assert;

test "@This()" {
    var items = []i32{ 1, 2, 3, 4 };
    const list = List(i32){ .items = items[0..] };
    assert(list.length() == 4);
}

fn List(comptime T: type) type {
    return struct {
        const Self = @This();

        items: []T,

        fn length(self: Self) usize {
            return self.items.len;
        }
    };
}
      {#code_end#}
      <p>
      When {#syntax#}@This(){#endsyntax#} is used at global scope, it returns a reference to the
      current import. There is a proposal to remove the import type and use an empty struct
      type instead. See 
      <a href="https://github.com/ziglang/zig/issues/1047">#1047</a> for details.
      </p>
      {#header_close#}
      {#header_open|@truncate#}
      <pre>{#syntax#}@truncate(comptime T: type, integer) T{#endsyntax#}</pre>
      <p>
      This function truncates bits from an integer type, resulting in a smaller
      integer type.
      </p>
      <p>
      The following produces a crash in debug mode and undefined behavior in
      release mode:
      </p>
      <pre>{#syntax#}const a: u16 = 0xabcd;
const b: u8 = u8(a);{#endsyntax#}</pre>
      <p>
      However this is well defined and working code:
      </p>
      <pre>{#syntax#}const a: u16 = 0xabcd;
const b: u8 = @truncate(u8, a);
// b is now 0xcd{#endsyntax#}</pre>
      <p>
      This function always truncates the significant bits of the integer, regardless
      of endianness on the target platform.
      </p>

      {#header_close#}
      {#header_open|@typeId#}
      <pre>{#syntax#}@typeId(comptime T: type) @import("builtin").TypeId{#endsyntax#}</pre>
      <p>
      Returns which kind of type something is. Possible values:
      </p>
      {#code_begin|syntax#}
pub const TypeId = enum {
    Type,
    Void,
    Bool,
    NoReturn,
    Int,
    Float,
    Pointer,
    Array,
    Struct,
    ComptimeFloat,
    ComptimeInt,
    Undefined,
    Null,
    Optional,
    ErrorUnion,
    Error,
    Enum,
    Union,
    Fn,
    Namespace,
    Block,
    BoundFn,
    ArgTuple,
    Opaque,
};
      {#code_end#}
      {#header_close#}
      {#header_open|@typeInfo#}
      <pre>{#syntax#}@typeInfo(comptime T: type) @import("builtin").TypeInfo{#endsyntax#}</pre>
      <p>
      Returns information on the type. Returns a value of the following union:
      </p>
      {#code_begin|syntax#}
pub const TypeInfo = union(TypeId) {
    Type: void,
    Void: void,
    Bool: void,
    NoReturn: void,
    Int: Int,
    Float: Float,
    Pointer: Pointer,
    Array: Array,
    Struct: Struct,
    ComptimeFloat: void,
    ComptimeInt: void,
    Undefined: void,
    Null: void,
    Optional: Optional,
    ErrorUnion: ErrorUnion,
    ErrorSet: ErrorSet,
    Enum: Enum,
    Union: Union,
    Fn: Fn,
    Namespace: void,
    BoundFn: Fn,
    ArgTuple: void,
    Opaque: void,
    Promise: Promise,


    pub const Int = struct {
        is_signed: bool,
        bits: u8,
    };

    pub const Float = struct {
        bits: u8,
    };

    pub const Pointer = struct {
        size: Size,
        is_const: bool,
        is_volatile: bool,
        alignment: u32,
        child: type,

        pub const Size = enum {
            One,
            Many,
            Slice,
        };
    };

    pub const Array = struct {
        len: usize,
        child: type,
    };

    pub const ContainerLayout = enum {
        Auto,
        Extern,
        Packed,
    };

    pub const StructField = struct {
        name: []const u8,
        offset: ?usize,
        field_type: type,
    };

    pub const Struct = struct {
        layout: ContainerLayout,
        fields: []StructField,
        defs: []Definition,
    };

    pub const Optional = struct {
        child: type,
    };

    pub const ErrorUnion = struct {
        error_set: type,
        payload: type,
    };

    pub const Error = struct {
        name: []const u8,
        value: usize,
    };

    pub const ErrorSet = struct {
        errors: []Error,
    };

    pub const EnumField = struct {
        name: []const u8,
        value: usize,
    };

    pub const Enum = struct {
        layout: ContainerLayout,
        tag_type: type,
        fields: []EnumField,
        defs: []Definition,
    };

    pub const UnionField = struct {
        name: []const u8,
        enum_field: ?EnumField,
        field_type: type,
    };

    pub const Union = struct {
        layout: ContainerLayout,
        tag_type: ?type,
        fields: []UnionField,
        defs: []Definition,
    };

    pub const CallingConvention = enum {
        Unspecified,
        C,
        Cold,
        Naked,
        Stdcall,
        Async,
    };

    pub const FnArg = struct {
        is_generic: bool,
        is_noalias: bool,
        arg_type: ?type,
    };

    pub const Fn = struct {
        calling_convention: CallingConvention,
        is_generic: bool,
        is_var_args: bool,
        return_type: ?type,
        async_allocator_type: ?type,
        args: []FnArg,
    };

    pub const Promise = struct {
        child: ?type,
    };

    pub const Definition = struct {
        name: []const u8,
        is_pub: bool,
        data: Data,

        pub const Data = union(enum) {
            Type: type,
            Var: type,
            Fn: FnDef,

            pub const FnDef = struct {
                fn_type: type,
                inline_type: Inline,
                calling_convention: CallingConvention,
                is_var_args: bool,
                is_extern: bool,
                is_export: bool,
                lib_name: ?[]const u8,
                return_type: type,
                arg_names: [][] const u8,

                pub const Inline = enum {
                    Auto,
                    Always,
                    Never,
                };
            };
        };
    };
};
      {#code_end#}
      {#header_close#}
      {#header_open|@typeName#}
      <pre>{#syntax#}@typeName(T: type) []u8{#endsyntax#}</pre>
      <p>
      This function returns the string representation of a type.
      </p>

      {#header_close#}
      {#header_open|@typeOf#}
      <pre>{#syntax#}@typeOf(expression) type{#endsyntax#}</pre>
      <p>
      This function returns a compile-time constant, which is the type of the
      expression passed as an argument. The expression is evaluated.
      </p>

      {#header_close#}
      {#header_close#}
      {#header_open|Build Mode#}
      <p>
      Zig has four build modes:
      </p>
      <ul>
        <li>{#link|Debug#} (default)</li>
        <li>{#link|ReleaseFast#}</li>
        <li>{#link|ReleaseSafe#}</li>
        <li>{#link|ReleaseSmall#}</li>
      </ul>
      <p>
      To add standard build options to a <code>build.zig</code> file:
      </p>
      {#code_begin|syntax#}
const Builder = @import("std").build.Builder;

pub fn build(b: *Builder) void {
    const exe = b.addExecutable("example", "example.zig");
    exe.setBuildMode(b.standardReleaseOptions());
    b.default_step.dependOn(&exe.step);
}
      {#code_end#}
      <p>
      This causes these options to be available:
      </p>
      <pre><code class="shell">  -Drelease-safe=[bool] optimizations on and safety on
  -Drelease-fast=[bool] optimizations on and safety off
  -Drelease-small=[bool] size optimizations on and safety off</code></pre>
      {#header_open|Debug#}
      <pre><code class="shell">$ zig build-exe example.zig</code></pre>
      <ul>
        <li>Fast compilation speed</li>
        <li>Safety checks enabled</li>
        <li>Slow runtime performance</li>
        <li>Large binary size</li>
        <li>No reproducible build requirement</li>
      </ul>
      {#header_close#}
      {#header_open|ReleaseFast#}
      <pre><code class="shell">$ zig build-exe example.zig --release-fast</code></pre>
      <ul>
        <li>Fast runtime performance</li>
        <li>Safety checks disabled</li>
        <li>Slow compilation speed</li>
        <li>Large binary size</li>
        <li>Reproducible build</li>
      </ul>
      {#header_close#}
      {#header_open|ReleaseSafe#}
      <pre><code class="shell">$ zig build-exe example.zig --release-safe</code></pre>
      <ul>
        <li>Medium runtime performance</li>
        <li>Safety checks enabled</li>
        <li>Slow compilation speed</li>
        <li>Large binary size</li>
        <li>Reproducible build</li>
      </ul>
      {#header_close#}
      {#header_open|ReleaseSmall#}
      <pre><code class="shell">$ zig build-exe example.zig --release-small</code></pre>
      <ul>
        <li>Medium runtime performance</li>
        <li>Safety checks disabled</li>
        <li>Slow compilation speed</li>
        <li>Small binary size</li>
        <li>Reproducible build</li>
      </ul>
      {#header_close#}
      {#see_also|Compile Variables|Zig Build System|Undefined Behavior#}
      {#header_close#}
      {#header_open|Undefined Behavior#}
      <p>
      Zig has many instances of undefined behavior. If undefined behavior is
      detected at compile-time, Zig emits a compile error and refuses to continue.
      Most undefined behavior that cannot be detected at compile-time can be detected
      at runtime. In these cases, Zig has safety checks. Safety checks can be disabled
      on a per-block basis with {#link|setRuntimeSafety#}. The {#link|ReleaseFast#}
      build mode disables all safety checks in order to facilitate optimizations.
      </p>
      <p>
      When a safety check fails, Zig crashes with a stack trace, like this:
      </p>
      {#code_begin|test_err|reached unreachable code#}
test "safety check" {
    unreachable;
}
      {#code_end#}
      {#header_open|Reaching Unreachable Code#}
      <p>At compile-time:</p>
      {#code_begin|test_err|unable to evaluate constant expression#}
comptime {
    assert(false);
}
fn assert(ok: bool) void {
    if (!ok) unreachable; // assertion failure
}
      {#code_end#}
      <p>At runtime:</p>
      {#code_begin|exe_err#}
const std = @import("std");

pub fn main() void {
    std.debug.assert(false);
}
      {#code_end#}
      {#header_close#}
      {#header_open|Index out of Bounds#}
      <p>At compile-time:</p>
      {#code_begin|test_err|index 5 outside array of size 5#}
comptime {
    const array = "hello";
    const garbage = array[5];
}
      {#code_end#}
      <p>At runtime:</p>
      {#code_begin|exe_err#}
pub fn main() void {
    var x = foo("hello");
}

fn foo(x: []const u8) u8 {
    return x[5];
}
      {#code_end#}
      {#header_close#}
      {#header_open|Cast Negative Number to Unsigned Integer#}
      <p>At compile-time:</p>
      {#code_begin|test_err|attempt to cast negative value to unsigned integer#}
comptime {
    const value: i32 = -1;
    const unsigned = @intCast(u32, value);
}
      {#code_end#}
      <p>At runtime:</p>
      {#code_begin|exe_err#}
const std = @import("std");

pub fn main() void {
    var value: i32 = -1;
    var unsigned = @intCast(u32, value);
    std.debug.warn("value: {}\n", unsigned);
}
      {#code_end#}
      <p>
      To obtain the maximum value of an unsigned integer, use {#syntax#}std.math.maxInt{#endsyntax#}.
      </p>
      {#header_close#}
      {#header_open|Cast Truncates Data#}
      <p>At compile-time:</p>
      {#code_begin|test_err|cast from 'u16' to 'u8' truncates bits#}
comptime {
    const spartan_count: u16 = 300;
    const byte = @intCast(u8, spartan_count);
}
      {#code_end#}
      <p>At runtime:</p>
      {#code_begin|exe_err#}
const std = @import("std");

pub fn main() void {
    var spartan_count: u16 = 300;
    const byte = @intCast(u8, spartan_count);
    std.debug.warn("value: {}\n", byte);
}
      {#code_end#}
      <p>
      To truncate bits, use {#link|@truncate#}.
      </p>
      {#header_close#}
      {#header_open|Integer Overflow#}
      {#header_open|Default Operations#}
      <p>The following operators can cause integer overflow:</p>
      <ul>
          <li>{#syntax#}+{#endsyntax#} (addition)</li>
          <li>{#syntax#}-{#endsyntax#} (subtraction)</li>
          <li>{#syntax#}-{#endsyntax#} (negation)</li>
          <li>{#syntax#}*{#endsyntax#} (multiplication)</li>
          <li>{#syntax#}/{#endsyntax#} (division)</li>
        <li>{#link|@divTrunc#} (division)</li>
        <li>{#link|@divFloor#} (division)</li>
        <li>{#link|@divExact#} (division)</li>
      </ul>
      <p>Example with addition at compile-time:</p>
      {#code_begin|test_err|operation caused overflow#}
comptime {
    var byte: u8 = 255;
    byte += 1;
}
      {#code_end#}
      <p>At runtime:</p>
      {#code_begin|exe_err#}
const std = @import("std");

pub fn main() void {
    var byte: u8 = 255;
    byte += 1;
    std.debug.warn("value: {}\n", byte);
}
      {#code_end#}
      {#header_close#}
      {#header_open|Standard Library Math Functions#}
      <p>These functions provided by the standard library return possible errors.</p>
      <ul>
          <li>{#syntax#}@import("std").math.add{#endsyntax#}</li>
          <li>{#syntax#}@import("std").math.sub{#endsyntax#}</li>
          <li>{#syntax#}@import("std").math.mul{#endsyntax#}</li>
          <li>{#syntax#}@import("std").math.divTrunc{#endsyntax#}</li>
          <li>{#syntax#}@import("std").math.divFloor{#endsyntax#}</li>
          <li>{#syntax#}@import("std").math.divExact{#endsyntax#}</li>
          <li>{#syntax#}@import("std").math.shl{#endsyntax#}</li>
      </ul>
      <p>Example of catching an overflow for addition:</p>
      {#code_begin|exe_err#}
const math = @import("std").math;
const warn = @import("std").debug.warn;
pub fn main() !void {
    var byte: u8 = 255;

    byte = if (math.add(u8, byte, 1)) |result| result else |err| {
        warn("unable to add one: {}\n", @errorName(err));
        return err;
    };

    warn("result: {}\n", byte);
}
      {#code_end#}
      {#header_close#}
      {#header_open|Builtin Overflow Functions#}
      <p>
      These builtins return a {#syntax#}bool{#endsyntax#} of whether or not overflow
      occurred, as well as returning the overflowed bits:
      </p>
      <ul>
          <li>{#link|@addWithOverflow#}</li>
          <li>{#link|@subWithOverflow#}</li>
          <li>{#link|@mulWithOverflow#}</li>
          <li>{#link|@shlWithOverflow#}</li>
      </ul>
      <p>
      Example of {#link|@addWithOverflow#}:
      </p>
      {#code_begin|exe#}
const warn = @import("std").debug.warn;
pub fn main() void {
    var byte: u8 = 255;

    var result: u8 = undefined;
    if (@addWithOverflow(u8, byte, 10, &result)) {
        warn("overflowed result: {}\n", result);
    } else {
        warn("result: {}\n", result);
    }
}
      {#code_end#}
      {#header_close#}
      {#header_open|Wrapping Operations#}
      <p>
      These operations have guaranteed wraparound semantics.
      </p>
      <ul>
          <li>{#syntax#}+%{#endsyntax#} (wraparound addition)</li>
          <li>{#syntax#}-%{#endsyntax#} (wraparound subtraction)</li>
          <li>{#syntax#}-%{#endsyntax#} (wraparound negation)</li>
          <li>{#syntax#}*%{#endsyntax#} (wraparound multiplication)</li>
      </ul>
      {#code_begin|test#}
const std = @import("std");
const assert = std.debug.assert;
const minInt = std.math.minInt;
const maxInt = std.math.maxInt;

test "wraparound addition and subtraction" {
    const x: i32 = maxInt(i32);
    const min_val = x +% 1;
    assert(min_val == minInt(i32));
    const max_val = min_val -% 1;
    assert(max_val == maxInt(i32));
}
      {#code_end#}
      {#header_close#}
      {#header_close#}
      {#header_open|Exact Left Shift Overflow#}
      <p>At compile-time:</p>
      {#code_begin|test_err|operation caused overflow#}
comptime {
    const x = @shlExact(u8(0b01010101), 2);
}
      {#code_end#}
      <p>At runtime:</p>
      {#code_begin|exe_err#}
const std = @import("std");

pub fn main() void {
    var x: u8 = 0b01010101;
    var y = @shlExact(x, 2);
    std.debug.warn("value: {}\n", y);
}
      {#code_end#}
      {#header_close#}
      {#header_open|Exact Right Shift Overflow#}
      <p>At compile-time:</p>
      {#code_begin|test_err|exact shift shifted out 1 bits#}
comptime {
    const x = @shrExact(u8(0b10101010), 2);
}
      {#code_end#}
      <p>At runtime:</p>
      {#code_begin|exe_err#}
const std = @import("std");

pub fn main() void {
    var x: u8 = 0b10101010;
    var y = @shrExact(x, 2);
    std.debug.warn("value: {}\n", y);
}
      {#code_end#}
      {#header_close#}
      {#header_open|Division by Zero#}
      <p>At compile-time:</p>
      {#code_begin|test_err|division by zero#}
comptime {
    const a: i32 = 1;
    const b: i32 = 0;
    const c = a / b;
}
      {#code_end#}
      <p>At runtime:</p>
      {#code_begin|exe_err#}
const std = @import("std");

pub fn main() void {
    var a: u32 = 1;
    var b: u32 = 0;
    var c = a / b;
    std.debug.warn("value: {}\n", c);
}
      {#code_end#}
      {#header_close#}
      {#header_open|Remainder Division by Zero#}
      <p>At compile-time:</p>
      {#code_begin|test_err|division by zero#}
comptime {
    const a: i32 = 10;
    const b: i32 = 0;
    const c = a % b;
}
      {#code_end#}
      <p>At runtime:</p>
      {#code_begin|exe_err#}
const std = @import("std");

pub fn main() void {
    var a: u32 = 10;
    var b: u32 = 0;
    var c = a % b;
    std.debug.warn("value: {}\n", c);
}
      {#code_end#}
      {#header_close#}
      {#header_open|Exact Division Remainder#}
      <p>At compile-time:</p>
      {#code_begin|test_err|exact division had a remainder#}
comptime {
    const a: u32 = 10;
    const b: u32 = 3;
    const c = @divExact(a, b);
}
      {#code_end#}
      <p>At runtime:</p>
      {#code_begin|exe_err#}
const std = @import("std");

pub fn main() void {
    var a: u32 = 10;
    var b: u32 = 3;
    var c = @divExact(a, b);
    std.debug.warn("value: {}\n", c);
}
      {#code_end#}
      {#header_close#}
      {#header_open|Slice Widen Remainder#}
      <p>At compile-time:</p>
      {#code_begin|test_err|unable to convert#}
comptime {
    var bytes = [5]u8{ 1, 2, 3, 4, 5 };
    var slice = @bytesToSlice(u32, bytes);
}
      {#code_end#}
      <p>At runtime:</p>
      {#code_begin|exe_err#}
const std = @import("std");

pub fn main() void {
    var bytes = [5]u8{ 1, 2, 3, 4, 5 };
    var slice = @bytesToSlice(u32, bytes[0..]);
    std.debug.warn("value: {}\n", slice[0]);
}
      {#code_end#}
      {#header_close#}
      {#header_open|Attempt to Unwrap Null#}
      <p>At compile-time:</p>
      {#code_begin|test_err|unable to unwrap null#}
comptime {
    const optional_number: ?i32 = null;
    const number = optional_number.?;
}
      {#code_end#}
      <p>At runtime:</p>
      {#code_begin|exe_err#}
const std = @import("std");

pub fn main() void {
    var optional_number: ?i32 = null;
    var number = optional_number.?;
    std.debug.warn("value: {}\n", number);
}
      {#code_end#}
      <p>One way to avoid this crash is to test for null instead of assuming non-null, with
      the {#syntax#}if{#endsyntax#} expression:</p>
      {#code_begin|exe|test#}
const warn = @import("std").debug.warn;
pub fn main() void {
    const optional_number: ?i32 = null;

    if (optional_number) |number| {
        warn("got number: {}\n", number);
    } else {
        warn("it's null\n");
    }
}
      {#code_end#}
      {#see_also|Optionals#}
      {#header_close#}
      {#header_open|Attempt to Unwrap Error#}
      <p>At compile-time:</p>
      {#code_begin|test_err|caught unexpected error 'UnableToReturnNumber'#}
comptime {
    const number = getNumberOrFail() catch unreachable;
}

fn getNumberOrFail() !i32 {
    return error.UnableToReturnNumber;
}
      {#code_end#}
      <p>At runtime:</p>
      {#code_begin|exe_err#}
const std = @import("std");

pub fn main() void {
    const number = getNumberOrFail() catch unreachable;
    std.debug.warn("value: {}\n", number);
}

fn getNumberOrFail() !i32 {
    return error.UnableToReturnNumber;
}
      {#code_end#}
      <p>One way to avoid this crash is to test for an error instead of assuming a successful result, with
      the {#syntax#}if{#endsyntax#} expression:</p>
      {#code_begin|exe#}
const warn = @import("std").debug.warn;

pub fn main() void {
    const result = getNumberOrFail();

    if (result) |number| {
        warn("got number: {}\n", number);
    } else |err| {
        warn("got error: {}\n", @errorName(err));
    }
}

fn getNumberOrFail() !i32 {
    return error.UnableToReturnNumber;
}
      {#code_end#}
      {#see_also|Errors#}
      {#header_close#}
      {#header_open|Invalid Error Code#}
      <p>At compile-time:</p>
      {#code_begin|test_err|integer value 11 represents no error#}
comptime {
    const err = error.AnError;
    const number = @errorToInt(err) + 10;
    const invalid_err = @intToError(number);
}
      {#code_end#}
      <p>At runtime:</p>
      {#code_begin|exe_err#}
const std = @import("std");

pub fn main() void {
    var err = error.AnError;
    var number = @errorToInt(err) + 500;
    var invalid_err = @intToError(number);
    std.debug.warn("value: {}\n", number);
}
      {#code_end#}
      {#header_close#}
      {#header_open|Invalid Enum Cast#}
      <p>At compile-time:</p>
      {#code_begin|test_err|has no tag matching integer value 3#}
const Foo = enum {
    A,
    B,
    C,
};
comptime {
    const a: u2 = 3;
    const b = @intToEnum(Foo, a);
}
      {#code_end#}
      <p>At runtime:</p>
      {#code_begin|exe_err#}
const std = @import("std");

const Foo = enum {
    A,
    B,
    C,
};

pub fn main() void {
    var a: u2 = 3;
    var b = @intToEnum(Foo, a);
    std.debug.warn("value: {}\n", @tagName(b));
}
      {#code_end#}
      {#header_close#}

      {#header_open|Invalid Error Set Cast#}
      <p>At compile-time:</p>
      {#code_begin|test_err|error.B not a member of error set 'Set2'#}
const Set1 = error{
    A,
    B,
};
const Set2 = error{
    A,
    C,
};
comptime {
    _ = @errSetCast(Set2, Set1.B);
}
      {#code_end#}
      <p>At runtime:</p>
      {#code_begin|exe_err#}
const std = @import("std");

const Set1 = error{
    A,
    B,
};
const Set2 = error{
    A,
    C,
};
pub fn main() void {
    foo(Set1.B);
}
fn foo(set1: Set1) void {
    const x = @errSetCast(Set2, set1);
    std.debug.warn("value: {}\n", x);
}
      {#code_end#}
      {#header_close#}

      {#header_open|Incorrect Pointer Alignment#}
      <p>At compile-time:</p>
      {#code_begin|test_err|pointer address 0x1 is not aligned to 4 bytes#}
comptime {
    const ptr = @intToPtr(*i32, 0x1);
    const aligned = @alignCast(4, ptr);
}
      {#code_end#}
      <p>At runtime:</p>
      {#code_begin|exe_err#}
pub fn main() !void {
    var array align(4) = []u32{ 0x11111111, 0x11111111 };
    const bytes = @sliceToBytes(array[0..]);
    if (foo(bytes) != 0x11111111) return error.Wrong;
}
fn foo(bytes: []u8) u32 {
    const slice4 = bytes[1..5];
    const int_slice = @bytesToSlice(u32, @alignCast(4, slice4));
    return int_slice[0];
}
      {#code_end#}
      {#header_close#}
      {#header_open|Wrong Union Field Access#}
      <p>At compile-time:</p>
      {#code_begin|test_err|accessing union field 'float' while field 'int' is set#}
comptime {
    var f = Foo{ .int = 42 };
    f.float = 12.34;
}

const Foo = union {
    float: f32,
    int: u32,
};
      {#code_end#}
      <p>At runtime:</p>
      {#code_begin|exe_err#}
const std = @import("std");

const Foo = union {
    float: f32,
    int: u32,
};

pub fn main() void {
    var f = Foo{ .int = 42 };
    bar(&f);
}

fn bar(f: *Foo) void {
    f.float = 12.34;
    std.debug.warn("value: {}\n", f.float);
}
      {#code_end#}
      <p>
      This safety is not available for {#syntax#}extern{#endsyntax#} or {#syntax#}packed{#endsyntax#} unions.
      </p>
      <p>
      To change the active field of a union, assign the entire union, like this:
      </p>
      {#code_begin|exe#}
const std = @import("std");

const Foo = union {
    float: f32,
    int: u32,
};

pub fn main() void {
    var f = Foo{ .int = 42 };
    bar(&f);
}

fn bar(f: *Foo) void {
    f.* = Foo{ .float = 12.34 };
    std.debug.warn("value: {}\n", f.float);
}
      {#code_end#}
      <p>
      To change the active field of a union when a meaningful value for the field is not known,
      use {#link|undefined#}, like this:
      </p>
      {#code_begin|exe#}
const std = @import("std");

const Foo = union {
    float: f32,
    int: u32,
};

pub fn main() void {
    var f = Foo{ .int = 42 };
    f = Foo{ .float = undefined };
    bar(&f);
    std.debug.warn("value: {}\n", f.float);
}

fn bar(f: *Foo) void {
    f.float = 12.34;
}
      {#code_end#}
      {#header_close#}

      {#header_open|Out of Bounds Float To Integer Cast#}
      <p>TODO</p>
      {#header_close#}

      {#header_close#}
      {#header_open|Memory#}
      <p>TODO: explain no default allocator in zig</p>
      <p>TODO: show how to use the allocator interface</p>
      <p>TODO: mention debug allocator</p>
      <p>TODO: importance of checking for allocation failure</p>
      <p>TODO: mention overcommit and the OOM Killer</p>
      <p>TODO: mention recursion</p>
      {#see_also|Pointers#}

      {#header_close#}
      {#header_open|Compile Variables#}
      <p>
      Compile variables are accessible by importing the {#syntax#}"builtin"{#endsyntax#} package,
      which the compiler makes available to every Zig source file. It contains
      compile-time constants such as the current target, endianness, and release mode.
      </p>
      {#code_begin|syntax#}
const builtin = @import("builtin");
const separator = if (builtin.os == builtin.Os.windows) '\\' else '/';
      {#code_end#}
      <p>
      Example of what is imported with {#syntax#}@import("builtin"){#endsyntax#}:
      </p>
      {#builtin#}
      {#see_also|Build Mode#}
      {#header_close#}
      {#header_open|Root Source File#}
      <p>TODO: explain how root source file finds other files</p>
      <p>TODO: pub fn main</p>
      <p>TODO: pub fn panic</p>
      <p>TODO: if linking with libc you can use export fn main</p>
      <p>TODO: order independent top level declarations</p>
      <p>TODO: lazy analysis</p>
      <p>TODO: using comptime { _ = @import() }</p>
      {#header_close#}
      {#header_open|Zig Test#}
      <p>TODO: basic usage</p>
      <p>TODO: lazy analysis</p>
      <p>TODO: --test-filter</p>
      <p>TODO: --test-name-prefix</p>
      <p>TODO: testing in releasefast and releasesafe mode. assert still works</p>
      {#header_close#}
      {#header_open|Zig Build System#}
      <p>TODO: explain purpose, it's supposed to replace make/cmake</p>
      <p>TODO: example of building a zig executable</p>
      <p>TODO: example of building a C library</p>
      {#header_close#}
      {#header_open|C#}
      <p>
      Although Zig is independent of C, and, unlike most other languages, does not depend on libc,
      Zig acknowledges the importance of interacting with existing C code.
      </p>
      <p>
      There are a few ways that Zig facilitates C interop.
      </p>
      {#header_open|C Type Primitives#}
      <p>
      These have guaranteed C ABI compatibility and can be used like any other type.
      </p>
      <ul>
          <li>{#syntax#}c_short{#endsyntax#}</li>
          <li>{#syntax#}c_ushort{#endsyntax#}</li>
          <li>{#syntax#}c_int{#endsyntax#}</li>
          <li>{#syntax#}c_uint{#endsyntax#}</li>
          <li>{#syntax#}c_long{#endsyntax#}</li>
          <li>{#syntax#}c_ulong{#endsyntax#}</li>
          <li>{#syntax#}c_longlong{#endsyntax#}</li>
          <li>{#syntax#}c_ulonglong{#endsyntax#}</li>
          <li>{#syntax#}c_longdouble{#endsyntax#}</li>
          <li>{#syntax#}c_void{#endsyntax#}</li>
      </ul>
      {#see_also|Primitive Types#}
      {#header_close#}
      {#header_open|C String Literals#}
      {#code_begin|exe#}
      {#link_libc#}
extern fn puts([*]const u8) void;

pub fn main() void {
    puts(c"this has a null terminator");
    puts(
        c\\and so
        c\\does this
        c\\multiline C string literal
    );
}
      {#code_end#}
      {#see_also|String Literals#}
      {#header_close#}
      {#header_open|Import from C Header File#}
      <p>
      The {#syntax#}@cImport{#endsyntax#} builtin function can be used
      to directly import symbols from .h files:
      </p>
      {#code_begin|exe#}
      {#link_libc#}
const c = @cImport({
    // See https://github.com/ziglang/zig/issues/515
    @cDefine("_NO_CRT_STDIO_INLINE", "1");
    @cInclude("stdio.h");
});
pub fn main() void {
    _ = c.printf(c"hello\n");
}
      {#code_end#}
      <p>
      The {#syntax#}@cImport{#endsyntax#} function takes an expression as a parameter.
      This expression is evaluated at compile-time and is used to control
      preprocessor directives and include multiple .h files:
      </p>
      {#code_begin|syntax#}
const builtin = @import("builtin");

const c = @cImport({
    @cDefine("NDEBUG", builtin.mode == builtin.Mode.ReleaseFast);
    if (something) {
        @cDefine("_GNU_SOURCE", {});
    }
    @cInclude("stdlib.h");
    if (something) {
        @cUndef("_GNU_SOURCE");
    }
    @cInclude("soundio.h");
});
      {#code_end#}
      {#see_also|@cImport|@cInclude|@cDefine|@cUndef|@import#}
      {#header_close#}
      {#header_open|Exporting a C Library#}
      <p>
      One of the primary use cases for Zig is exporting a library with the C ABI for other programming languages
      to call into. The {#syntax#}export{#endsyntax#} keyword in front of functions, variables, and types causes them to
      be part of the library API:
      </p>
      <p class="file">mathtest.zig</p>
      {#code_begin|syntax#}
export fn add(a: i32, b: i32) i32 {
    return a + b;
}
      {#code_end#}
      <p>To make a shared library:</p>
      <pre><code class="shell">$ zig build-lib mathtest.zig
</code></pre>
      <p>To make a static library:</p>
      <pre><code class="shell">$ zig build-lib mathtest.zig --static
</code></pre>
      <p>Here is an example with the {#link|Zig Build System#}:</p>
      <p class="file">test.c</p>
      <pre><code class="cpp">// This header is generated by zig from mathtest.zig
#include "mathtest.h"
#include &lt;assert.h&gt;

int main(int argc, char **argv) {
    assert(add(42, 1337) == 1379);
    return 0;
}</code></pre>
      <p class="file">build.zig</p>
      {#code_begin|syntax#}
const Builder = @import("std").build.Builder;

pub fn build(b: *Builder) void {
    const lib = b.addSharedLibrary("mathtest", "mathtest.zig", b.version(1, 0, 0));

    const exe = b.addCExecutable("test");
    exe.addCompileFlags([][]const u8{"-std=c99"});
    exe.addSourceFile("test.c");
    exe.linkLibrary(lib);

    b.default_step.dependOn(&exe.step);

    const run_cmd = b.addCommand(".", b.env_map, [][]const u8{exe.getOutputPath()});
    run_cmd.step.dependOn(&exe.step);

    const test_step = b.step("test", "Test the program");
    test_step.dependOn(&run_cmd.step);
}
      {#code_end#}
      <p class="file">terminal</p>
      <pre><code class="shell">$ zig build
$ ./test
$ echo $?
0</code></pre>
      {#header_close#}
      {#header_open|Mixing Object Files#}
      <p>
      You can mix Zig object files with any other object files that respect the C ABI. Example:
      </p>
      <p class="file">base64.zig</p>
      {#code_begin|syntax#}
const base64 = @import("std").base64;

export fn decode_base_64(
    dest_ptr: [*]u8,
    dest_len: usize,
    source_ptr: [*]const u8,
    source_len: usize,
) usize {
    const src = source_ptr[0..source_len];
    const dest = dest_ptr[0..dest_len];
    const base64_decoder = base64.standard_decoder_unsafe;
    const decoded_size = base64_decoder.calcSize(src);
    base64_decoder.decode(dest[0..decoded_size], src);
    return decoded_size;
}
      {#code_end#}
      <p class="file">test.c</p>
      <pre><code class="cpp">// This header is generated by zig from base64.zig
#include "base64.h"

#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

int main(int argc, char **argv) {
    const char *encoded = "YWxsIHlvdXIgYmFzZSBhcmUgYmVsb25nIHRvIHVz";
    char buf[200];

    size_t len = decode_base_64(buf, 200, encoded, strlen(encoded));
    buf[len] = 0;
    puts(buf);

    return 0;
}</code></pre>
      <p class="file">build.zig</p>
      {#code_begin|syntax#}
const Builder = @import("std").build.Builder;

pub fn build(b: *Builder) void {
    const obj = b.addObject("base64", "base64.zig");

    const exe = b.addCExecutable("test");
    exe.addCompileFlags([][]const u8 {
        "-std=c99",
    });
    exe.addSourceFile("test.c");
    exe.addObject(obj);
    exe.setOutputPath(".");

    b.default_step.dependOn(&exe.step);
}
      {#code_end#}
      <p class="file">terminal</p>
      <pre><code class="shell">$ zig build
$ ./test
all your base are belong to us</code></pre>
      {#see_also|Targets|Zig Build System#}
      {#header_close#}
      {#header_close#}
      {#header_open|Targets#}
      <p>
      Zig supports generating code for all targets that LLVM supports. Here is
      what it looks like to execute <code>zig targets</code> on a Linux x86_64
      computer:
      </p>
      <pre><code class="shell">$ zig targets
Architectures:
  armv8_2a
  armv8_1a
  armv8
  armv8r
  armv8m_baseline
  armv8m_mainline
  armv7
  armv7em
  armv7m
  armv7s
  armv7k
  armv7ve
  armv6
  armv6m
  armv6k
  armv6t2
  armv5
  armv5te
  armv4t
  armeb
  aarch64
  aarch64_be
  avr
  bpfel
  bpfeb
  hexagon
  mips
  mipsel
  mips64
  mips64el
  msp430
  nios2
  powerpc
  powerpc64
  powerpc64le
  r600
  amdgcn
  riscv32
  riscv64
  sparc
  sparcv9
  sparcel
  s390x
  tce
  tcele
  thumb
  thumbeb
  i386
  x86_64 (native)
  xcore
  nvptx
  nvptx64
  le32
  le64
  amdil
  amdil64
  hsail
  hsail64
  spir
  spir64
  kalimbav3
  kalimbav4
  kalimbav5
  shave
  lanai
  wasm32
  wasm64
  renderscript32
  renderscript64

Operating Systems:
  freestanding
  ananas
  cloudabi
  dragonfly
  freebsd
  fuchsia
  ios
  kfreebsd
  linux (native)
  lv2
  macosx
  netbsd
  openbsd
  solaris
  windows
  haiku
  minix
  rtems
  nacl
  cnk
  bitrig
  aix
  cuda
  nvcl
  amdhsa
  ps4
  elfiamcu
  tvos
  watchos
  mesa3d
  contiki
  zen

Environments:
  unknown
  gnu (native)
  gnuabi64
  gnueabi
  gnueabihf
  gnux32
  code16
  eabi
  eabihf
  android
  musl
  musleabi
  musleabihf
  msvc
  itanium
  cygnus
  amdopencl
  coreclr
  opencl</code></pre>
      <p>
      The Zig Standard Library ({#syntax#}@import("std"){#endsyntax#}) has architecture, environment, and operating sytsem
      abstractions, and thus takes additional work to support more platforms.
      Not all standard library code requires operating system abstractions, however,
      so things such as generic data structures work an all above platforms.
      </p>
      <p>The current list of targets supported by the Zig Standard Library is:</p>
      <ul>
      <li>Linux x86_64</li>
      <li>Windows x86_64</li>
      <li>MacOS x86_64</li>
      </ul>
      {#header_close#}
      {#header_open|Style Guide#}
      <p>
These coding conventions are not enforced by the compiler, but they are shipped in
this documentation along with the compiler in order to provide a point of
reference, should anyone wish to point to an authority on agreed upon Zig
coding style.
      </p>
      {#header_open|Whitespace#}
      <ul>
        <li>
          4 space indentation
        </li>
        <li>
          Open braces on same line, unless you need to wrap.
        </li>
        <li>If a list of things is longer than 2, put each item on its own line and
          exercise the ability to put an extra comma at the end.
        </li>
        <li>
          Line length: aim for 100; use common sense.
        </li>
      </ul>
      {#header_close#}
      {#header_open|Names#}
      <p>
      Roughly speaking: {#syntax#}camelCaseFunctionName{#endsyntax#}, {#syntax#}TitleCaseTypeName{#endsyntax#},
              {#syntax#}snake_case_variable_name{#endsyntax#}. More precisely:
      </p>
      <ul>
        <li>
            If {#syntax#}x{#endsyntax#} is a {#syntax#}struct{#endsyntax#} (or an alias of a {#syntax#}struct{#endsyntax#}),
                        then {#syntax#}x{#endsyntax#} should be {#syntax#}TitleCase{#endsyntax#}.
        </li>
        <li>
            If {#syntax#}x{#endsyntax#} otherwise identifies a type, {#syntax#}x{#endsyntax#} should have {#syntax#}snake_case{#endsyntax#}.
        </li>
        <li>
            If {#syntax#}x{#endsyntax#} is callable, and {#syntax#}x{#endsyntax#}'s return type is {#syntax#}type{#endsyntax#}, then {#syntax#}x{#endsyntax#} should be {#syntax#}TitleCase{#endsyntax#}.
        </li>
        <li>
            If {#syntax#}x{#endsyntax#} is otherwise callable, then {#syntax#}x{#endsyntax#} should be {#syntax#}camelCase{#endsyntax#}.
        </li>
        <li>
            Otherwise, {#syntax#}x{#endsyntax#} should be {#syntax#}snake_case{#endsyntax#}.
        </li>
      </ul>
      <p>
      Acronyms, initialisms, proper nouns, or any other word that has capitalization
      rules in written English are subject to naming conventions just like any other
      word. Even acronyms that are only 2 letters long are subject to these
      conventions.
      </p>
      <p>
      These are general rules of thumb; if it makes sense to do something different,
      do what makes sense. For example, if there is an established convention such as
      {#syntax#}ENOENT{#endsyntax#}, follow the established convention.
      </p>
      {#header_close#}
      {#header_open|Examples#}
      {#code_begin|syntax#}
const namespace_name = @import("dir_name/file_name.zig");
var global_var: i32 = undefined;
const const_name = 42;
const primitive_type_alias = f32;
const string_alias = []u8;

const StructName = struct {};
const StructAlias = StructName;

fn functionName(param_name: TypeName) void {
    var functionPointer = functionName;
    functionPointer();
    functionPointer = otherFunction;
    functionPointer();
}
const functionAlias = functionName;

fn ListTemplateFunction(comptime ChildType: type, comptime fixed_size: usize) type {
    return List(ChildType, fixed_size);
}

fn ShortList(comptime T: type, comptime n: usize) type {
    return struct {
        field_name: [n]T,
        fn methodName() void {}
    };
}

// The word XML loses its casing when used in Zig identifiers.
const xml_document =
    \\<?xml version="1.0" encoding="UTF-8"?>
    \\<document>
    \\</document>
;
const XmlParser = struct {};

// The initials BE (Big Endian) are just another word in Zig identifier names.
fn readU32Be() u32 {}
      {#code_end#}
      <p>
      See the Zig Standard Library for more examples.
      </p>
      {#header_close#}
      {#header_close#}
      {#header_open|Source Encoding#}
      <p>Zig source code is encoded in UTF-8. An invalid UTF-8 byte sequence results in a compile error.</p>
      <p>Throughout all zig source code (including in comments), some codepoints are never allowed:</p>
      <ul>
        <li>Ascii control characters, except for U+000a (LF): U+0000 - U+0009, U+000b - U+0001f, U+007f. (Note that Windows line endings (CRLF) are not allowed, and hard tabs are not allowed.)</li>
        <li>Non-Ascii Unicode line endings: U+0085 (NEL), U+2028 (LS), U+2029 (PS).</li>
      </ul>
      <p>The codepoint U+000a (LF) (which is encoded as the single-byte value 0x0a) is the line terminator character. This character always terminates a line of zig source code (except possbly the last line of the file).</p>
      <p>For some discussion on the rationale behind these design decisions, see <a href="https://github.com/ziglang/zig/issues/663">issue #663</a></p>
      {#header_close#}
      {#header_open|Grammar#}
      <pre><code>Root &lt;- skip ContainerMembers eof

# *** Top level ***
ContainerMembers
    &lt;- TestDecl ContainerMembers
     / TopLevelComptime ContainerMembers
     / KEYWORD_pub? TopLevelDecl ContainerMembers
     / KEYWORD_pub? ContainerField COMMA ContainerMembers
     / KEYWORD_pub? ContainerField
     /

TestDecl &lt;- KEYWORD_test STRINGLITERAL Block

TopLevelComptime &lt;- KEYWORD_comptime BlockExpr

TopLevelDecl
    &lt;- (KEYWORD_export / KEYWORD_extern STRINGLITERAL? / KEYWORD_inline)? FnProto (SEMICOLON / Block)
     / (KEYWORD_export / KEYWORD_extern STRINGLITERAL?)? VarDecl
     / KEYWORD_use Expr SEMICOLON

FnProto &lt;- FnCC? KEYWORD_fn IDENTIFIER? LPAREN ParamDeclList RPAREN ByteAlign? LinkSection? EXCLAMATIONMARK? (KEYWORD_var / TypeExpr)

VarDecl &lt;- (KEYWORD_const / KEYWORD_var) IDENTIFIER (COLON TypeExpr)? ByteAlign? LinkSection? (EQUAL Expr)? SEMICOLON

ContainerField &lt;- IDENTIFIER (COLON TypeExpr)? (EQUAL Expr)?

# *** Block Level ***
Statement
    &lt;- KEYWORD_comptime? VarDecl
     / KEYWORD_comptime BlockExprStatement
     / KEYWORD_suspend (SEMICOLON / BlockExprStatement)
     / KEYWORD_defer BlockExprStatement
     / KEYWORD_errdefer BlockExprStatement
     / IfStatement
     / LabeledStatement
     / SwitchExpr
     / AssignExpr SEMICOLON

IfStatement
    &lt;- IfPrefix BlockExpr ( KEYWORD_else Payload? Statement )?
     / IfPrefix AssignExpr ( SEMICOLON / KEYWORD_else Payload? Statement )

LabeledStatement &lt;- BlockLabel? (Block / LoopStatement)

LoopStatement &lt;- KEYWORD_inline? (ForStatement / WhileStatement)

ForStatement
    &lt;- ForPrefix BlockExpr ( KEYWORD_else Statement )?
     / ForPrefix AssignExpr ( SEMICOLON / KEYWORD_else Statement )

WhileStatement
    &lt;- WhilePrefix BlockExpr ( KEYWORD_else Payload? Statement )?
     / WhilePrefix AssignExpr ( SEMICOLON / KEYWORD_else Payload? Statement )

BlockExprStatement
    &lt;- BlockExpr
     / AssignExpr SEMICOLON

BlockExpr &lt;- BlockLabel? Block

# *** Expression Level ***
AssignExpr &lt;- Expr (AssignOp Expr)?

Expr &lt;- KEYWORD_try* BoolOrExpr

BoolOrExpr &lt;- BoolAndExpr (KEYWORD_or BoolAndExpr)*

BoolAndExpr &lt;- CompareExpr (KEYWORD_and CompareExpr)*

CompareExpr &lt;- BitwiseExpr (CompareOp BitwiseExpr)?

BitwiseExpr &lt;- BitShiftExpr (BitwiseOp BitShiftExpr)*

BitShiftExpr &lt;- AdditionExpr (BitShiftOp AdditionExpr)*

AdditionExpr &lt;- MultiplyExpr (AdditionOp MultiplyExpr)*

MultiplyExpr &lt;- PrefixExpr (MultiplyOp PrefixExpr)*

PrefixExpr &lt;- PrefixOp* PrimaryExpr

PrimaryExpr
    &lt;- AsmExpr
     / IfExpr
     / KEYWORD_break BreakLabel? Expr?
     / KEYWORD_cancel Expr
     / KEYWORD_comptime Expr
     / KEYWORD_continue BreakLabel?
     / KEYWORD_resume Expr
     / KEYWORD_return Expr?
     / LabeledExpr
     / CurlySuffixExpr

IfExpr &lt;- IfPrefix Expr (KEYWORD_else Payload? Expr)?

LabeledExpr &lt;- BlockLabel? (Block / LoopExpr)

Block &lt;- LBRACE Statement* RBRACE

LoopExpr &lt;- KEYWORD_inline? (ForExpr / WhileExpr)

ForExpr &lt;- ForPrefix Expr (KEYWORD_else Expr)?

WhileExpr &lt;- WhilePrefix Expr (KEYWORD_else Payload? Expr)?

CurlySuffixExpr &lt;- TypeExpr InitList?

InitList
    &lt;- LBRACE FieldInit (COMMA FieldInit)* COMMA? RBRACE
     / LBRACE Expr (COMMA Expr)* COMMA? RBRACE
     / LBRACE RBRACE

TypeExpr &lt;- PrefixTypeOp* ErrorUnionExpr

ErrorUnionExpr &lt;- SuffixExpr (EXCLAMATIONMARK TypeExpr)?

SuffixExpr
    &lt;- AsyncPrefix PrimaryTypeExpr SuffixOp* FnCallArguments
     / PrimaryTypeExpr (SuffixOp / FnCallArguments)*

PrimaryTypeExpr
    &lt;- BUILTINIDENTIFIER FnCallArguments
     / CHAR_LITERAL
     / ContainerDecl
     / ErrorSetDecl
     / FLOAT
     / FnProto
     / GroupedExpr
     / LabeledTypeExpr
     / IDENTIFIER
     / IfTypeExpr
     / INTEGER
     / KEYWORD_anyerror
     / KEYWORD_comptime TypeExpr
     / KEYWORD_error DOT IDENTIFIER
     / KEYWORD_false
     / KEYWORD_null
     / KEYWORD_promise
     / KEYWORD_true
     / KEYWORD_undefined
     / KEYWORD_unreachable
     / STRINGLITERAL
     / SwitchExpr

ContainerDecl &lt;- (KEYWORD_extern / KEYWORD_packed)? ContainerDeclAuto

ErrorSetDecl &lt;- KEYWORD_error LBRACE IdentifierList RBRACE

GroupedExpr &lt;- LPAREN Expr RPAREN

IfTypeExpr &lt;- IfPrefix TypeExpr (KEYWORD_else Payload? TypeExpr)?

LabeledTypeExpr
    &lt;- BlockLabel Block
     / BlockLabel? LoopTypeExpr

LoopTypeExpr &lt;- KEYWORD_inline? (ForTypeExpr / WhileTypeExpr)

ForTypeExpr &lt;- ForPrefix TypeExpr (KEYWORD_else TypeExpr)?

WhileTypeExpr &lt;- WhilePrefix TypeExpr (KEYWORD_else Payload? TypeExpr)?

SwitchExpr &lt;- KEYWORD_switch LPAREN Expr RPAREN LBRACE SwitchProngList RBRACE

# *** Assembly ***
AsmExpr &lt;- KEYWORD_asm KEYWORD_volatile? LPAREN STRINGLITERAL AsmOutput? RPAREN

AsmOutput &lt;- COLON AsmOutputList AsmInput?

AsmOutputItem &lt;- LBRACKET IDENTIFIER RBRACKET STRINGLITERAL LPAREN (MINUSRARROW TypeExpr / IDENTIFIER) RPAREN

AsmInput &lt;- COLON AsmInputList AsmClobbers?

AsmInputItem &lt;- LBRACKET IDENTIFIER RBRACKET STRINGLITERAL LPAREN Expr RPAREN

AsmClobbers &lt;- COLON StringList

# *** Helper grammar ***
BreakLabel &lt;- COLON IDENTIFIER

BlockLabel &lt;- IDENTIFIER COLON

FieldInit &lt;- DOT IDENTIFIER EQUAL Expr

WhileContinueExpr &lt;- COLON LPAREN AssignExpr RPAREN

LinkSection &lt;- KEYWORD_linksection LPAREN Expr RPAREN

# Fn specific
FnCC
    &lt;- KEYWORD_nakedcc
     / KEYWORD_stdcallcc
     / KEYWORD_extern
     / KEYWORD_async (LARROW TypeExpr RARROW)?

ParamDecl &lt;- (KEYWORD_noalias / KEYWORD_comptime)? (IDENTIFIER COLON)? ParamType

ParamType
    &lt;- KEYWORD_var
     / DOT3
     / TypeExpr

# Control flow prefixes
IfPrefix &lt;- KEYWORD_if LPAREN Expr RPAREN PtrPayload?

WhilePrefix &lt;- KEYWORD_while LPAREN Expr RPAREN PtrPayload? WhileContinueExpr?

ForPrefix &lt;- KEYWORD_for LPAREN Expr RPAREN PtrIndexPayload

# Payloads
Payload &lt;- PIPE IDENTIFIER PIPE

PtrPayload &lt;- PIPE ASTERISK? IDENTIFIER PIPE

PtrIndexPayload &lt;- PIPE ASTERISK? IDENTIFIER (COMMA IDENTIFIER)? PIPE


# Switch specific
SwitchProng &lt;- SwitchCase EQUALRARROW PtrPayload? AssignExpr

SwitchCase
    &lt;- SwitchItem (COMMA SwitchItem)* COMMA?
     / KEYWORD_else

SwitchItem &lt;- Expr (DOT3 Expr)?

# Operators
AssignOp
    &lt;- ASTERISKEQUAL
     / SLASHEQUAL
     / PERCENTEQUAL
     / PLUSEQUAL
     / MINUSEQUAL
     / LARROW2EQUAL
     / RARROW2EQUAL
     / AMPERSANDEQUAL
     / CARETEQUAL
     / PIPEEQUAL
     / ASTERISKPERCENTEQUAL
     / PLUSPERCENTEQUAL
     / MINUSPERCENTEQUAL
     / EQUAL

CompareOp
    &lt;- EQUALEQUAL
     / EXCLAMATIONMARKEQUAL
     / LARROW
     / RARROW
     / LARROWEQUAL
     / RARROWEQUAL

BitwiseOp
    &lt;- AMPERSAND
     / CARET
     / PIPE
     / KEYWORD_orelse
     / KEYWORD_catch Payload?

BitShiftOp
    &lt;- LARROW2
     / RARROW2

AdditionOp
    &lt;- PLUS
     / MINUS
     / PLUS2
     / PLUSPERCENT
     / MINUSPERCENT

MultiplyOp
    &lt;- PIPE2
     / ASTERISK
     / SLASH
     / PERCENT
     / ASTERISK2
     / ASTERISKPERCENT

PrefixOp
    &lt;- EXCLAMATIONMARK
     / MINUS
     / TILDE
     / MINUSPERCENT
     / AMPERSAND
     / KEYWORD_try
     / KEYWORD_await

PrefixTypeOp
    &lt;- QUESTIONMARK
     / KEYWORD_promise MINUSRARROW
     / ArrayTypeStart (ByteAlign / KEYWORD_const / KEYWORD_volatile)*
     / PtrTypeStart (KEYWORD_align LPAREN Expr (COLON INTEGER COLON INTEGER)? RPAREN / KEYWORD_const / KEYWORD_volatile)*

SuffixOp
    &lt;- LBRACKET Expr (DOT2 Expr?)? RBRACKET
     / DOT IDENTIFIER
     / DOTASTERISK
     / DOTQUESTIONMARK

AsyncPrefix &lt;- KEYWORD_async (LARROW PrefixExpr RARROW)?

FnCallArguments &lt;- LPAREN ExprList RPAREN

# Ptr specific
ArrayTypeStart &lt;- LBRACKET Expr? RBRACKET

PtrTypeStart
    &lt;- ASTERISK
     / ASTERISK2
     / LBRACKET ASTERISK RBRACKET

# ContainerDecl specific
ContainerDeclAuto &lt;- ContainerDeclType LBRACE ContainerMembers RBRACE

ContainerDeclType
    &lt;- (KEYWORD_struct / KEYWORD_enum) (LPAREN Expr RPAREN)?
     / KEYWORD_union (LPAREN (KEYWORD_enum (LPAREN Expr RPAREN)? / Expr) RPAREN)?

# Alignment
ByteAlign &lt;- KEYWORD_align LPAREN Expr RPAREN

# Lists
IdentifierList &lt;- (IDENTIFIER COMMA)* IDENTIFIER?

SwitchProngList &lt;- (SwitchProng COMMA)* SwitchProng?

AsmOutputList &lt;- (AsmOutputItem COMMA)* AsmOutputItem?

AsmInputList &lt;- (AsmInputItem COMMA)* AsmInputItem?

StringList &lt;- (STRINGLITERAL COMMA)* STRINGLITERAL?

ParamDeclList &lt;- (ParamDecl COMMA)* ParamDecl?

ExprList &lt;- (Expr COMMA)* Expr?

# *** Tokens ***
eof &lt;- !.
hex &lt;- [0-9a-fA-F]
char_escape
    &lt;- "\\x" hex hex
     / "\\u" hex hex hex hex
     / "\\U" hex hex hex hex hex hex
     / "\\" [nr\\t'"]
char_char
    &lt;- char_escape
     / [^\\'\n]
string_char
    &lt;- char_escape
     / [^\\"\n]

line_comment &lt;- '//'[^\n]*
line_string &lt;- ("\\\\" [^\n]* [ \n]*)+
line_cstring &lt;- ("c\\\\" [^\n]* [ \n]*)+
skip &lt;- ([ \n] / line_comment)*

CHAR_LITERAL &lt;- "'" char_char "'" skip
FLOAT
    &lt;- "0b" [01]+  "." [01]+  ([eE] [-+]? [01]+)?  skip
     / "0o" [0-7]+ "." [0-7]+ ([eE] [-+]? [0-7]+)? skip
     / "0x" hex+   "." hex+   ([pP] [-+]? hex+)?   skip
     /      [0-9]+ "." [0-9]+ ([eE] [-+]? [0-9]+)? skip
     / "0b" [01]+  "."? [eE] [-+]? [01]+  skip
     / "0o" [0-7]+ "."? [eE] [-+]? [0-7]+ skip
     / "0x" hex+   "."? [pP] [-+]? hex+   skip
     /      [0-9]+ "."? [eE] [-+]? [0-9]+ skip
INTEGER
    &lt;- "0b" [01]+  skip
     / "0o" [0-7]+ skip
     / "0x" hex+   skip
     /      [0-9]+ skip
STRINGLITERAL
    &lt;- "c"? "\"" string_char* "\"" skip
     / line_string                 skip
     / line_cstring                skip
IDENTIFIER
    &lt;- !keyword ("c" !["\\] / [A-Zabd-z_]) [A-Za-z0-9_]* skip
     / "@\"" string_char* "\""                            skip
BUILTINIDENTIFIER &lt;- "@"[A-Za-z_][A-Za-z0-9_]* skip


AMPERSAND            &lt;- '&'      ![=]      skip
AMPERSANDEQUAL       &lt;- '&='               skip
ASTERISK             &lt;- '*'      ![*%=]    skip
ASTERISK2            &lt;- '**'               skip
ASTERISKEQUAL        &lt;- '*='               skip
ASTERISKPERCENT      &lt;- '*%'     ![=]      skip
ASTERISKPERCENTEQUAL &lt;- '*%='              skip
CARET                &lt;- '^'      ![=]      skip
CARETEQUAL           &lt;- '^='               skip
COLON                &lt;- ':'                skip
COMMA                &lt;- ','                skip
DOT                  &lt;- '.'      ![*.?]    skip
DOT2                 &lt;- '..'     ![.]      skip
DOT3                 &lt;- '...'              skip
DOTASTERISK          &lt;- '.*'               skip
DOTQUESTIONMARK      &lt;- '.?'               skip
EQUAL                &lt;- '='      ![&gt;=]     skip
EQUALEQUAL           &lt;- '=='               skip
EQUALRARROW          &lt;- '=&gt;'               skip
EXCLAMATIONMARK      &lt;- '!'      ![=]      skip
EXCLAMATIONMARKEQUAL &lt;- '!='               skip
LARROW               &lt;- '&lt;'      ![&lt;=]     skip
LARROW2              &lt;- '&lt;&lt;'     ![=]      skip
LARROW2EQUAL         &lt;- '&lt;&lt;='              skip
LARROWEQUAL          &lt;- '&lt;='               skip
LBRACE               &lt;- '{'                skip
LBRACKET             &lt;- '['                skip
LPAREN               &lt;- '('                skip
MINUS                &lt;- '-'      ![%=&gt;]    skip
MINUSEQUAL           &lt;- '-='               skip
MINUSPERCENT         &lt;- '-%'     ![=]      skip
MINUSPERCENTEQUAL    &lt;- '-%='              skip
MINUSRARROW          &lt;- '-&gt;'               skip
PERCENT              &lt;- '%'      ![=]      skip
PERCENTEQUAL         &lt;- '%='               skip
PIPE                 &lt;- '|'      ![|=]     skip
PIPE2                &lt;- '||'               skip
PIPEEQUAL            &lt;- '|='               skip
PLUS                 &lt;- '+'      ![%+=]    skip
PLUS2                &lt;- '++'               skip
PLUSEQUAL            &lt;- '+='               skip
PLUSPERCENT          &lt;- '+%'     ![=]      skip
PLUSPERCENTEQUAL     &lt;- '+%='              skip
QUESTIONMARK         &lt;- '?'                skip
RARROW               &lt;- '&gt;'      ![&gt;=]     skip
RARROW2              &lt;- '&gt;&gt;'     ![=]      skip
RARROW2EQUAL         &lt;- '&gt;&gt;='              skip
RARROWEQUAL          &lt;- '&gt;='               skip
RBRACE               &lt;- '}'                skip
RBRACKET             &lt;- ']'                skip
RPAREN               &lt;- ')'                skip
SEMICOLON            &lt;- ';'                skip
SLASH                &lt;- '/'      ![=]      skip
SLASHEQUAL           &lt;- '/='               skip
TILDE                &lt;- '~'                skip

end_of_word &lt;- ![a-zA-Z0-9_] skip
KEYWORD_align       &lt;- 'align'       end_of_word
KEYWORD_and         &lt;- 'and'         end_of_word
KEYWORD_anyerror    &lt;- 'anyerror'    end_of_word
KEYWORD_asm         &lt;- 'asm'         end_of_word
KEYWORD_async       &lt;- 'async'       end_of_word
KEYWORD_await       &lt;- 'await'       end_of_word
KEYWORD_break       &lt;- 'break'       end_of_word
KEYWORD_cancel      &lt;- 'cancel'      end_of_word
KEYWORD_catch       &lt;- 'catch'       end_of_word
KEYWORD_comptime    &lt;- 'comptime'    end_of_word
KEYWORD_const       &lt;- 'const'       end_of_word
KEYWORD_continue    &lt;- 'continue'    end_of_word
KEYWORD_defer       &lt;- 'defer'       end_of_word
KEYWORD_else        &lt;- 'else'        end_of_word
KEYWORD_enum        &lt;- 'enum'        end_of_word
KEYWORD_errdefer    &lt;- 'errdefer'    end_of_word
KEYWORD_error       &lt;- 'error'       end_of_word
KEYWORD_export      &lt;- 'export'      end_of_word
KEYWORD_extern      &lt;- 'extern'      end_of_word
KEYWORD_false       &lt;- 'false'       end_of_word
KEYWORD_fn          &lt;- 'fn'          end_of_word
KEYWORD_for         &lt;- 'for'         end_of_word
KEYWORD_if          &lt;- 'if'          end_of_word
KEYWORD_inline      &lt;- 'inline'      end_of_word
KEYWORD_nakedcc     &lt;- 'nakedcc'     end_of_word
KEYWORD_noalias     &lt;- 'noalias'     end_of_word
KEYWORD_null        &lt;- 'null'        end_of_word
KEYWORD_or          &lt;- 'or'          end_of_word
KEYWORD_orelse      &lt;- 'orelse'      end_of_word
KEYWORD_packed      &lt;- 'packed'      end_of_word
KEYWORD_promise     &lt;- 'promise'     end_of_word
KEYWORD_pub         &lt;- 'pub'         end_of_word
KEYWORD_resume      &lt;- 'resume'      end_of_word
KEYWORD_return      &lt;- 'return'      end_of_word
KEYWORD_linksection &lt;- 'linksection' end_of_word
KEYWORD_stdcallcc   &lt;- 'stdcallcc'   end_of_word
KEYWORD_struct      &lt;- 'struct'      end_of_word
KEYWORD_suspend     &lt;- 'suspend'     end_of_word
KEYWORD_switch      &lt;- 'switch'      end_of_word
KEYWORD_test        &lt;- 'test'        end_of_word
KEYWORD_true        &lt;- 'true'        end_of_word
KEYWORD_try         &lt;- 'try'         end_of_word
KEYWORD_undefined   &lt;- 'undefined'   end_of_word
KEYWORD_union       &lt;- 'union'       end_of_word
KEYWORD_unreachable &lt;- 'unreachable' end_of_word
KEYWORD_use         &lt;- 'use'         end_of_word
KEYWORD_var         &lt;- 'var'         end_of_word
KEYWORD_volatile    &lt;- 'volatile'    end_of_word
KEYWORD_while       &lt;- 'while'       end_of_word

keyword &lt;- KEYWORD_align / KEYWORD_and / KEYWORD_anyerror / KEYWORD_asm
         / KEYWORD_async / KEYWORD_await / KEYWORD_break / KEYWORD_cancel
         / KEYWORD_catch / KEYWORD_comptime / KEYWORD_const / KEYWORD_continue
         / KEYWORD_defer / KEYWORD_else / KEYWORD_enum / KEYWORD_errdefer
         / KEYWORD_error / KEYWORD_export / KEYWORD_extern / KEYWORD_false
         / KEYWORD_fn / KEYWORD_for / KEYWORD_if / KEYWORD_inline
         / KEYWORD_nakedcc / KEYWORD_noalias / KEYWORD_null / KEYWORD_or
         / KEYWORD_orelse / KEYWORD_packed / KEYWORD_promise / KEYWORD_pub
         / KEYWORD_resume / KEYWORD_return / KEYWORD_linksection
         / KEYWORD_stdcallcc / KEYWORD_struct / KEYWORD_suspend
         / KEYWORD_switch / KEYWORD_test / KEYWORD_true / KEYWORD_try
         / KEYWORD_undefined / KEYWORD_union / KEYWORD_unreachable
         / KEYWORD_use / KEYWORD_var / KEYWORD_volatile / KEYWORD_while</code></pre>
      {#header_close#}
      {#header_open|Zen#}
      <ul>
        <li>Communicate intent precisely.</li>
        <li>Edge cases matter.</li>
        <li>Favor reading code over writing code.</li>
        <li>Only one obvious way to do things.</li>
        <li>Runtime crashes are better than bugs.</li>
        <li>Compile errors are better than runtime crashes.</li>
        <li>Incremental improvements.</li>
        <li>Avoid local maximums.</li>
        <li>Reduce the amount one must remember.</li>
        <li>Minimize energy spent on coding style.</li>
        <li>Together we serve end users.</li>
      </ul>
      {#header_close#}
    </div>
  </body>
</html>
