const W = Properties.makeOpt;

const pointer_sign_message = " converts between pointers to integer types with different sign";

# Maybe someday this will no longer be needed.
todo
    .msg = "TODO: {s}"
    .extra = .str
    .kind = .@"error"

error_directive
    .msg = "{s}"
    .extra = .str
    .kind = .@"error"

warning_directive
    .msg = "{s}"
    .opt = W("#warnings")
    .extra = .str
    .kind = .warning

elif_without_if
    .msg = "#elif without #if"
    .kind = .@"error"

elif_after_else
    .msg = "#elif after #else"
    .kind = .@"error"

elifdef_without_if
    .msg = "#elifdef without #if"
    .kind = .@"error"

elifdef_after_else
    .msg = "#elifdef after #else"
    .kind = .@"error"

elifndef_without_if
    .msg = "#elifndef without #if"
    .kind = .@"error"

elifndef_after_else
    .msg = "#elifndef after #else"
    .kind = .@"error"

else_without_if
    .msg = "#else without #if"
    .kind = .@"error"

else_after_else
    .msg = "#else after #else"
    .kind = .@"error"

endif_without_if
    .msg = "#endif without #if"
    .kind = .@"error"

unknown_pragma
    .msg = "unknown pragma ignored"
    .opt = W("unknown-pragmas")
    .kind = .off
    .all = true

line_simple_digit
    .msg = "#line directive requires a simple digit sequence"
    .kind = .@"error"

line_invalid_filename
    .msg = "invalid filename for #line directive"
    .kind = .@"error"

unterminated_conditional_directive
    .msg = "unterminated conditional directive"
    .kind = .@"error"

invalid_preprocessing_directive
    .msg = "invalid preprocessing directive"
    .kind = .@"error"

macro_name_missing
    .msg = "macro name missing"
    .kind = .@"error"

extra_tokens_directive_end
    .msg = "extra tokens at end of macro directive"
    .kind = .@"error"

expected_value_in_expr
    .msg = "expected value in expression"
    .kind = .@"error"

closing_paren
    .msg = "expected closing ')'"
    .kind = .@"error"

to_match_paren
    .msg = "to match this '('"
    .kind = .note

to_match_brace
    .msg = "to match this '{'"
    .kind = .note

to_match_bracket
    .msg = "to match this '['"
    .kind = .note

header_str_closing
    .msg = "expected closing '>'"
    .kind = .@"error"

header_str_match
    .msg = "to match this '<'"
    .kind = .note

string_literal_in_pp_expr
    .msg = "string literal in preprocessor expression"
    .kind = .@"error"

float_literal_in_pp_expr
    .msg = "floating point literal in preprocessor expression"
    .kind = .@"error"

defined_as_macro_name
    .msg = "'defined' cannot be used as a macro name"
    .kind = .@"error"

macro_name_must_be_identifier
    .msg = "macro name must be an identifier"
    .kind = .@"error"

whitespace_after_macro_name
    .msg = "ISO C99 requires whitespace after the macro name"
    .opt = W("c99-extensions")
    .kind = .warning

hash_hash_at_start
    .msg = "'##' cannot appear at the start of a macro expansion"
    .kind = .@"error"

hash_hash_at_end
    .msg = "'##' cannot appear at the end of a macro expansion"
    .kind = .@"error"

pasting_formed_invalid
    .msg = "pasting formed '{s}', an invalid preprocessing token"
    .extra = .str
    .kind = .@"error"

missing_paren_param_list
    .msg = "missing ')' in macro parameter list"
    .kind = .@"error"

unterminated_macro_param_list
    .msg = "unterminated macro param list"
    .kind = .@"error"

invalid_token_param_list
    .msg = "invalid token in macro parameter list"
    .kind = .@"error"

expected_comma_param_list
    .msg = "expected comma in macro parameter list"
    .kind = .@"error"

hash_not_followed_param
    .msg = "'#' is not followed by a macro parameter"
    .kind = .@"error"

expected_filename
    .msg = "expected \"FILENAME\" or <FILENAME>"
    .kind = .@"error"

empty_filename
    .msg = "empty filename"
    .kind = .@"error"

expected_invalid
    .msg = "expected '{s}', found invalid bytes"
    .extra = .tok_id_expected
    .kind = .@"error"

expected_eof
    .msg = "expected '{s}' before end of file"
    .extra = .tok_id_expected
    .kind = .@"error"

expected_token
    .msg = "expected '{s}', found '{s}'"
    .extra = .tok_id
    .kind = .@"error"

expected_expr
    .msg = "expected expression"
    .kind = .@"error"

expected_integer_constant_expr
    .msg = "expression is not an integer constant expression"
    .kind = .@"error"

missing_type_specifier
    .msg = "type specifier missing, defaults to 'int'"
    .opt = W("implicit-int")
    .kind = .warning
    .all = true

missing_type_specifier_c23
    .msg = "a type specifier is required for all declarations"
    .kind = .@"error"

multiple_storage_class
    .msg = "cannot combine with previous '{s}' declaration specifier"
    .extra = .str
    .kind = .@"error"

static_assert_failure
    .msg = "static assertion failed"
    .kind = .@"error"

static_assert_failure_message
    .msg = "static assertion failed {s}"
    .extra = .str
    .kind = .@"error"

expected_type
    .msg = "expected a type"
    .kind = .@"error"

cannot_combine_spec
    .msg = "cannot combine with previous '{s}' specifier"
    .extra = .str
    .kind = .@"error"

duplicate_decl_spec
    .msg = "duplicate '{s}' declaration specifier"
    .extra = .str
    .opt = W("duplicate-decl-specifier")
    .kind = .warning
    .all = true

restrict_non_pointer
    .msg = "restrict requires a pointer or reference ('{s}' is invalid)"
    .extra = .str
    .kind = .@"error"

expected_external_decl
    .msg = "expected external declaration"
    .kind = .@"error"

expected_ident_or_l_paren
    .msg = "expected identifier or '('"
    .kind = .@"error"

missing_declaration
    .msg = "declaration does not declare anything"
    .opt = W("missing-declaration")
    .kind = .warning

func_not_in_root
    .msg = "function definition is not allowed here"
    .kind = .@"error"

illegal_initializer
    .msg = "illegal initializer (only variables can be initialized)"
    .kind = .@"error"

extern_initializer
    .msg = "extern variable has initializer"
    .opt = W("extern-initializer")
    .kind = .warning

spec_from_typedef
    .msg = "'{s}' came from typedef"
    .extra = .str
    .kind = .note

param_before_var_args
    .msg = "ISO C requires a named parameter before '...'"
    .kind = .@"error"
    .suppress_version = .c23

void_only_param
    .msg = "'void' must be the only parameter if specified"
    .kind = .@"error"

void_param_qualified
    .msg = "'void' parameter cannot be qualified"
    .kind = .@"error"

void_must_be_first_param
    .msg = "'void' must be the first parameter if specified"
    .kind = .@"error"

invalid_storage_on_param
    .msg = "invalid storage class on function parameter"
    .kind = .@"error"

threadlocal_non_var
    .msg = "_Thread_local only allowed on variables"
    .kind = .@"error"

func_spec_non_func
    .msg = "'{s}' can only appear on functions"
    .extra = .str
    .kind = .@"error"

illegal_storage_on_func
    .msg = "illegal storage class on function"
    .kind = .@"error"

illegal_storage_on_global
    .msg = "illegal storage class on global variable"
    .kind = .@"error"

expected_stmt
    .msg = "expected statement"
    .kind = .@"error"

func_cannot_return_func
    .msg = "function cannot return a function"
    .kind = .@"error"

func_cannot_return_array
    .msg = "function cannot return an array"
    .kind = .@"error"

undeclared_identifier
    .msg = "use of undeclared identifier '{s}'"
    .extra = .str
    .kind = .@"error"

not_callable
    .msg = "cannot call non function type '{s}'"
    .extra = .str
    .kind = .@"error"

unsupported_str_cat
    .msg = "unsupported string literal concatenation"
    .kind = .@"error"

static_func_not_global
    .msg = "static functions must be global"
    .kind = .@"error"

implicit_func_decl
    .msg = "call to undeclared function '{s}'; ISO C99 and later do not support implicit function declarations"
    .extra = .str
    .opt = W("implicit-function-declaration")
    .kind = .@"error"
    .all = true

unknown_builtin
    .msg = "use of unknown builtin '{s}'"
    .extra = .str
    .opt = W("implicit-function-declaration")
    .kind = .@"error"
    .all = true

implicit_builtin
    .msg = "implicitly declaring library function '{s}'"
    .extra = .str
    .opt = W("implicit-function-declaration")
    .kind = .@"error"
    .all = true

implicit_builtin_header_note
    .msg = "include the header <{s}.h> or explicitly provide a declaration for '{s}'"
    .extra = .builtin_with_header
    .opt = W("implicit-function-declaration")
    .kind = .note
    .all = true

expected_param_decl
    .msg = "expected parameter declaration"
    .kind = .@"error"

invalid_old_style_params
    .msg = "identifier parameter lists are only allowed in function definitions"
    .kind = .@"error"

expected_fn_body
    .msg = "expected function body after function declaration"
    .kind = .@"error"

invalid_void_param
    .msg = "parameter cannot have void type"
    .kind = .@"error"

unused_value
    .msg = "expression result unused"
    .opt = W("unused-value")
    .kind = .warning
    .all = true

continue_not_in_loop
    .msg = "'continue' statement not in a loop"
    .kind = .@"error"

break_not_in_loop_or_switch
    .msg = "'break' statement not in a loop or a switch"
    .kind = .@"error"

unreachable_code
    .msg = "unreachable code"
    .opt = W("unreachable-code")
    .kind = .warning
    .all = true

duplicate_label
    .msg = "duplicate label '{s}'"
    .extra = .str
    .kind = .@"error"

previous_label
    .msg = "previous definition of label '{s}' was here"
    .extra = .str
    .kind = .note

undeclared_label
    .msg = "use of undeclared label '{s}'"
    .extra = .str
    .kind = .@"error"

case_not_in_switch
    .msg = "'{s}' statement not in a switch statement"
    .extra = .str
    .kind = .@"error"

duplicate_switch_case
    .msg = "duplicate case value '{s}'"
    .extra = .str
    .kind = .@"error"

multiple_default
    .msg = "multiple default cases in the same switch"
    .kind = .@"error"

previous_case
    .msg = "previous case defined here"
    .kind = .note

const expected_arguments = "expected {d} argument(s) got {d}";

expected_arguments
    .msg = expected_arguments
    .extra = .arguments
    .kind = .@"error"

expected_arguments_old
    .msg = expected_arguments
    .extra = .arguments
    .kind = .warning

expected_at_least_arguments
    .msg = "expected at least {d} argument(s) got {d}"
    .extra = .arguments
    .kind = .warning

invalid_static_star
    .msg = "'static' may not be used with an unspecified variable length array size"
    .kind = .@"error"

static_non_param
    .msg = "'static' used outside of function parameters"
    .kind = .@"error"

array_qualifiers
    .msg = "type qualifier in non parameter array type"
    .kind = .@"error"

star_non_param
    .msg = "star modifier used outside of function parameters"
    .kind = .@"error"

variable_len_array_file_scope
    .msg = "variable length arrays not allowed at file scope"
    .kind = .@"error"

useless_static
    .msg = "'static' useless without a constant size"
    .kind = .warning
    .w_extra = true

negative_array_size
    .msg = "array size must be 0 or greater"
    .kind = .@"error"

array_incomplete_elem
    .msg = "array has incomplete element type '{s}'"
    .extra = .str
    .kind = .@"error"

array_func_elem
    .msg = "arrays cannot have functions as their element type"
    .kind = .@"error"

static_non_outermost_array
    .msg = "'static' used in non-outermost array type"
    .kind = .@"error"

qualifier_non_outermost_array
    .msg = "type qualifier used in non-outermost array type"
    .kind = .@"error"

unterminated_macro_arg_list
    .msg = "unterminated function macro argument list"
    .kind = .@"error"

unknown_warning
    .msg = "unknown warning '{s}'"
    .extra = .str
    .opt = W("unknown-warning-option")
    .kind = .warning

overflow
    .msg = "overflow in expression; result is '{s}'"
    .extra = .str
    .opt = W("integer-overflow")
    .kind = .warning

int_literal_too_big
    .msg = "integer literal is too large to be represented in any integer type"
    .kind = .@"error"

indirection_ptr
    .msg = "indirection requires pointer operand"
    .kind = .@"error"

addr_of_rvalue
    .msg = "cannot take the address of an rvalue"
    .kind = .@"error"

addr_of_bitfield
    .msg = "address of bit-field requested"
    .kind = .@"error"

not_assignable
    .msg = "expression is not assignable"
    .kind = .@"error"

ident_or_l_brace
    .msg = "expected identifier or '{'"
    .kind = .@"error"

empty_enum
    .msg = "empty enum is invalid"
    .kind = .@"error"

redefinition
    .msg = "redefinition of '{s}'"
    .extra = .str
    .kind = .@"error"

previous_definition
    .msg = "previous definition is here"
    .kind = .note

expected_identifier
    .msg = "expected identifier"
    .kind = .@"error"

expected_str_literal
    .msg = "expected string literal for diagnostic message in static_assert"
    .kind = .@"error"

expected_str_literal_in
    .msg = "expected string literal in '{s}'"
    .extra = .str
    .kind = .@"error"

parameter_missing
    .msg = "parameter named '{s}' is missing"
    .extra = .str
    .kind = .@"error"

empty_record
    .msg = "empty {s} is a GNU extension"
    .extra = .str
    .opt = W("gnu-empty-struct")
    .kind = .off
    .pedantic = true

empty_record_size
    .msg = "empty {s} has size 0 in C, size 1 in C++"
    .extra = .str
    .opt = W("c++-compat")
    .kind = .off

wrong_tag
    .msg = "use of '{s}' with tag type that does not match previous definition"
    .extra = .str
    .kind = .@"error"

expected_parens_around_typename
    .msg = "expected parentheses around type name"
    .kind = .@"error"

alignof_expr
    .msg = "'_Alignof' applied to an expression is a GNU extension"
    .opt = W("gnu-alignof-expression")
    .kind = .warning
    .suppress_gnu = true

invalid_alignof
    .msg = "invalid application of 'alignof' to an incomplete type '{s}'"
    .extra = .str
    .kind = .@"error"

invalid_sizeof
    .msg = "invalid application of 'sizeof' to an incomplete type '{s}'"
    .extra = .str
    .kind = .@"error"

macro_redefined
    .msg = "'{s}' macro redefined"
    .extra = .str
    .opt = W("macro-redefined")
    .kind = .warning

generic_qual_type
    .msg = "generic association with qualifiers cannot be matched with"
    .opt = W("generic-qual-type")
    .kind = .warning

generic_array_type
    .msg = "generic association array type cannot be matched with"
    .opt = W("generic-qual-type")
    .kind = .warning

generic_func_type
    .msg = "generic association function type cannot be matched with"
    .opt = W("generic-qual-type")
    .kind = .warning

generic_duplicate
    .msg = "type '{s}' in generic association compatible with previously specified type"
    .extra = .str
    .kind = .@"error"

generic_duplicate_here
    .msg = "compatible type '{s}' specified here"
    .extra = .str
    .kind = .note

generic_duplicate_default
    .msg = "duplicate default generic association"
    .kind = .@"error"

generic_no_match
    .msg = "controlling expression type '{s}' not compatible with any generic association type"
    .extra = .str
    .kind = .@"error"

escape_sequence_overflow
    .msg = "escape sequence out of range"
    .kind = .@"error"

invalid_universal_character
    .msg = "invalid universal character"
    .kind = .@"error"

incomplete_universal_character
    .msg = "incomplete universal character name"
    .kind = .@"error"

multichar_literal_warning
    .msg = "multi-character character constant"
    .opt = W("multichar")
    .kind = .warning
    .all = true

invalid_multichar_literal
    .msg = "{s} character literals may not contain multiple characters"
    .kind = .@"error"
    .extra = .str

wide_multichar_literal
    .msg = "extraneous characters in character constant ignored"
    .kind = .warning

char_lit_too_wide
    .msg = "character constant too long for its type"
    .kind = .warning
    .all = true

char_too_large
    .msg = "character too large for enclosing character literal type"
    .kind = .@"error"

must_use_struct
    .msg = "must use 'struct' tag to refer to type '{s}'"
    .extra = .str
    .kind = .@"error"

must_use_union
    .msg = "must use 'union' tag to refer to type '{s}'"
    .extra = .str
    .kind = .@"error"

must_use_enum
    .msg = "must use 'enum' tag to refer to type '{s}'"
    .extra = .str
    .kind = .@"error"

redefinition_different_sym
    .msg = "redefinition of '{s}' as different kind of symbol"
    .extra = .str
    .kind = .@"error"

redefinition_incompatible
    .msg = "redefinition of '{s}' with a different type"
    .extra = .str
    .kind = .@"error"

redefinition_of_parameter
    .msg = "redefinition of parameter '{s}'"
    .extra = .str
    .kind = .@"error"

invalid_bin_types
    .msg = "invalid operands to binary expression ({s})"
    .extra = .str
    .kind = .@"error"

comparison_ptr_int
    .msg = "comparison between pointer and integer ({s})"
    .extra = .str
    .opt = W("pointer-integer-compare")
    .kind = .warning

comparison_distinct_ptr
    .msg = "comparison of distinct pointer types ({s})"
    .extra = .str
    .opt = W("compare-distinct-pointer-types")
    .kind = .warning

incompatible_pointers
    .msg = "incompatible pointer types ({s})"
    .extra = .str
    .kind = .@"error"

invalid_argument_un
    .msg = "invalid argument type '{s}' to unary expression"
    .extra = .str
    .kind = .@"error"

incompatible_assign
    .msg = "assignment to {s}"
    .extra = .str
    .kind = .@"error"

implicit_ptr_to_int
    .msg = "implicit pointer to integer conversion from {s}"
    .extra = .str
    .opt = W("int-conversion")
    .kind = .warning

invalid_cast_to_float
    .msg = "pointer cannot be cast to type '{s}'"
    .extra = .str
    .kind = .@"error"

invalid_cast_to_pointer
    .msg = "operand of type '{s}' cannot be cast to a pointer type"
    .extra = .str
    .kind = .@"error"

invalid_cast_type
    .msg = "cannot cast to non arithmetic or pointer type '{s}'"
    .extra = .str
    .kind = .@"error"

qual_cast
    .msg = "cast to type '{s}' will not preserve qualifiers"
    .extra = .str
    .opt = W("cast-qualifiers")
    .kind = .warning

invalid_index
    .msg = "array subscript is not an integer"
    .kind = .@"error"

invalid_subscript
    .msg = "subscripted value is not an array or pointer"
    .kind = .@"error"

array_after
    .msg = "array index {s} is past the end of the array"
    .extra = .str
    .opt = W("array-bounds")
    .kind = .warning

array_before
    .msg = "array index {s} is before the beginning of the array"
    .extra = .str
    .opt = W("array-bounds")
    .kind = .warning

statement_int
    .msg = "statement requires expression with integer type ('{s}' invalid)"
    .extra = .str
    .kind = .@"error"

statement_scalar
    .msg = "statement requires expression with scalar type ('{s}' invalid)"
    .extra = .str
    .kind = .@"error"

func_should_return
    .msg = "non-void function '{s}' should return a value"
    .extra = .str
    .opt = W("return-type")
    .kind = .@"error"
    .all = true

incompatible_return
    .msg = "returning {s}"
    .extra = .str
    .kind = .@"error"

incompatible_return_sign
    .msg = "returning {s}" ++ pointer_sign_message
    .extra = .str
    .kind = .warning
    .opt = W("pointer-sign")

implicit_int_to_ptr
    .msg = "implicit integer to pointer conversion from {s}"
    .extra = .str
    .opt = W("int-conversion")
    .kind = .warning

func_does_not_return
    .msg = "non-void function '{s}' does not return a value"
    .extra = .str
    .opt = W("return-type")
    .kind = .warning
    .all = true

void_func_returns_value
    .msg = "void function '{s}' should not return a value"
    .extra = .str
    .opt = W("return-type")
    .kind = .@"error"
    .all = true

incompatible_arg
    .msg = "passing {s}"
    .extra = .str
    .kind = .@"error"

incompatible_ptr_arg
    .msg = "passing {s}"
    .extra = .str
    .kind = .warning
    .opt = W("incompatible-pointer-types")

incompatible_ptr_arg_sign
    .msg = "passing {s}" ++ pointer_sign_message
    .extra = .str
    .kind = .warning
    .opt = W("pointer-sign")

parameter_here
    .msg = "passing argument to parameter here"
    .kind = .note

atomic_array
    .msg = "atomic cannot be applied to array type '{s}'"
    .extra = .str
    .kind = .@"error"

atomic_func
    .msg = "atomic cannot be applied to function type '{s}'"
    .extra = .str
    .kind = .@"error"

atomic_incomplete
    .msg = "atomic cannot be applied to incomplete type '{s}'"
    .extra = .str
    .kind = .@"error"

addr_of_register
    .msg = "address of register variable requested"
    .kind = .@"error"

variable_incomplete_ty
    .msg = "variable has incomplete type '{s}'"
    .extra = .str
    .kind = .@"error"

parameter_incomplete_ty
    .msg = "parameter has incomplete type '{s}'"
    .extra = .str
    .kind = .@"error"

tentative_array
    .msg = "tentative array definition assumed to have one element"
    .kind = .warning

deref_incomplete_ty_ptr
    .msg = "dereferencing pointer to incomplete type '{s}'"
    .extra = .str
    .kind = .@"error"

alignas_on_func
    .msg = "'_Alignas' attribute only applies to variables and fields"
    .kind = .@"error"

alignas_on_param
    .msg = "'_Alignas' attribute cannot be applied to a function parameter"
    .kind = .@"error"

minimum_alignment
    .msg = "requested alignment is less than minimum alignment of {d}"
    .extra = .unsigned
    .kind = .@"error"

maximum_alignment
    .msg = "requested alignment of {s} is too large"
    .extra = .str
    .kind = .@"error"

negative_alignment
    .msg = "requested negative alignment of {s} is invalid"
    .extra = .str
    .kind = .@"error"

align_ignored
    .msg = "'_Alignas' attribute is ignored here"
    .kind = .warning

zero_align_ignored
    .msg = "requested alignment of zero is ignored"
    .kind = .warning

non_pow2_align
    .msg = "requested alignment is not a power of 2"
    .kind = .@"error"

pointer_mismatch
    .msg = "pointer type mismatch ({s})"
    .extra = .str
    .opt = W("pointer-type-mismatch")
    .kind = .warning

static_assert_not_constant
    .msg = "static_assert expression is not an integral constant expression"
    .kind = .@"error"

static_assert_missing_message
    .msg = "static_assert with no message is a C23 extension"
    .opt = W("c23-extensions")
    .kind = .warning
    .suppress_version = .c23

pre_c23_compat
    .msg = "{s} is incompatible with C standards before C23"
    .extra = .str
    .kind = .off
    .suppress_unless_version = .c23
    .opt = W("pre-c23-compat")

unbound_vla
    .msg = "variable length array must be bound in function definition"
    .kind = .@"error"

array_too_large
    .msg = "array is too large"
    .kind = .@"error"

incompatible_ptr_init
    .msg = "incompatible pointer types initializing {s}"
    .extra = .str
    .opt = W("incompatible-pointer-types")
    .kind = .warning

incompatible_ptr_init_sign
    .msg = "incompatible pointer types initializing {s}" ++ pointer_sign_message
    .extra = .str
    .opt = W("pointer-sign")
    .kind = .warning

incompatible_ptr_assign
    .msg = "incompatible pointer types assigning to {s}"
    .extra = .str
    .opt = W("incompatible-pointer-types")
    .kind = .warning

incompatible_ptr_assign_sign
    .msg = "incompatible pointer types assigning to {s} " ++ pointer_sign_message
    .extra = .str
    .opt = W("pointer-sign")
    .kind = .warning

vla_init
    .msg = "variable-sized object may not be initialized"
    .kind = .@"error"

func_init
    .msg = "illegal initializer type"
    .kind = .@"error"

incompatible_init
    .msg = "initializing {s}"
    .extra = .str
    .kind = .@"error"

empty_scalar_init
    .msg = "scalar initializer cannot be empty"
    .kind = .@"error"

excess_scalar_init
    .msg = "excess elements in scalar initializer"
    .opt = W("excess-initializers")
    .kind = .warning

excess_str_init
    .msg = "excess elements in string initializer"
    .opt = W("excess-initializers")
    .kind = .warning

excess_struct_init
    .msg = "excess elements in struct initializer"
    .opt = W("excess-initializers")
    .kind = .warning

excess_array_init
    .msg = "excess elements in array initializer"
    .opt = W("excess-initializers")
    .kind = .warning

str_init_too_long
    .msg = "initializer-string for char array is too long"
    .opt = W("excess-initializers")
    .kind = .warning

arr_init_too_long
    .msg = "cannot initialize type ({s})"
    .extra = .str
    .kind = .@"error"

invalid_typeof
    .msg = "'{s} typeof' is invalid"
    .extra = .str
    .kind = .@"error"

division_by_zero
    .msg = "{s} by zero is undefined"
    .extra = .str
    .opt = W("division-by-zero")
    .kind = .warning

division_by_zero_macro
    .msg = "{s} by zero in preprocessor expression"
    .extra = .str
    .kind = .@"error"

builtin_choose_cond
    .msg = "'__builtin_choose_expr' requires a constant expression"
    .kind = .@"error"

alignas_unavailable
    .msg = "'_Alignas' attribute requires integer constant expression"
    .kind = .@"error"

case_val_unavailable
    .msg = "case value must be an integer constant expression"
    .kind = .@"error"

enum_val_unavailable
    .msg = "enum value must be an integer constant expression"
    .kind = .@"error"

incompatible_array_init
    .msg = "cannot initialize array of type {s}"
    .extra = .str
    .kind = .@"error"

array_init_str
    .msg = "array initializer must be an initializer list or wide string literal"
    .kind = .@"error"

initializer_overrides
    .msg = "initializer overrides previous initialization"
    .opt = W("initializer-overrides")
    .kind = .warning
    .w_extra = true

previous_initializer
    .msg = "previous initialization"
    .kind = .note

invalid_array_designator
    .msg = "array designator used for non-array type '{s}'"
    .extra = .str
    .kind = .@"error"

negative_array_designator
    .msg = "array designator value {s} is negative"
    .extra = .str
    .kind = .@"error"

oob_array_designator
    .msg = "array designator index {s} exceeds array bounds"
    .extra = .str
    .kind = .@"error"

invalid_field_designator
    .msg = "field designator used for non-record type '{s}'"
    .extra = .str
    .kind = .@"error"

no_such_field_designator
    .msg = "record type has no field named '{s}'"
    .extra = .str
    .kind = .@"error"

empty_aggregate_init_braces
    .msg = "initializer for aggregate with no elements requires explicit braces"
    .kind = .@"error"

ptr_init_discards_quals
    .msg = "initializing {s} discards qualifiers"
    .extra = .str
    .opt = W("incompatible-pointer-types-discards-qualifiers")
    .kind = .warning

ptr_assign_discards_quals
    .msg = "assigning to {s} discards qualifiers"
    .extra = .str
    .opt = W("incompatible-pointer-types-discards-qualifiers")
    .kind = .warning

ptr_ret_discards_quals
    .msg = "returning {s} discards qualifiers"
    .extra = .str
    .opt = W("incompatible-pointer-types-discards-qualifiers")
    .kind = .warning

ptr_arg_discards_quals
    .msg = "passing {s} discards qualifiers"
    .extra = .str
    .opt = W("incompatible-pointer-types-discards-qualifiers")
    .kind = .warning

unknown_attribute
    .msg = "unknown attribute '{s}' ignored"
    .extra = .str
    .opt = W("unknown-attributes")
    .kind = .warning

ignored_attribute
    .msg = "{s}"
    .extra = .str
    .opt = W("ignored-attributes")
    .kind = .warning

invalid_fallthrough
    .msg = "fallthrough annotation does not directly precede switch label"
    .kind = .@"error"

cannot_apply_attribute_to_statement
    .msg = "'{s}' attribute cannot be applied to a statement"
    .extra = .str
    .kind = .@"error"

builtin_macro_redefined
    .msg = "redefining builtin macro"
    .opt = W("builtin-macro-redefined")
    .kind = .warning

feature_check_requires_identifier
    .msg = "builtin feature check macro requires a parenthesized identifier"
    .kind = .@"error"

missing_tok_builtin
    .msg = "missing '{s}', after builtin feature-check macro"
    .extra = .tok_id_expected
    .kind = .@"error"

gnu_label_as_value
    .msg = "use of GNU address-of-label extension"
    .opt = W("gnu-label-as-value")
    .kind = .off
    .pedantic = true

expected_record_ty
    .msg = "member reference base type '{s}' is not a structure or union"
    .extra = .str
    .kind = .@"error"

member_expr_not_ptr
    .msg = "member reference type '{s}' is not a pointer; did you mean to use '.'?"
    .extra = .str
    .kind = .@"error"

member_expr_ptr
    .msg = "member reference type '{s}' is a pointer; did you mean to use '->'?"
    .extra = .str
    .kind = .@"error"

no_such_member
    .msg = "no member named {s}"
    .extra = .str
    .kind = .@"error"

malformed_warning_check
    .msg = "{s} expected option name (e.g. \"-Wundef\")"
    .extra = .str
    .opt = W("malformed-warning-check")
    .kind = .warning
    .all = true

invalid_computed_goto
    .msg = "computed goto in function with no address-of-label expressions"
    .kind = .@"error"

pragma_warning_message
    .msg = "{s}"
    .extra = .str
    .opt = W("#pragma-messages")
    .kind = .warning

pragma_error_message
    .msg = "{s}"
    .extra = .str
    .kind = .@"error"

pragma_message
    .msg = "#pragma message: {s}"
    .extra = .str
    .kind = .note

pragma_requires_string_literal
    .msg = "pragma {s} requires string literal"
    .extra = .str
    .kind = .@"error"

poisoned_identifier
    .msg = "attempt to use a poisoned identifier"
    .kind = .@"error"

pragma_poison_identifier
    .msg = "can only poison identifier tokens"
    .kind = .@"error"

pragma_poison_macro
    .msg = "poisoning existing macro"
    .kind = .warning

newline_eof
    .msg = "no newline at end of file"
    .opt = W("newline-eof")
    .kind = .off
    .pedantic = true

empty_translation_unit
    .msg = "ISO C requires a translation unit to contain at least one declaration"
    .opt = W("empty-translation-unit")
    .kind = .off
    .pedantic = true

omitting_parameter_name
    .msg = "omitting the parameter name in a function definition is a C23 extension"
    .opt = W("c23-extensions")
    .kind = .warning
    .suppress_version = .c23

non_int_bitfield
    .msg = "bit-field has non-integer type '{s}'"
    .extra = .str
    .kind = .@"error"

negative_bitwidth
    .msg = "bit-field has negative width ({s})"
    .extra = .str
    .kind = .@"error"

zero_width_named_field
    .msg = "named bit-field has zero width"
    .kind = .@"error"

bitfield_too_big
    .msg = "width of bit-field exceeds width of its type"
    .kind = .@"error"

invalid_utf8
    .msg = "source file is not valid UTF-8"
    .kind = .@"error"

implicitly_unsigned_literal
    .msg = "integer literal is too large to be represented in a signed integer type, interpreting as unsigned"
    .opt = W("implicitly-unsigned-literal")
    .kind = .warning

invalid_preproc_operator
    .msg = "token is not a valid binary operator in a preprocessor subexpression"
    .kind = .@"error"

invalid_preproc_expr_start
    .msg = "invalid token at start of a preprocessor expression"
    .kind = .@"error"

c99_compat
    .msg = "using this character in an identifier is incompatible with C99"
    .opt = W("c99-compat")
    .kind = .off

unexpected_character
    .msg = "unexpected character <U+{X:0>4}>"
    .extra = .actual_codepoint
    .kind = .@"error"

invalid_identifier_start_char
    .msg = "character <U+{X:0>4}> not allowed at the start of an identifier"
    .extra = .actual_codepoint
    .kind = .@"error"

unicode_zero_width
    .msg = "identifier contains Unicode character <U+{X:0>4}> that is invisible in some environments"
    .opt = W("unicode-homoglyph")
    .extra = .actual_codepoint
    .kind = .warning

unicode_homoglyph
    .msg = "treating Unicode character <U+{X:0>4}> as identifier character rather than as '{u}' symbol"
    .extra = .codepoints
    .opt = W("unicode-homoglyph")
    .kind = .warning

meaningless_asm_qual
    .msg = "meaningless '{s}' on assembly outside function"
    .extra = .str
    .kind = .@"error"

duplicate_asm_qual
    .msg = "duplicate asm qualifier '{s}'"
    .extra = .str
    .kind = .@"error"

invalid_asm_str
    .msg = "cannot use {s} string literal in assembly"
    .extra = .str
    .kind = .@"error"

dollar_in_identifier_extension
    .msg = "'$' in identifier"
    .opt = W("dollar-in-identifier-extension")
    .kind = .off
    .pedantic = true

dollars_in_identifiers
    .msg = "illegal character '$' in identifier"
    .kind = .@"error"

expanded_from_here
    .msg = "expanded from here"
    .kind = .note

skipping_macro_backtrace
    .msg = "(skipping {d} expansions in backtrace; use -fmacro-backtrace-limit=0 to see all)"
    .extra = .unsigned
    .kind = .note

pragma_operator_string_literal
    .msg = "_Pragma requires exactly one string literal token"
    .kind = .@"error"

unknown_gcc_pragma
    .msg = "pragma GCC expected 'error', 'warning', 'diagnostic', 'poison'"
    .opt = W("unknown-pragmas")
    .kind = .off
    .all = true

unknown_gcc_pragma_directive
    .msg = "pragma GCC diagnostic expected 'error', 'warning', 'ignored', 'fatal', 'push', or 'pop'"
    .opt = W("unknown-pragmas")
    .kind = .warning
    .all = true

predefined_top_level
    .msg = "predefined identifier is only valid inside function"
    .opt = W("predefined-identifier-outside-function")
    .kind = .warning

incompatible_va_arg
    .msg = "first argument to va_arg, is of type '{s}' and not 'va_list'"
    .extra = .str
    .kind = .@"error"

too_many_scalar_init_braces
    .msg = "too many braces around scalar initializer"
    .opt = W("many-braces-around-scalar-init")
    .kind = .warning

uninitialized_in_own_init
    .msg = "variable '{s}' is uninitialized when used within its own initialization"
    .extra = .str
    .opt = W("uninitialized")
    .kind = .off
    .all = true

gnu_statement_expression
    .msg = "use of GNU statement expression extension"
    .opt = W("gnu-statement-expression")
    .kind = .off
    .suppress_gnu = true
    .pedantic = true

stmt_expr_not_allowed_file_scope
    .msg = "statement expression not allowed at file scope"
    .kind = .@"error"

gnu_imaginary_constant
    .msg = "imaginary constants are a GNU extension"
    .opt = W("gnu-imaginary-constant")
    .kind = .off
    .suppress_gnu = true
    .pedantic = true

plain_complex
    .msg = "plain '_Complex' requires a type specifier; assuming '_Complex double'"
    .kind = .warning

complex_int
    .msg = "complex integer types are a GNU extension"
    .opt = W("gnu-complex-integer")
    .suppress_gnu = true
    .kind = .off

qual_on_ret_type
    .msg = "'{s}' type qualifier on return type has no effect"
    .opt = W("ignored-qualifiers")
    .extra = .str
    .kind = .off
    .all = true

cli_invalid_standard
    .msg = "invalid standard '{s}'"
    .extra = .str
    .kind = .@"error"

cli_invalid_target
    .msg = "invalid target '{s}'"
    .extra = .str
    .kind = .@"error"

cli_invalid_emulate
    .msg = "invalid compiler '{s}'"
    .extra = .str
    .kind = .@"error"

cli_unknown_arg
    .msg = "unknown argument '{s}'"
    .extra = .str
    .kind = .@"error"

cli_error
    .msg = "{s}"
    .extra = .str
    .kind = .@"error"

cli_unused_link_object
    .msg = "{s}: linker input file unused because linking not done"
    .extra = .str
    .kind = .warning

cli_unknown_linker
    .msg = "unrecognized linker '{s}'"
    .extra = .str
    .kind = .@"error"

extra_semi
    .msg = "extra ';' outside of a function"
    .opt = W("extra-semi")
    .kind = .off
    .pedantic = true

func_field
    .msg = "field declared as a function"
    .kind = .@"error"

vla_field
    .msg = "variable length array fields extension is not supported"
    .kind = .@"error"

field_incomplete_ty
    .msg = "field has incomplete type '{s}'"
    .extra = .str
    .kind = .@"error"

flexible_in_union
    .msg = "flexible array member in union is not allowed"
    .kind = .@"error"
    .suppress_msvc = true

flexible_non_final
    .msg = "flexible array member is not at the end of struct"
    .kind = .@"error"

flexible_in_empty
    .msg = "flexible array member in otherwise empty struct"
    .kind = .@"error"
    .suppress_msvc = true

duplicate_member
    .msg = "duplicate member '{s}'"
    .extra = .str
    .kind = .@"error"

binary_integer_literal
    .msg = "binary integer literals are a GNU extension"
    .kind = .off
    .opt = W("gnu-binary-literal")
    .pedantic = true

gnu_va_macro
    .msg = "named variadic macros are a GNU extension"
    .opt = W("variadic-macros")
    .kind = .off
    .pedantic = true

builtin_must_be_called
    .msg = "builtin function must be directly called"
    .kind = .@"error"

va_start_not_in_func
    .msg = "'va_start' cannot be used outside a function"
    .kind = .@"error"

va_start_fixed_args
    .msg = "'va_start' used in a function with fixed args"
    .kind = .@"error"

va_start_not_last_param
    .msg = "second argument to 'va_start' is not the last named parameter"
    .opt = W("varargs")
    .kind = .warning

attribute_not_enough_args
    .msg = "'{s}' attribute takes at least {d} argument(s)"
    .kind = .@"error"
    .extra = .attr_arg_count

attribute_too_many_args
    .msg = "'{s}' attribute takes at most {d} argument(s)"
    .kind = .@"error"
    .extra = .attr_arg_count

attribute_arg_invalid
    .msg = "Attribute argument is invalid, expected {s} but got {s}"
    .kind = .@"error"
    .extra = .attr_arg_type

unknown_attr_enum
    .msg = "Unknown `{s}` argument. Possible values are: {s}"
    .kind = .@"error"
    .extra = .attr_enum

attribute_requires_identifier
    .msg = "'{s}' attribute requires an identifier"
    .kind = .@"error"
    .extra = .str

declspec_not_enabled
    .msg = "'__declspec' attributes are not enabled; use '-fdeclspec' or '-fms-extensions' to enable support for __declspec attributes"
    .kind = .@"error"

declspec_attr_not_supported
    .msg = "__declspec attribute '{s}' is not supported"
    .extra = .str
    .opt = W("ignored-attributes")
    .kind = .warning

deprecated_declarations
    .msg = "{s}"
    .extra = .str
    .opt = W("deprecated-declarations")
    .kind = .warning

deprecated_note
    .msg = "'{s}' has been explicitly marked deprecated here"
    .extra = .str
    .opt = W("deprecated-declarations")
    .kind = .note

unavailable
    .msg = "{s}"
    .extra = .str
    .kind = .@"error"

unavailable_note
    .msg = "'{s}' has been explicitly marked unavailable here"
    .extra = .str
    .kind = .note

warning_attribute
    .msg = "{s}"
    .extra = .str
    .kind = .warning
    .opt = W("attribute-warning")

error_attribute
    .msg = "{s}"
    .extra = .str
    .kind = .@"error"

ignored_record_attr
    .msg = "attribute '{s}' is ignored, place it after \"{s}\" to apply attribute to type declaration"
    .extra = .ignored_record_attr
    .kind = .warning
    .opt = W("ignored-attributes")

backslash_newline_escape
    .msg = "backslash and newline separated by space"
    .kind = .warning
    .opt = W("backslash-newline-escape")

array_size_non_int
    .msg = "size of array has non-integer type '{s}'"
    .extra = .str
    .kind = .@"error"

cast_to_smaller_int
    .msg = "cast to smaller integer type {s}"
    .extra = .str
    .kind = .warning
    .opt = W("pointer-to-int-cast")

gnu_switch_range
    .msg = "use of GNU case range extension"
    .opt = W("gnu-case-range")
    .kind = .off
    .pedantic = true

empty_case_range
    .msg = "empty case range specified"
    .kind = .warning

non_standard_escape_char
    .msg = "use of non-standard escape character '\\{s}'"
    .kind = .off
    .opt = W("pedantic")
    .extra = .invalid_escape

invalid_pp_stringify_escape
    .msg = "invalid string literal, ignoring final '\\'"
    .kind = .warning

vla
    .msg = "variable length array used"
    .kind = .off
    .opt = W("vla")

float_overflow_conversion
    .msg = "implicit conversion of non-finite value from {s} is undefined"
    .extra = .str
    .kind = .off
    .opt = W("float-overflow-conversion")

float_out_of_range
    .msg = "implicit conversion of out of range value from {s} is undefined"
    .extra = .str
    .kind = .warning
    .opt = W("literal-conversion")

float_zero_conversion
    .msg = "implicit conversion from {s}"
    .extra = .str
    .kind = .off
    .opt = W("float-zero-conversion")

float_value_changed
    .msg = "implicit conversion from {s}"
    .extra = .str
    .kind = .warning
    .opt = W("float-conversion")

float_to_int
    .msg = "implicit conversion turns floating-point number into integer: {s}"
    .extra = .str
    .kind = .off
    .opt = W("literal-conversion")

const_decl_folded
    .msg = "expression is not an integer constant expression; folding it to a constant is a GNU extension"
    .kind = .off
    .opt = W("gnu-folding-constant")
    .pedantic = true

const_decl_folded_vla
    .msg = "variable length array folded to constant array as an extension"
    .kind = .off
    .opt = W("gnu-folding-constant")
    .pedantic = true

redefinition_of_typedef
    .msg = "typedef redefinition with different types ({s})"
    .extra = .str
    .kind = .@"error"

undefined_macro
    .msg = "'{s}' is not defined, evaluates to 0"
    .extra = .str
    .kind = .off
    .opt = W("undef")

fn_macro_undefined
    .msg = "function-like macro '{s}' is not defined"
    .extra = .str
    .kind = .@"error"

preprocessing_directive_only
    .msg = "'{s}' must be used within a preprocessing directive"
    .extra = .tok_id_expected
    .kind = .@"error"

missing_lparen_after_builtin
    .msg = "Missing '(' after built-in macro '{s}'"
    .extra = .str
    .kind = .@"error"

offsetof_ty
    .msg = "offsetof requires struct or union type, '{s}' invalid"
    .extra = .str
    .kind = .@"error"

offsetof_incomplete
    .msg = "offsetof of incomplete type '{s}'"
    .extra = .str
    .kind = .@"error"

offsetof_array
    .msg = "offsetof requires array type, '{s}' invalid"
    .extra = .str
    .kind = .@"error"

pragma_pack_lparen
    .msg = "missing '(' after '#pragma pack' - ignoring"
    .kind = .warning
    .opt = W("ignored-pragmas")

pragma_pack_rparen
    .msg = "missing ')' after '#pragma pack' - ignoring"
    .kind = .warning
    .opt = W("ignored-pragmas")

pragma_pack_unknown_action
    .msg = "unknown action for '#pragma pack' - ignoring"
    .opt = W("ignored-pragmas")
    .kind = .warning

pragma_pack_show
    .msg = "value of #pragma pack(show) == {d}"
    .extra = .unsigned
    .kind = .warning

pragma_pack_int
    .msg = "expected #pragma pack parameter to be '1', '2', '4', '8', or '16'"
    .opt = W("ignored-pragmas")
    .kind = .warning

pragma_pack_int_ident
    .msg = "expected integer or identifier in '#pragma pack' - ignored"
    .opt = W("ignored-pragmas")
    .kind = .warning

pragma_pack_undefined_pop
    .msg = "specifying both a name and alignment to 'pop' is undefined"
    .kind = .warning

pragma_pack_empty_stack
    .msg = "#pragma pack(pop, ...) failed: stack empty"
    .opt = W("ignored-pragmas")
    .kind = .warning

cond_expr_type
    .msg = "used type '{s}' where arithmetic or pointer type is required"
    .extra = .str
    .kind = .@"error"

too_many_includes
    .msg = "#include nested too deeply"
    .kind = .@"error"

enumerator_too_small
    .msg = "ISO C restricts enumerator values to range of 'int' ({s} is too small)"
    .extra = .str
    .kind = .off
    .opt = W("pedantic")

enumerator_too_large
    .msg = "ISO C restricts enumerator values to range of 'int' ({s} is too large)"
    .extra = .str
    .kind = .off
    .opt = W("pedantic")

include_next
    .msg = "#include_next is a language extension"
    .kind = .off
    .pedantic = true
    .opt = W("gnu-include-next")

include_next_outside_header
    .msg = "#include_next in primary source file; will search from start of include path"
    .kind = .warning
    .opt = W("include-next-outside-header")

enumerator_overflow
    .msg = "overflow in enumeration value"
    .kind = .warning

enum_not_representable
    .msg = "incremented enumerator value {s} is not representable in the largest integer type"
    .kind = .warning
    .opt = W("enum-too-large")
    .extra = .pow_2_as_string

enum_too_large
    .msg = "enumeration values exceed range of largest integer"
    .kind = .warning
    .opt = W("enum-too-large")

enum_fixed
    .msg = "enumeration types with a fixed underlying type are a Clang extension"
    .kind = .off
    .pedantic = true
    .opt = W("fixed-enum-extension")

enum_prev_nonfixed
    .msg = "enumeration previously declared with nonfixed underlying type"
    .kind = .@"error"

enum_prev_fixed
    .msg = "enumeration previously declared with fixed underlying type"
    .kind = .@"error"

enum_different_explicit_ty
    # str will be like 'new' (was 'old'
    .msg = "enumeration redeclared with different underlying type {s})"
    .extra = .str
    .kind = .@"error"

enum_not_representable_fixed
    .msg = "enumerator value is not representable in the underlying type '{s}'"
    .extra = .str
    .kind = .@"error"

transparent_union_wrong_type
    .msg = "'transparent_union' attribute only applies to unions"
    .opt = W("ignored-attributes")
    .kind = .warning

transparent_union_one_field
    .msg = "transparent union definition must contain at least one field; transparent_union attribute ignored"
    .opt = W("ignored-attributes")
    .kind = .warning

transparent_union_size
    .msg = "size of field {s} bits) does not match the size of the first field in transparent union; transparent_union attribute ignored"
    .extra = .str
    .opt = W("ignored-attributes")
    .kind = .warning

transparent_union_size_note
    .msg = "size of first field is {d}"
    .extra = .unsigned
    .kind = .note

designated_init_invalid
    .msg = "'designated_init' attribute is only valid on 'struct' type'"
    .kind = .@"error"

designated_init_needed
    .msg = "positional initialization of field in 'struct' declared with 'designated_init' attribute"
    .opt = W("designated-init")
    .kind = .warning

ignore_common
    .msg = "ignoring attribute 'common' because it conflicts with attribute 'nocommon'"
    .opt = W("ignored-attributes")
    .kind = .warning

ignore_nocommon
    .msg = "ignoring attribute 'nocommon' because it conflicts with attribute 'common'"
    .opt = W("ignored-attributes")
    .kind = .warning

non_string_ignored
    .msg = "'nonstring' attribute ignored on objects of type '{s}'"
    .opt = W("ignored-attributes")
    .kind = .warning

local_variable_attribute
    .msg = "'{s}' attribute only applies to local variables"
    .extra = .str
    .opt = W("ignored-attributes")
    .kind = .warning

ignore_cold
    .msg = "ignoring attribute 'cold' because it conflicts with attribute 'hot'"
    .opt = W("ignored-attributes")
    .kind = .warning

ignore_hot
    .msg = "ignoring attribute 'hot' because it conflicts with attribute 'cold'"
    .opt = W("ignored-attributes")
    .kind = .warning

ignore_noinline
    .msg = "ignoring attribute 'noinline' because it conflicts with attribute 'always_inline'"
    .opt = W("ignored-attributes")
    .kind = .warning

ignore_always_inline
    .msg = "ignoring attribute 'always_inline' because it conflicts with attribute 'noinline'"
    .opt = W("ignored-attributes")
    .kind = .warning

invalid_noreturn
    .msg = "function '{s}' declared 'noreturn' should not return"
    .extra = .str
    .kind = .warning
    .opt = W("invalid-noreturn")

nodiscard_unused
    .msg = "ignoring return value of '{s}', declared with 'nodiscard' attribute"
    .extra = .str
    .kind = .warning
    .opt = W("unused-result")

warn_unused_result
    .msg = "ignoring return value of '{s}', declared with 'warn_unused_result' attribute"
    .extra = .str
    .kind = .warning
    .opt = W("unused-result")

invalid_vec_elem_ty
    .msg = "invalid vector element type '{s}'"
    .extra = .str
    .kind = .@"error"

vec_size_not_multiple
    .msg = "vector size not an integral multiple of component size"
    .kind = .@"error"

invalid_imag
    .msg = "invalid type '{s}' to __imag operator"
    .extra = .str
    .kind = .@"error"

invalid_real
    .msg = "invalid type '{s}' to __real operator"
    .extra = .str
    .kind = .@"error"

zero_length_array
    .msg = "zero size arrays are an extension"
    .kind = .off
    .pedantic = true
    .opt = W("zero-length-array")

old_style_flexible_struct
    .msg = "array index {s} is past the end of the array"
    .extra = .str
    .kind = .off
    .pedantic = true
    .opt = W("old-style-flexible-struct")

comma_deletion_va_args
    .msg = "token pasting of ',' and __VA_ARGS__ is a GNU extension"
    .kind = .off
    .pedantic = true
    .opt = W("gnu-zero-variadic-macro-arguments")
    .suppress_gcc = true

main_return_type
    .msg = "return type of 'main' is not 'int'"
    .kind = .warning
    .opt = W("main-return-type")

expansion_to_defined
    .msg = "macro expansion producing 'defined' has undefined behavior"
    .kind = .off
    .pedantic = true
    .opt = W("expansion-to-defined")

invalid_int_suffix
    .msg = "invalid suffix '{s}' on integer constant"
    .extra = .str
    .kind = .@"error"

invalid_float_suffix
    .msg = "invalid suffix '{s}' on floating constant"
    .extra = .str
    .kind = .@"error"

invalid_octal_digit
    .msg = "invalid digit '{c}' in octal constant"
    .extra = .ascii
    .kind = .@"error"

invalid_binary_digit
    .msg = "invalid digit '{c}' in binary constant"
    .extra = .ascii
    .kind = .@"error"

exponent_has_no_digits
    .msg = "exponent has no digits"
    .kind = .@"error"

hex_floating_constant_requires_exponent
    .msg = "hexadecimal floating constant requires an exponent"
    .kind = .@"error"

sizeof_returns_zero
    .msg = "sizeof returns 0"
    .kind = .warning
    .suppress_gcc = true
    .suppress_clang = true

declspec_not_allowed_after_declarator
    .msg = "'declspec' attribute not allowed after declarator"
    .kind = .@"error"

declarator_name_tok
    .msg = "this declarator"
    .kind = .note

type_not_supported_on_target
    .msg = "{s} is not supported on this target"
    .extra = .str
    .kind = .@"error"

bit_int
    .msg = "'_BitInt' in C17 and earlier is a Clang extension'"
    .kind = .off
    .pedantic = true
    .opt = W("bit-int-extension")
    .suppress_version = .c23

unsigned_bit_int_too_small
    .msg = "{s} must have a bit size of at least 1"
    .extra = .str
    .kind = .@"error"

signed_bit_int_too_small
    .msg = "{s} must have a bit size of at least 2"
    .extra = .str
    .kind = .@"error"

bit_int_too_big
    .msg = "{s} of bit sizes greater than " ++ std.fmt.comptimePrint("{d}", .{Properties.max_bits}) ++ " not supported"
    .extra = .str
    .kind = .@"error"

keyword_macro
    .msg = "keyword is hidden by macro definition"
    .kind = .off
    .pedantic = true
    .opt = W("keyword-macro")

ptr_arithmetic_incomplete
    .msg = "arithmetic on a pointer to an incomplete type '{s}'"
    .extra = .str
    .kind = .@"error"

callconv_not_supported
    .msg = "'{s}' calling convention is not supported for this target"
    .extra = .str
    .opt = W("ignored-attributes")
    .kind = .warning

pointer_arith_void
    .msg = "invalid application of '{s}' to a void type"
    .extra = .str
    .kind = .off
    .pedantic = true
    .opt = W("pointer-arith")

sizeof_array_arg
    .msg = "sizeof on array function parameter will return size of {s}"
    .extra = .str
    .kind = .warning
    .opt = W("sizeof-array-argument")

array_address_to_bool
    .msg = "address of array '{s}' will always evaluate to 'true'"
    .extra = .str
    .kind = .warning
    .opt = W("pointer-bool-conversion")

string_literal_to_bool
    .msg = "implicit conversion turns string literal into bool: {s}"
    .extra = .str
    .kind = .off
    .opt = W("string-conversion")

constant_expression_conversion_not_allowed
    .msg = "this conversion is not allowed in a constant expression"
    .kind = .note

invalid_object_cast
    .msg = "cannot cast an object of type {s}"
    .extra = .str
    .kind = .@"error"

cli_invalid_fp_eval_method
    .msg = "unsupported argument '{s}' to option '-ffp-eval-method='; expected 'source', 'double', or 'extended'"
    .extra = .str
    .kind = .@"error"

suggest_pointer_for_invalid_fp16
    .msg = "{s} cannot have __fp16 type; did you forget * ?"
    .extra = .str
    .kind = .@"error"

bitint_suffix
    .msg = "'_BitInt' suffix for literals is a C23 extension"
    .opt = W("c23-extensions")
    .kind = .warning
    .suppress_version = .c23

auto_type_extension
    .msg = "'__auto_type' is a GNU extension"
    .opt = W("gnu-auto-type")
    .kind = .off
    .pedantic = true

auto_type_not_allowed
    .msg = "'__auto_type' not allowed in {s}"
    .kind = .@"error"
    .extra = .str

auto_type_requires_initializer
    .msg = "declaration of variable '{s}' with deduced type requires an initializer"
    .kind = .@"error"
    .extra = .str

auto_type_requires_single_declarator
    .msg = "'__auto_type' may only be used with a single declarator"
    .kind = .@"error"

auto_type_requires_plain_declarator
    .msg = "'__auto_type' requires a plain identifier as declarator"
    .kind = .@"error"

invalid_cast_to_auto_type
    .msg = "invalid cast to '__auto_type'"
    .kind = .@"error"

auto_type_from_bitfield
    .msg = "cannot use bit-field as '__auto_type' initializer"
    .kind = .@"error"

array_of_auto_type
    .msg = "'{s}' declared as array of '__auto_type'"
    .kind = .@"error"
    .extra = .str

auto_type_with_init_list
    .msg = "cannot use '__auto_type' with initializer list"
    .kind = .@"error"

missing_semicolon
    .msg = "expected ';' at end of declaration list"
    .kind = .warning

tentative_definition_incomplete
    .msg = "tentative definition has type '{s}' that is never completed"
    .kind = .@"error"
    .extra = .str

forward_declaration_here
    .msg = "forward declaration of '{s}'"
    .kind = .note
    .extra = .str

gnu_union_cast
    .msg = "cast to union type is a GNU extension"
    .opt = W("gnu-union-cast")
    .kind = .off
    .pedantic = true

invalid_union_cast
    .msg = "cast to union type from type '{s}' not present in union"
    .kind = .@"error"
    .extra = .str

cast_to_incomplete_type
    .msg = "cast to incomplete type '{s}'"
    .kind = .@"error"
    .extra = .str

invalid_source_epoch
    .msg = "environment variable SOURCE_DATE_EPOCH must expand to a non-negative integer less than or equal to 253402300799"
    .kind = .@"error"

fuse_ld_path
    .msg = "'-fuse-ld=' taking a path is deprecated; use '--ld-path=' instead"
    .kind = .off
    .opt = W("fuse-ld-path")

invalid_rtlib
    .msg = "invalid runtime library name '{s}'"
    .kind = .@"error"
    .extra = .str

unsupported_rtlib_gcc
    .msg = "unsupported runtime library 'libgcc' for platform '{s}'"
    .kind = .@"error"
    .extra = .str

invalid_unwindlib
    .msg = "invalid unwind library name '{s}'"
    .kind = .@"error"
    .extra = .str

incompatible_unwindlib
    .msg = "--rtlib=libgcc requires --unwindlib=libgcc"
    .kind = .@"error"

gnu_asm_disabled
    .msg = "GNU-style inline assembly is disabled"
    .kind = .@"error"

extension_token_used
    .msg = "extension used"
    .kind = .off
    .pedantic = true
    .opt = W("language-extension-token")

complex_component_init
    .msg = "complex initialization specifying real and imaginary components is an extension"
    .opt = W("complex-component-init")
    .kind = .off
    .pedantic = true

complex_prefix_postfix_op
    .msg = "ISO C does not support '++'/'--' on complex type '{s}'"
    .opt = W("pedantic")
    .extra = .str
    .kind = .off

not_floating_type
    .msg = "argument type '{s}' is not a real floating point type"
    .extra = .str
    .kind = .@"error"

argument_types_differ
    .msg = "arguments are of different types ({s})"
    .extra = .str
    .kind = .@"error"

ms_search_rule
    .msg = "#include resolved using non-portable Microsoft search rules as: {s}"
    .extra = .str
    .opt = W("microsoft-include")
    .kind = .warning

ctrl_z_eof
    .msg = "treating Ctrl-Z as end-of-file is a Microsoft extension"
    .opt = W("microsoft-end-of-file")
    .kind = .off
    .pedantic = true

illegal_char_encoding_warning
    .msg = "illegal character encoding in character literal"
    .opt = W("invalid-source-encoding")
    .kind = .warning

illegal_char_encoding_error
    .msg = "illegal character encoding in character literal"
    .kind = .@"error"

ucn_basic_char_error
    .msg = "character '{c}' cannot be specified by a universal character name"
    .kind = .@"error"
    .extra = .ascii

ucn_basic_char_warning
    .msg = "specifying character '{c}' with a universal character name is incompatible with C standards before C23"
    .kind = .off
    .extra = .ascii
    .suppress_unless_version = .c23
    .opt = W("pre-c23-compat")

ucn_control_char_error
    .msg = "universal character name refers to a control character"
    .kind = .@"error"

ucn_control_char_warning
    .msg = "universal character name referring to a control character is incompatible with C standards before C23"
    .kind = .off
    .suppress_unless_version = .c23
    .opt = W("pre-c23-compat")

c89_ucn_in_literal
    .msg = "universal character names are only valid in C99 or later"
    .suppress_version = .c99
    .kind = .warning
    .opt = W("unicode")

four_char_char_literal
    .msg = "multi-character character constant"
    .opt = W("four-char-constants")
    .kind = .off

multi_char_char_literal
    .msg = "multi-character character constant"
    .kind = .off

missing_hex_escape
    .msg = "\\{c} used with no following hex digits"
    .kind = .@"error"
    .extra = .ascii

unknown_escape_sequence
    .msg = "unknown escape sequence '\\{s}'"
    .kind = .warning
    .opt = W("unknown-escape-sequence")
    .extra = .invalid_escape

attribute_requires_string
    .msg = "attribute '{s}' requires an ordinary string"
    .kind = .@"error"
    .extra = .str

unterminated_string_literal_warning
    .msg = "missing terminating '\"' character"
    .kind = .warning
    .opt = W("invalid-pp-token")

unterminated_string_literal_error
    .msg = "missing terminating '\"' character"
    .kind = .@"error"

empty_char_literal_warning
    .msg = "empty character constant"
    .kind = .warning
    .opt = W("invalid-pp-token")

empty_char_literal_error
    .msg = "empty character constant"
    .kind = .@"error"

unterminated_char_literal_warning
    .msg = "missing terminating ' character"
    .kind = .warning
    .opt = W("invalid-pp-token")

unterminated_char_literal_error
    .msg = "missing terminating ' character"
    .kind = .@"error"

unterminated_comment
    .msg = "unterminated comment"
    .kind = .@"error"

def_no_proto_deprecated
    .msg = "a function definition without a prototype is deprecated in all versions of C and is not supported in C23"
    .kind = .warning
    .opt = W("deprecated-non-prototype")

passing_args_to_kr
    .msg = "passing arguments to a function without a prototype is deprecated in all versions of C and is not supported in C23"
    .kind = .warning
    .opt = W("deprecated-non-prototype")

unknown_type_name
    .msg = "unknown type name '{s}'"
    .kind = .@"error"
    .extra = .str

label_compound_end
    .msg = "label at end of compound statement is a C23 extension"
    .opt = W("c23-extensions")
    .kind = .warning
    .suppress_version = .c23

u8_char_lit
    .msg = "UTF-8 character literal is a C23 extension"
    .opt = W("c23-extensions")
    .kind = .warning
    .suppress_version = .c23

malformed_embed_param
    .msg = "unexpected token in embed parameter"
    .kind = .@"error"

malformed_embed_limit
    .msg = "the limit parameter expects one non-negative integer as a parameter"
    .kind = .@"error"

duplicate_embed_param
    .msg = "duplicate embed parameter '{s}'"
    .kind = .warning
    .extra = .str
    .opt = W("duplicate-embed-param")

unsupported_embed_param
    .msg = "unsupported embed parameter '{s}' embed parameter"
    .kind = .warning
    .extra = .str
    .opt = W("unsupported-embed-param")

invalid_compound_literal_storage_class
    .msg = "compound literal cannot have {s} storage class"
    .kind = .@"error"
    .extra = .str

va_opt_lparen
    .msg = "missing '(' following __VA_OPT__"
    .kind = .@"error"

va_opt_rparen
    .msg = "unterminated __VA_OPT__ argument list"
    .kind = .@"error"

attribute_int_out_of_range
    .msg = "attribute value '{s}' out of range"
    .kind = .@"error"
    .extra = .str

identifier_not_normalized
    .msg = "'{s}' is not in NFC"
    .kind = .warning
    .extra = .normalized
    .opt = W("normalized")

c23_auto_plain_declarator
    .msg = "'auto' requires a plain identifier declarator"
    .kind = .@"error"

c23_auto_single_declarator
    .msg = "'auto' can only be used with a single declarator"
    .kind = .@"error"

c32_auto_requires_initializer
    .msg = "'auto' requires an initializer"
    .kind = .@"error"

c23_auto_scalar_init
    .msg = "'auto' requires a scalar initializer"
    .kind = .@"error"
